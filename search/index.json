[{"content":"一. 本次讲解\n​\tsql语句以及相关的建表的操作和设计思路\n二. 代码讲解：\n​\t1.创建数据库appDB\n1 2 3 -- 创建数据库 appDB 并切换到此数据库 CREATE DATABASE appDB; USE appDB; 创建并且使用数据库appDB ​\t2.管理员表\n1 2 3 4 5 6 7 8 9 10 -- 创建 ADMIN 表，用于存储管理员账户信息 CREATE TABLE `ADMIN`( `username` CHAR(15) PRIMARY KEY,-- 用户名，主键 `password` CHAR(12) NOT NULL-- 密码，不能为空 )ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 向 ADMIN 表插入管理员账户信息 INSERT INTO `ADMIN` VALUES (\u0026#39;root\u0026#39;,\u0026#39;12345678\u0026#39;); -- 查看 ADMIN 表中所有记录 SELECT* FROM ADMIN; 存储管理员的账号和密码字段（username, password）。 主要用于应用的后台管理。 主键：username。 ​\t3.用户表\n1 2 3 4 5 6 7 8 9 10 11 12 13 -- 创建 CUSTOMER 表，用于存储顾客账户信息 CREATE TABLE `CUSTOMER`( `username` CHAR(15) PRIMARY KEY,-- 用户名，主键 `password` CHAR(12) NOT NULL,-- 密码，不能为空 `address` VARCHAR(30) NOT NULL,-- 顾客地址，不能为空 `phone` CHAR(15) NOT NULL-- 顾客手机号，不能为空 )ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 向 CUSTOMER 表插入顾客账户信息 INSERT INTO `CUSTOMER` VALUES (\u0026#39;lonelyprince7\u0026#39;,\u0026#39;77777777\u0026#39;,\u0026#39;西南石油大学学生宿舍10-222\u0026#39;,\u0026#39;13844444444\u0026#39;), (\u0026#39;小张\u0026#39;,\u0026#39;55555555\u0026#39;,\u0026#39;西南石油大学学生宿舍17-555\u0026#39;,\u0026#39;18833344444\u0026#39;); -- 查看 CUSTOMER 表中所有记录 SELECT* FROM CUSTOMER; 存储顾客的用户名、密码、地址、电话（username, password, address, phone）。\n顾客可以使用此表与应用进行交互，例如下单、查看菜品等。\n主键：username。\n​\t4.餐馆表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 创建 RESTAURANT 表，用于存储餐馆账户信息 CREATE TABLE `RESTAURANT`( `username` CHAR(15) PRIMARY KEY,-- 餐馆名称，主键 `password` CHAR(12) NOT NULL,-- 餐馆密码，不能为空 `address` VARCHAR(30) NOT NULL,-- 餐馆地址，不能为空 `phone` CHAR(15) NOT NULL,-- 餐馆电话，不能为空 `img_res` VARCHAR(50)-- 餐馆图片路径 )ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 向 RESTAURANT 表插入餐馆账户信息 INSERT INTO `RESTAURANT` VALUES (\u0026#39;土风土味\u0026#39;,\u0026#39;77777777\u0026#39;,\u0026#39;四川省成都市新都区正因村128号\u0026#39;,\u0026#39;1314074\u0026#39;,\u0026#39;static/images/res_2.jpg\u0026#39;), (\u0026#39;统一面馆\u0026#39;,\u0026#39;88888888\u0026#39;,\u0026#39;四川省成都市新都区正熊猫大道69号\u0026#39;,\u0026#39;1884801\u0026#39;,\u0026#39;static/images/res_1.jpg\u0026#39;); -- 查看 RESTAURANT 表中所有记录 SELECT* FROM RESTAURANT; 存储餐馆的用户名、密码、地址、电话、图片路径（username, password, address, phone, img_res）。 每家餐馆都有自己的登录信息，可以管理自己的菜品。 主键：username。 ​\t5.菜品表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -- 创建 DISHES 表，用于存储菜品信息 CREATE TABLE `DISHES`( `dishname` CHAR(15) PRIMARY KEY,-- 菜品名称，主键 `restaurant` CHAR(15) NOT NULL,-- 餐馆名称，外键，不能为空 `dishinfo` VARCHAR(50) , -- 菜品信息 `nutriention` VARCHAR(30),-- 营养信息 `price` DECIMAL(5,2) NOT NULL,-- 价格，不能为空 `sales` INT(5) NOT NULL, -- 销量 `imgsrc` VARCHAR(50), -- 菜品图片路径 `isSpecialty` BOOLEAN, -- 是否为特色菜（布尔类型） FOREIGN KEY (restaurant) REFERENCES RESTAURANT(username)-- 关联到餐馆表的用户名字段 )ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 向 DISHES 表插入菜品信息 INSERT INTO DISHES VALUES (\u0026#39;水煮鱼\u0026#39;, \u0026#39;土风土味\u0026#39;, \u0026#39;松江鲈鱼，巨口细鳞，肉质鲜嫩\u0026#39;, \u0026#39;蛋白质，维生素\u0026#39;, 26.00, 0, \u0026#39;static/images/img_2.jpg\u0026#39;, 0), (\u0026#39;香锅牛肉\u0026#39;, \u0026#39;土风土味\u0026#39;, \u0026#39;该香锅牛肉味道鲜美，有土豆藕片等蔬菜可添加\u0026#39;, \u0026#39;蛋白质，维生素\u0026#39;, 14.50, 0, \u0026#39;static/images/img_5.jpg\u0026#39;, 1), (\u0026#39;牛肉面\u0026#39;, \u0026#39;统一面馆\u0026#39;, \u0026#39;老坛酸菜牛肉面，麻辣酸爽，美味享受\u0026#39;, \u0026#39;蛋白质，淀粉，维生素\u0026#39;, 13.00, 1, \u0026#39;static/images/img_7.jpg\u0026#39;, 0); -- 查看 DISHES 表中所有记录 SELECT* FROM DISHES; 存储各个餐馆的菜品信息，包括菜名、餐馆名称、菜品描述、营养成分、价格、销量、图片路径以及是否是特色菜（dishname, restaurant, dishinfo, nutriention, price, sales, imgsrc, isSpecialty）。 restaurant 字段为外键，关联到 RESTAURANT 表中的 username，以指定每个菜品所属的餐馆。 主键：dishname。 ​\t6.购物车表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -- 创建 SHOPPINGCART 表，用于存储顾客购物车信息 CREATE TABLE `SHOPPINGCART`( `username` CHAR(15),-- 顾客用户名，外键 `restaurant` CHAR(15),-- 餐馆名称，外键 `dishname` CHAR(15),-- 菜品名称，外键 `price` DECIMAL(5,2) NOT NULL,-- 菜品价格 `img_res` VARCHAR(50), -- 菜品图片路径 FOREIGN KEY (username) REFERENCES CUSTOMER(username),-- 关联到顾客表的用户名字段 FOREIGN KEY (restaurant) REFERENCES RESTAURANT(username),-- 关联到餐馆表的用户名字段 FOREIGN KEY (dishname) REFERENCES DISHES(dishname), -- 关联到菜品表的菜品名称字段 PRIMARY KEY (username,restaurant,dishname)-- 联合主键，确保每个顾客、餐馆和菜品的组合唯一 )ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 向 SHOPPINGCART 表插入购物车信息 INSERT INTO `SHOPPINGCART` VALUES (\u0026#39;lonelyprince7\u0026#39;,\u0026#39;土风土味\u0026#39;,\u0026#39;水煮鱼\u0026#39;,26.00,\u0026#39;static/images/img_2.jpg\u0026#39;); -- 查看 SHOPPINGCART 表中所有记录 SELECT* FROM SHOPPINGCART; 追踪顾客加入购物车的菜品信息，包括顾客用户名、餐馆名、菜品名、价格、图片路径（username, restaurant, dishname, price, img_res）。\n外键：\n​\tusername 关联 CUSTOMER 表，表示购物车归属于哪个顾客。\n​\trestaurant 和 dishname 分别关联 RESTAURANT 和 DISHES 表，以指定购物车中的菜品来源。\n复合主键：(username, restaurant, dishname)，确保每个购物车中的条目在顾客、餐馆和菜品的组合下是唯一的。\n​\t7.订单评论表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 -- 创建 ORDER_COMMENT 表，用于存储顾客对订单的评价信息 CREATE TABLE `ORDER_COMMENT`( `orderID` CHAR(15) PRIMARY KEY,-- 订单编号，主键 `username` CHAR(15) NOT NULL,-- 顾客用户名，外键 `restaurant` VARCHAR(15) NOT NULL,-- 餐馆名称，外键 `isFinished` BOOLEAN, -- 订单是否完成（布尔类型） CHECK(isFinished=1 or isFinished =0), -- 检查 isFinished 值必须为 1 或 0 `cost` DECIMAL(5,2) NOT NULL,-- 订单总金额，不能为空 `c_rank` TINYINT(1),-- 评价等级（1-5） CHECK(c_rank BETWEEN 1 AND 5),-- 检查 c_rank 值必须在 1 到 5 之间 `text` VARCHAR(50),-- 评价内容 `transactiontime` TIMESTAMP(0) NOT NULL,-- 交易时间，不能为空 CHECK(transactiontime BETWEEN \u0026#39;1970-01-01 00:00:01\u0026#39; AND \u0026#39;2038-01-19 03:14:07\u0026#39;),-- 检查交易时间在合法范围内 FOREIGN KEY (username) REFERENCES CUSTOMER(username),-- 关联到顾客表的用户名字段 FOREIGN KEY (restaurant) REFERENCES RESTAURANT(username)-- 关联到餐馆表的用户名字段 )ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 向 ORDER_COMMENT 表插入订单评价信息 INSERT INTO ORDER_COMMENT VALUES (\u0026#39;1444000\u0026#39;, \u0026#39;lonelyprince7\u0026#39;, \u0026#39;土风土味\u0026#39;, 1, 26.00, 1, \u0026#39;鱼肉非常不新鲜，不推荐\u0026#39;, \u0026#39;2020-11-7 13:14:07\u0026#39;), (\u0026#39;1445000\u0026#39;, \u0026#39;lonelyprince7\u0026#39;, \u0026#39;土风土味\u0026#39;, 1, 14.50, 3, \u0026#39;牛肉太少，蔬菜太多，希望下次多放点牛肉\u0026#39;, \u0026#39;2020-10-13 20:29:13\u0026#39;), (\u0026#39;1446000\u0026#39;, \u0026#39;小张\u0026#39;, \u0026#39;统一面馆\u0026#39;, 0, 13.00, 5, \u0026#39;分量足，味道好，推荐\u0026#39;, \u0026#39;2020-10-27 15:45:21\u0026#39;); -- 查看 ORDER_COMMENT 表中所有记录 SELECT* FROM ORDER_COMMENT; 存储顾客的订单记录以及评价内容，包括订单 ID、用户名、餐馆名、订单是否完成、花费、评分、评论文本、交易时间（orderID, username, restaurant, isFinished, cost, c_rank, text, transactiontime）。\n外键：\n​\tusername 关联 CUSTOMER 表。\n​\trestaurant 关联 RESTAURANT 表。\n约束条件：\n​\tisFinished 限制为 0 或 1，表示订单未完成或已完成。\n​\tc_rank 限制在 1 到 5 之间，用于评分。\n​\ttransactiontime 需在合法的时间范围内。\n主键：orderID。\n​\t8.简易的ER图\n","date":"2024-11-12T14:12:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E5%85%AB/","title":"外卖订餐系统-（八）"},{"content":"一. 本次讲解\n​\t页面指引、个人中心页面、修改个人信息页面、修改密码页面、商家查看订单、完结\n二. 代码讲解：\n​\t1.页面指引\n1 2 3 4 5 @app.route(\u0026#39;/MerchantIndex\u0026#39;) # 渲染并返回 \u0026#39;MerchantIndex.html\u0026#39; 模板页面 def Merchantindexpage(): return render_template(\u0026#39;MerchantIndex.html\u0026#39;) 此代码段用于定义 Flask Web 应用中的一个路由，使用户能够通过访问 /MerchantIndex 路径来加载并查看 MerchantIndex.html 页面。\n​\t2.个人中心页面\n1 2 3 4 5 # 个人中心页面 @app.route(\u0026#39;/MerchantPersonal\u0026#39;) # 渲染并返回 \u0026#39;MerchantPersonal.html\u0026#39; 模板页面 def MpersonalPage(): return render_template(\u0026#39;MerchantPersonal.html\u0026#39;) 该代码段定义了一个 Flask Web 应用中的路由，使用户能够通过访问 /MerchantPersonal 路径进入商户的个人中心页面 MerchantPersonal.html。\n​\t3.修改个人信息页面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 修改个人信息页面 @app.route(\u0026#39;/MerchantModifyPerInfo\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def MerchantModifyPerInfo(): msg = \u0026#34;\u0026#34; # 如果请求方法为 GET，直接返回页面并传递用户名信息 if request.method == \u0026#39;GET\u0026#39;: return render_template(\u0026#39;MerchantModifyPerInfo.html\u0026#39;, username=username) # 如果请求方法为 POST，处理表单提交的数据 if request.method == \u0026#39;POST\u0026#39;: # 从表单获取用户填写的地址和电话号码信息 address = request.form[\u0026#39;address\u0026#39;] phonenum = request.form[\u0026#39;phonenum\u0026#39;] # 获取上传的图片文件 f = request.files[\u0026#39;imagesrc\u0026#39;] filename = \u0026#39;\u0026#39; # 检查文件名是否符合要求 if f !=\u0026#39;\u0026#39; and allowed_file(f.filename): filename = secure_filename(f.filename) # 保存文件到指定路径 if filename != \u0026#39;\u0026#39;: f.save(\u0026#39;static/images/\u0026#39; + filename) imgsrc = \u0026#39;static/images/\u0026#39; + filename # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 构建更新个人信息的 SQL 语句，根据是否上传图片来选择更新内容 if filename == \u0026#39;\u0026#39;:\t# 如果没有上传图片，仅更新地址和电话信息 sql = \u0026#34;Update {} SET address = \u0026#39;{}\u0026#39;, phone = \u0026#39;{}\u0026#39; where username = \u0026#39;{}\u0026#39;\u0026#34;.format(userRole, address, phonenum,username) else: # 如果有上传图片，更新地址、电话和图片路径 sql = \u0026#34;Update {} SET address = \u0026#39;{}\u0026#39;, phone = \u0026#39;{}\u0026#39;,img_res = \u0026#39;{}\u0026#39; where username = \u0026#39;{}\u0026#39;\u0026#34;.format(userRole, address, phonenum, imgsrc, username) try: cursor.execute(sql) db.commit() msg = \u0026#34;done\u0026#34; except ValueError as e: msg = \u0026#34;fail\u0026#34; return render_template(\u0026#39;MerchantModifyPerInfo.html\u0026#39;, messages=msg, username=username) ​\t该代码段定义了一个 Flask 路由 /MerchantModifyPerInfo，用户可通过此路径修改个人信息。支持 GET 和 POST 两种请求方法：GET 显示页面，POST 处理提交的数据，包括更新地址、电话号码和头像，并将修改后的信息存储到数据库。\n​\t4.修改密码页面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 修改密码页面 @app.route(\u0026#39;/MerchantModifyPwd\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def MerModifyPassword(): msg = \u0026#34;\u0026#34; # 如果请求方法为 GET，直接返回页面并传递用户名信息 if request.method == \u0026#39;GET\u0026#39;: return render_template(\u0026#39;MerchantModifyPwd.html\u0026#39;, username=username) # 如果请求方法为 POST，处理表单提交的数据 if request.method == \u0026#39;POST\u0026#39;: # 从表单获取用户输入的两次密码 psw1 = request.form[\u0026#39;psw1\u0026#39;] psw2 = request.form[\u0026#39;psw2\u0026#39;] # 两次输入密码是否相同 if psw1 == psw2: # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 构建更新密码的 SQL 语句 sql = \u0026#34;Update {} SET password = \u0026#39;{}\u0026#39; where username = \u0026#39;{}\u0026#39;\u0026#34;.format(userRole, psw1, username) try: cursor.execute(sql) db.commit() msg = \u0026#34;done\u0026#34; except ValueError as e: msg = \u0026#34;fail\u0026#34; # 构建更新密码的 SQL 语句 return render_template(\u0026#39;MerchantModifyPwd.html\u0026#39;, messages=msg, username=username) else: # 如果两次输入的密码不一致 msg = \u0026#34;not equal\u0026#34; return render_template(\u0026#39;MerchantModifyPwd.html\u0026#39;, messages=msg, username=username) 该代码段定义了一个 Flask 路由 /MerchantModifyPwd，用户可通过此路径修改个人密码。支持 GET 和 POST 两种请求方法：GET 显示页面，POST 处理密码更新。系统检查两次密码是否一致并更新数据库，最后将操作结果返回页面显示。\n​\t5.商家查看订单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 #商家查看订单 @app.route(\u0026#39;/MerchantOrderPage\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def MerchantOrderPage(): msg = \u0026#34;\u0026#34; # 全局变量，记录未完成订单数量 global notFinishedNum # GET 请求：用于初次加载页面和显示订单信息 if request.method == \u0026#39;GET\u0026#39;: msg = \u0026#34;\u0026#34; # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询未完成订单数量 presql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE restaurant = \u0026#39;%s\u0026#39; AND isFinished = 0\u0026#34; % username cursor.execute(presql) res1 = cursor.fetchall() notFinishedNum = len(res1) # 查询所有订单信息 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE restaurant = \u0026#39;%s\u0026#39;\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() # 判断是否有订单记录 if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, messages=msg) # POST 请求：用于执行特定操作，如排序和过滤订单 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按时间排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询并按时间排序 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; Order BY transactiontime DESC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, result=res, messages=msg, notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, messages=msg) elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按价格排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 按价格升序排序订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; Order BY cost ASC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, messages=msg, notFinishedNum=notFinishedNum) elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;未完成订单\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询未完成订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 0 \u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=len(res)) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, messages=msg, notFinishedNum=notFinishedNum) else: return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, messages=msg) 该代码段定义了一个 Flask 路由 /MerchantOrderPage，用户可以通过此路径查看和管理订单。支持 GET 和 POST 请求，通过 POST 可实现按时间和价格排序以及仅查看未完成订单的功能，并将查询结果返回页面显示。\n​\t6.完结\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def parse_args(): \u0026#34;\u0026#34;\u0026#34;解析命令行参数并返回包含这些参数的命名空间对象。 Returns: args: 包含解析后命令行参数的命名空间对象。 \u0026#34;\u0026#34;\u0026#34; # 创建用于解析命令行参数的解析器对象，并为脚本添加描述。 parser = argparse.ArgumentParser(description=__doc__) # 添加MySQL root密码的参数，默认值为“xxxxxxxx”。 parser.add_argument( \u0026#39;--mysql_pwd\u0026#39;, help=\u0026#39;the mysql root password\u0026#39;, default=\u0026#34;xxxxxxxx\u0026#34; ) # 添加要使用的数据库名称参数，默认值为“appdb”。 parser.add_argument( \u0026#39;--db_name\u0026#39;, help=\u0026#39;which database to use\u0026#39;, default=\u0026#34;appdb\u0026#34; ) # 解析用户提供的命令行参数并返回。 args = parser.parse_args() return args if __name__ == \u0026#39;__main__\u0026#39;: # 解析命令行参数以获取MySQL密码和数据库名称。 args = parse_args() # 从解析对象中提取单个参数。 mysql_pwd = args.mysql_pwd db_name = args.db_name # 启动应用程序服务器，在localhost的9090端口上监听 app.run(host=\u0026#39;localhost\u0026#39;, port=\u0026#39;9090\u0026#39;) 用途：该脚本用于解析命令行参数，以便用户指定MySQL密码 (--mysql_pwd) 和数据库名称 (--db_name)，默认值分别为 \u0026quot;xxxxxxxx\u0026quot; 和 \u0026quot;appdb\u0026quot;。\n执行：在运行脚本时，解析命令行参数并将其应用到程序中，启动应用服务器，监听 localhost:9090。\n","date":"2024-11-12T14:12:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E4%B8%83/","title":"外卖订餐系统-（七）"},{"content":"一. 本次讲解\n​\t商家查看菜品信息、商家修改菜品信息、商家添加新菜品\n二. 代码讲解：\n​\t1.商家查看菜品信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #商家查看菜品信息 @app.route(\u0026#39;/MerchantMenu\u0026#39;,methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def MerchantMenu(): msg = \u0026#34;\u0026#34; # 处理 GET 请求：用于显示商家的所有菜品信息 if request.method == \u0026#39;GET\u0026#39;: msg = \u0026#34;\u0026#34; # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询当前商家(username)的所有菜品信息 sql = \u0026#34;SELECT * FROM DISHES WHERE restaurant = \u0026#39;%s\u0026#39;\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() # 如果有查询结果，返回菜品信息页面，显示结果 if len(res) != 0: msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MerchantMenu.html\u0026#39;, username=username, result=res, messages=msg) else: # 如果没有结果，返回页面并显示“无菜品”信息 msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MerchantMenu.html\u0026#39;, username=username, messages=msg) # 处理 POST 请求：用于执行删除菜品或按销量或价格排序 if request.method == \u0026#39;POST\u0026#39;: # 删除指定菜品 if request.form[\u0026#34;action\u0026#34;] == \u0026#34;删除该菜品\u0026#34;: # 获取菜品名称和所属餐厅 dishname = request.form.get(\u0026#39;dishname\u0026#39;) rest = request.form.get(\u0026#39;restaurant\u0026#39;) db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 执行删除操作 sql = \u0026#34;DELETE FROM DISHES where dishname = \u0026#39;{}\u0026#39; and restaurant = \u0026#39;{}\u0026#39;\u0026#34;.format(dishname,rest) try: cursor.execute(sql) db.commit() dmsg = \u0026#34;done\u0026#34; except ValueError as e: dmsg = \u0026#34;fail\u0026#34; return render_template(\u0026#39;MerchantMenu.html\u0026#39;, dishname=dishname, rest=rest, dmessages=dmsg) # 按销量排序显示菜品 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按销量排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 执行查询，按销量从高到低排序 sql = \u0026#34;SELECT * FROM DISHES WHERE restaurant = \u0026#39;%s\u0026#39; Order BY sales DESC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MerchantMenu.html\u0026#39;,username=username, result=res, messages=msg) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MerchantMenu.html\u0026#39;, username=username, messages=msg) # 按价格排序显示菜品 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按价格排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 执行查询，按价格从高到低排序 sql = \u0026#34;SELECT * FROM DISHES WHERE restaurant = \u0026#39;%s\u0026#39; Order BY price DESC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MerchantMenu.html\u0026#39;, username=username, result=res, messages=msg) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MerchantMenu.html\u0026#39;,username=username,messages=msg) ​\t2.商家修改菜品信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #商家修改菜品信息 @app.route(\u0026#39;/MenuModify\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def MenuModify(): msg = \u0026#34;\u0026#34; # 如果操作为“修改菜品信息”，则加载菜品信息修改页面 if request.form[\u0026#34;action\u0026#34;] == \u0026#34;修改菜品信息\u0026#34;: # 从表单获取菜品和商家信息 dishname = request.form[\u0026#39;dishname\u0026#39;]#传递过去菜品名 rest = request.form[\u0026#39;restaurant\u0026#39;]#传递过去商家名 dishinfo = request.form[\u0026#39;dishinfo\u0026#39;] nutriention = request.form.get(\u0026#39;nutriention\u0026#39;) price = request.form.get(\u0026#39;price\u0026#39;) isSpecialty = request.form.get(\u0026#39;isSpecialty\u0026#39;) return render_template(\u0026#39;MenuModify.html\u0026#39;, dishname=dishname, rest=rest, dishinfo=dishinfo, nutriention=nutriention, price=price, username=username, messages=msg,isSpecialty=isSpecialty) # 如果操作为“提交修改”，则执行数据库更新操作 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;提交修改\u0026#34;: # 获取表单中的修改数据 dishname = request.form.get(\u0026#39;dishname\u0026#39;) rest = request.form.get(\u0026#39;rest\u0026#39;) dishinfo = request.form[\u0026#39;dishinfo\u0026#39;] nutriention = request.form.get(\u0026#39;nutriention\u0026#39;) price = request.form.get(\u0026#39;price\u0026#39;) isSpecialty = int(request.form.get(\u0026#39;isSpecialty\u0026#39;)) f = request.files[\u0026#39;imagesrc\u0026#39;] filename = \u0026#39;\u0026#39;# 默认文件名为空 # 检查是否有上传的图片文件且格式允许 if f !=\u0026#39;\u0026#39; and allowed_file(f.filename): filename = secure_filename(f.filename) # 如果有有效文件名，保存文件到指定目录 if filename != \u0026#39;\u0026#39;: f.save(\u0026#39;static/images/\u0026#39; + filename) imgsrc = \u0026#39;static/images/\u0026#39; + filename # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 根据是否有新图片，生成不同的 SQL 语句 if filename == \u0026#39;\u0026#39;: # 没有图片时，不更新图片路径字段 sql = \u0026#34;Update DISHES SET dishinfo = \u0026#39;{}\u0026#39;, nutriention = \u0026#39;{}\u0026#39;, price = {} , isSpecialty = {} where dishname = \u0026#39;{}\u0026#39; and restaurant = \u0026#39;{}\u0026#39;\u0026#34;.format(dishinfo,nutriention,price,isSpecialty,dishname,rest) else: # 有图片时，更新图片路径字段 sql = \u0026#34;Update DISHES SET dishinfo = \u0026#39;{}\u0026#39;, nutriention = \u0026#39;{}\u0026#39;, price = {} ,imgsrc = \u0026#39;{}\u0026#39;, isSpecialty = {} where dishname = \u0026#39;{}\u0026#39; and restaurant = \u0026#39;{}\u0026#39;\u0026#34;.format(dishinfo,nutriention,price,imgsrc,isSpecialty,dishname,rest) try: cursor.execute(sql) #事务中的更改保存到数据库中 db.commit() msg = \u0026#34;done\u0026#34; except ValueError as e: msg = \u0026#34;fail\u0026#34; # 渲染模板，返回修改后的信息 return render_template(\u0026#39;MenuModify.html\u0026#39;,dishname=dishname, rest=rest, username=username, messages=msg) 该路由函数 MenuModify 允许商家修改菜品信息。根据请求表单中的 action 字段，它处理两种操作：\n修改菜品信息： 如果 action 是 \u0026quot;修改菜品信息\u0026quot;，则从表单中获取现有的菜品信息（如描述、营养信息、价格、是否为特色菜等），并将这些信息显示在 MenuModify.html 页面上，以便商家进行编辑。 提交修改： 如果 action 是 \u0026quot;提交修改\u0026quot;，则会使用用户提供的新的菜品信息更新数据库。 如果上传了新图片，也会将图片更新。图片将保存到静态目录中，同时图片路径会存储在数据库中。 构造一个 SQL UPDATE 语句，如果有新图片，则包含新的图片路径。 修改后的信息保存到数据库中，并将操作成功或失败的消息渲染在 MenuModify.html 页面上。 ​\t3.商家添加新菜品\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #商家添加新菜品 @app.route(\u0026#39;/MenuAdd\u0026#39;,methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def MenuAdd(): msg = \u0026#34;\u0026#34; rest= \u0026#34;\u0026#34;# 商家名称变量 # 判断请求表单中的 \u0026#34;action\u0026#34; 字段 if request.form[\u0026#34;action\u0026#34;] == \u0026#34;增加菜品\u0026#34;: rest = request.form[\u0026#39;restaurant\u0026#39;]#传递过去商家名 return render_template(\u0026#39;MenuAdd.html\u0026#39;,rest=rest) elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;确认增加\u0026#34;: # 获取表单中传递的菜品信息 dishname = request.form.get(\u0026#39;dishname\u0026#39;) # 菜品名 rest = request.form.get(\u0026#39;rest\u0026#39;)# 商家名 dishinfo = request.form.get(\u0026#39;dishinfo\u0026#39;)# 菜品描述信息 nutriention = request.form.get(\u0026#39;nutriention\u0026#39;)# 营养信息 price = request.form.get(\u0026#39;price\u0026#39;)# 价格 # 菜品图片文件 f = request.files[\u0026#39;imagesrc\u0026#39;] # 是否特色菜，转为整型 isSpecialty = int(request.form.get(\u0026#39;isSpecialty\u0026#39;)) # 检查图片文件是否有效且格式允许 if f and allowed_file(f.filename): filename = secure_filename(f.filename) f.save(\u0026#39;static/images/\u0026#39; + filename) imgsrc = \u0026#39;static/images/\u0026#39; + filename # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 检查菜品是否已经存在 sql1 = \u0026#34;SELECT * from DISHES where dishname = \u0026#39;{}\u0026#39; \u0026#34;.format(dishname) cursor.execute(sql1) db.commit() res1 = cursor.fetchall() # 计算结果条数，如果有数据，表示菜品已存在 num = 0 for row in res1: num = num + 1 # 如果已经存在该商家 if num == 1:# 如果菜品已经存在，返回失败消息 msg = \u0026#34;fail1\u0026#34; else: # 如果菜品不存在，执行插入操作 sql2 = \u0026#34;insert into DISHES values (\u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;,\u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;,{}, {},\u0026#39;{}\u0026#39;, {}) \u0026#34;.format(dishname,rest,dishinfo,nutriention,price,0,imgsrc,isSpecialty) try: cursor.execute(sql2) db.commit() msg = \u0026#34;done\u0026#34; except ValueError as e: msg = \u0026#34;fail\u0026#34; return render_template(\u0026#39;MenuAdd.html\u0026#39;, messages=msg, username=username) 该路由函数 MenuAdd 处理商家添加新菜品的操作，支持以下两个主要功能：\n显示添加菜品页面： 如果请求的 action 为 \u0026quot;增加菜品\u0026quot;，则根据商家名称加载 MenuAdd.html 页面，准备输入菜品信息。 提交添加的菜品： 如果 action 为 \u0026quot;确认增加\u0026quot;，则获取提交的菜品信息（如菜品名、描述、营养信息、价格、特色菜状态以及图片）。 检查数据库中是否已经存在同名菜品，如果存在，则返回错误消息。 如果菜品不存在，程序会将新菜品信息插入到数据库中，并保存上传的图片。 根据添加结果显示成功或失败消息。 ​\n","date":"2024-11-12T00:42:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E5%85%AD/","title":"外卖订餐系统-（六）"},{"content":"一. 本次讲解\n​\n二. 代码讲解：\n​\t1. 管理与页面历史相关\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import flask from flask import Blueprint import db # 创建一个名为 \u0026#39;page_history\u0026#39; 的 Blueprint，负责管理与页面历史相关的路由 page_history = Blueprint(\u0026#39;page_history\u0026#39;, __name__) # 定义一个路由，当访问路径为 \u0026#39;/history_\u0026lt;gid\u0026gt;_\u0026lt;sel\u0026gt;_\u0026lt;buy\u0026gt;\u0026#39; 时，调用 history 函数 @page_history.route(\u0026#39;/history_\u0026lt;gid\u0026gt;_\u0026lt;sel\u0026gt;_\u0026lt;buy\u0026gt;\u0026#39;) def history(gid, sel, buy): \u0026#34;\u0026#34;\u0026#34; 渲染历史页面模板 :param gid: 商品ID :param sel: 卖家ID :param buy: 买家ID :return: 渲染历史页面模板 \u0026#34;\u0026#34;\u0026#34; return flask.render_template(\u0026#39;./static/templates/history.html\u0026#39;) # 渲染指定的 HTML 模板 ​\t2. 处理登录页面相关\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import flask from flask import Blueprint import db # 创建一个Blueprint实例，用于处理登录页面相关的路由 page_login = Blueprint(\u0026#39;page_login\u0026#39;, __name__) # 定义/login路由，支持GET和POST请求 @page_login.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): \u0026#34;\u0026#34;\u0026#34; 处理登录页面的请求 :return: - 当请求方法为GET时，返回登录页面的HTML。 - 当请求方法为POST时，接收表单提交的用户名和密码，与数据库中的信息进行验证，返回验证结果。 \u0026#34;\u0026#34;\u0026#34; if flask.request.method == \u0026#39;POST\u0026#39;: # 如果请求方法是POST，表示提交了登录表单 # 从表单中获取用户名和密码 name = flask.request.form.get(\u0026#39;name\u0026#39;) psw = flask.request.form.get(\u0026#39;psw\u0026#39;) # 如果用户名或密码为空，返回403错误 if name is None or psw is None: return flask.make_response(\u0026#39;Failed\u0026#39;, 403) # 返回403错误，表示失败 # 调用db模块中的login_check函数，验证用户名和密码是否匹配 check_res, uid, authority = db.login_check(name, psw) # 如果验证成功（check_res == 0），返回success以及用户ID if check_res == 0: return \u0026#39;success\u0026#39; + str(uid) else: # 如果验证失败，返回fail return \u0026#39;fail\u0026#39; if flask.request.method == \u0026#39;GET\u0026#39;: # 如果请求方法是GET，表示请求的是登录页面 # 渲染并返回登录页面的HTML return flask.render_template(\u0026#39;./static/templates/login.html\u0026#39;) ​\t3.处理首页及推荐商品相关\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import flask from flask import Blueprint import db # 创建一个Blueprint实例，用于处理首页及推荐商品相关的路由 page_front = Blueprint(\u0026#39;page_front\u0026#39;, __name__) # 定义根路径(\u0026#39;/\u0026#39;)路由，处理首页请求 @page_front.route(\u0026#39;/\u0026#39;) def root(): \u0026#34;\u0026#34;\u0026#34; 首页 :return: 返回首页HTML模板 \u0026#34;\u0026#34;\u0026#34; # 渲染并返回首页的HTML模板 return flask.render_template(\u0026#39;./static/templates/index.html\u0026#39;) # 定义/recommend路由，处理推荐商品请求 @page_front.route(\u0026#39;/recommend\u0026#39;) def recommend(): \u0026#34;\u0026#34;\u0026#34; 获取最多30个商品，并将其打包成JSON格式返回 :return: 返回包含商品信息的JSON对象 \u0026#34;\u0026#34;\u0026#34; # 从数据库中获取最多30个商品的信息 goods_info = db.get_some_goods(30) # 将商品信息打包成JSON格式并返回 return flask.jsonify(goods_info) ​\t4.处理商品上传和更新相关的路由\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 import flask from flask import Blueprint import db import datetime # 创建一个Blueprint实例，用于处理商品上传和更新相关的路由 page_upload = Blueprint(\u0026#39;page_upload\u0026#39;, __name__) # 定义/upload_\u0026lt;op\u0026gt;路由，处理上传商品的请求 @page_upload.route(\u0026#39;/upload_\u0026lt;op\u0026gt;\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def upload(op): \u0026#34;\u0026#34;\u0026#34; 上传商品页面 :param op: 操作类型，\u0026#39;new\u0026#39;表示新增商品，\u0026#39;update\u0026#39;表示更新已有商品 :return: null \u0026#34;\u0026#34;\u0026#34; # 当请求方法为GET时，返回上传页面 if flask.request.method == \u0026#39;GET\u0026#39;: if op == \u0026#39;new\u0026#39;: # 如果是新增商品，返回空的上传页面 return flask.render_template(\u0026#39;./static/templates/upload.html\u0026#39;, origin=None) else: # 如果是更新商品，获取商品信息并返回编辑页面 gid = op.split(\u0026#39;_\u0026#39;) goods, cmt = db.get_item_info(int(gid[1])) # 获取商品信息 return flask.render_template(\u0026#39;./static/templates/upload.html\u0026#39;, origin=goods) # 当请求方法为POST时，处理表单提交的数据 if flask.request.method == \u0026#39;POST\u0026#39;: # 获取表单中的商品信息 name = flask.request.form.get(\u0026#39;name\u0026#39;) # 商品名称 price = flask.request.form.get(\u0026#39;price\u0026#39;) # 商品价格 des = flask.request.form.get(\u0026#39;des\u0026#39;) # 商品描述 uploader = flask.request.form.get(\u0026#39;uploader\u0026#39;) # 上传者 # 处理新增商品的逻辑 if op == \u0026#39;new\u0026#39;: # 获取上传的商品图片文件 f_img = flask.request.files.get(\u0026#39;img\u0026#39;) f_img_name = f_img.filename # 获取当前时间戳，作为文件保存名称的一部分 t = datetime.datetime.now().strftime(\u0026#39;%Y-%m-%d-%H-%M-%S\u0026#39;) full_path = \u0026#39;static/img/\u0026#39; + t + \u0026#39;-\u0026#39; + f_img_name # 保存路径 print(name, price, des, f_img_name) try: # 保存图片文件 f_img.save(full_path) # 将商品信息插入数据库 db.insert_goods(name, price, des, \u0026#39;../\u0026#39; + full_path, uploader, flask.request.form.get(\u0026#39;gid\u0026#39;)) except Exception as e: print(e) return \u0026#39;Error: fail to save file.\u0026#39; # 如果文件保存失败，返回错误信息 finally: return flask.redirect(\u0026#39;/\u0026#39;) # 成功后跳转到首页 # 处理更新商品的逻辑 if op == \u0026#39;update\u0026#39;: # 获取上传的商品图片文件 f_img = flask.request.files.get(\u0026#39;img\u0026#39;) f_img_name = f_img.filename # 如果上传了新图片 if f_img_name != \u0026#39;\u0026#39;: t = datetime.datetime.now().strftime(\u0026#39;%Y-%m-%d-%H-%M-%S\u0026#39;) full_path = \u0026#39;static/img/\u0026#39; + t + \u0026#39;-\u0026#39; + f_img_name print(\u0026#39;[\u0026#39;+f_img_name+\u0026#39;]\u0026#39;, type(f_img_name)) try: # 保存图片文件 f_img.save(full_path) # 更新商品信息 db.insert_goods(name, price, des, \u0026#39;../\u0026#39; + full_path, uploader, flask.request.form.get(\u0026#39;gid\u0026#39;)) except Exception as e: print(e) return \u0026#39;Error: fail to save file.\u0026#39; # 如果文件保存失败，返回错误信息 finally: return flask.redirect(\u0026#39;/\u0026#39;) # 成功后跳转到首页 else: # 如果没有上传新图片，仅更新其他信息 db.insert_goods(name, price, des, \u0026#39;\u0026#39;, uploader, flask.request.form.get(\u0026#39;gid\u0026#39;)) # 如果操作不符合预期，返回404 return \u0026#39;404 Not Found.\u0026#39; ​\t5.处理用户注册相关的路由\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import flask from flask import Blueprint import db # 创建一个Blueprint实例，用于处理用户注册相关的路由 page_register = Blueprint(\u0026#39;page_register\u0026#39;, __name__) # 定义/register路由，处理用户注册请求 @page_register.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): \u0026#34;\u0026#34;\u0026#34; 注册页面 :return: 当请求方法为GET时，返回HTML注册页面 当请求方法为POST时，将新用户的信息插入数据库 \u0026#34;\u0026#34;\u0026#34; # 当请求方法为GET时，返回注册页面 if flask.request.method == \u0026#39;GET\u0026#39;: return flask.render_template(\u0026#39;./static/templates/register.html\u0026#39;) # 当请求方法为POST时，处理表单提交的数据 if flask.request.method == \u0026#39;POST\u0026#39;: # 获取表单中的用户信息 name = flask.request.form.get(\u0026#39;name\u0026#39;) # 用户名 psw = flask.request.form.get(\u0026#39;psw\u0026#39;) # 密码 cps = flask.request.form.get(\u0026#39;cps\u0026#39;) # 确认密码 tel = flask.request.form.get(\u0026#39;tel\u0026#39;) # 电话号码 sid = flask.request.form.get(\u0026#39;sid\u0026#39;) # 学号 vx = flask.request.form.get(\u0026#39;vx\u0026#39;) # 微信号 qq = flask.request.form.get(\u0026#39;qq\u0026#39;) # QQ号 email = flask.request.form.get(\u0026#39;email\u0026#39;) # 邮箱 # 调用数据库函数插入新用户信息 r = db.insert_user(name=name, psw=psw, cps=cps, tel=tel, sid=sid, vx=vx, qq=qq, email=email) # 返回数据库插入结果 return r ​\t6.处理与用户信息相关的路由\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 import flask from flask import Blueprint import db # 创建一个Blueprint实例，用于处理与用户信息相关的路由 page_myinfo = Blueprint(\u0026#39;page_myinfo\u0026#39;, __name__) # 定义/myinfo路由，显示当前用户信息 @page_myinfo.route(\u0026#39;/myinfo\u0026#39;) def myInfo(): \u0026#34;\u0026#34;\u0026#34; 显示和编辑当前用户的信息 :return: null \u0026#34;\u0026#34;\u0026#34; # 获取当前登录用户的userid（从cookies中获取） cur_user = flask.request.cookies.get(\u0026#39;userid\u0026#39;) # 如果用户未登录，重定向到登录页面 if cur_user is None: return flask.redirect(\u0026#39;/login\u0026#39;) # 获取当前用户的详细信息，包括上传的商品、交易记录和收藏的商品 info, up, deals, fav = db.get_user_info(userid=cur_user) # 渲染myinfo.html页面，传递用户信息 return flask.render_template(\u0026#39;./static/templates/myinfo.html\u0026#39;, info=info, up=up, deals=deals, fav=fav) # 定义/user_\u0026lt;uid\u0026gt;路由，显示指定用户的信息 @page_myinfo.route(\u0026#39;/user_\u0026lt;uid\u0026gt;\u0026#39;) def user_info(uid): # 获取指定用户的详细信息 info, up, deals, fav = db.get_user_info(userid=uid) # 渲染userinfo.html页面，传递用户信息 return flask.render_template(\u0026#39;./static/templates/userinfo.html\u0026#39;, info=info, up=up) # 定义/modify_deal路由，处理修改交易状态的请求 @page_myinfo.route(\u0026#39;/modify_deal\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def modify_deal(): \u0026#34;\u0026#34;\u0026#34; 修改交易，能够更改交易状态或删除交易 :return: null \u0026#34;\u0026#34;\u0026#34; # 获取请求的表单数据 req = flask.request.form # 调用db.modify_deal()函数，根据表单数据修改交易 db.modify_deal(req[\u0026#39;gid\u0026#39;], req[\u0026#39;buyer\u0026#39;], req[\u0026#39;seller\u0026#39;], req[\u0026#39;do\u0026#39;], req[\u0026#39;text\u0026#39;]) # 返回操作成功的消息 return \u0026#39;good\u0026#39; # 定义/remove_goods路由，处理删除商品的请求 @page_myinfo.route(\u0026#39;/remove_goods\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def rm_goods(): # 从表单中获取商品ID，并调用db.remove_goods()函数删除商品 return db.remove_goods(flask.request.form.get(\u0026#39;gid\u0026#39;)) # 定义/remove_favorites路由，处理删除收藏商品的请求 @page_myinfo.route(\u0026#39;/remove_favorites\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def rm_favorites(): # 获取表单数据（用户ID和商品ID） info = flask.request.form # 调用db.remove_favorites()函数删除指定用户的收藏商品 return db.remove_favorites(info[\u0026#39;uid\u0026#39;], info[\u0026#39;gid\u0026#39;]) # 定义/modify_info路由，处理修改用户信息的请求 @page_myinfo.route(\u0026#39;/modify_info\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def modify_info(): # 获取表单中提交的用户新信息 new_info = flask.request.form # 调用db.modify_info()函数修改用户信息 rt = db.modify_info(new_info) # 返回修改操作的结果 return rt 7.处理与商品信息和用户交互相关的路由\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 import flask from flask import Blueprint import db # 创建一个Blueprint实例，用于处理与商品信息和用户交互相关的路由 page_briefing = Blueprint(\u0026#39;page_briefing\u0026#39;, __name__) # 定义/item_\u0026lt;gid\u0026gt;路由，展示商品的详细信息 @page_briefing.route(\u0026#39;/item_\u0026lt;gid\u0026gt;\u0026#39;) def itemInfo(gid): \u0026#34;\u0026#34;\u0026#34; 显示商品详细信息并支持更新 :param gid: 商品ID :return: null \u0026#34;\u0026#34;\u0026#34; # 从数据库获取商品信息和评论 info, comment = db.get_item_info(int(gid)) # 获取当前登录用户的ID（通过cookies获取） user_id = flask.request.cookies.get(\u0026#39;userid\u0026#39;) if user_id is not None: # 如果用户已登录，获取用户基本信息、上传商品、交易记录和收藏商品等 basic, up, deals, fav = db.get_user_info(userid=user_id) aut = basic[\u0026#39;aut\u0026#39;] # 用户权限 name = basic[\u0026#39;name\u0026#39;] # 用户名 else: aut = None name = None # 渲染商品详细信息页面，并传递商品信息、评论、用户权限和用户名等数据 return flask.render_template(\u0026#39;static/templates/briefing.html\u0026#39;, info=info, comment=comment, aut=aut, name=name) # 定义/buy路由，处理购买操作 @page_briefing.route(\u0026#39;/buy\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def buy(): \u0026#34;\u0026#34;\u0026#34; 处理购买操作，接收POST请求 :return: 操作状态 \u0026#34;\u0026#34;\u0026#34; # 获取表单数据 deal = flask.request.form # 调用数据库操作函数记录交易 db.new_deal(deal[\u0026#39;buyer_id\u0026#39;], deal[\u0026#39;seller_id\u0026#39;], deal[\u0026#39;gid\u0026#39;]) return \u0026#39;good\u0026#39; # 定义/add_comment路由，处理添加评论操作 @page_briefing.route(\u0026#39;/add_comment\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_comment(): \u0026#34;\u0026#34;\u0026#34; 向数据库添加评论，POST请求应该包含所有必要的信息 :return: 确认消息 \u0026#39;good\u0026#39; \u0026#34;\u0026#34;\u0026#34; # 获取表单数据 gid = flask.request.form.get(\u0026#39;gid\u0026#39;) time = flask.request.form.get(\u0026#39;time\u0026#39;) commenter = flask.request.form.get(\u0026#39;commenter\u0026#39;) text = flask.request.form.get(\u0026#39;text\u0026#39;) reply_to = flask.request.form.get(\u0026#39;replyTo\u0026#39;) # 调用数据库操作函数插入评论 db.insert_comment(gid, time, commenter, text, reply_to) return \u0026#39;good\u0026#39; # 定义/like路由，处理商品添加到用户收藏的操作 @page_briefing.route(\u0026#39;/like\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def like(): \u0026#34;\u0026#34;\u0026#34; 将商品添加到用户收藏夹 :return: 操作状态 \u0026#34;\u0026#34;\u0026#34; # 获取表单数据 info = flask.request.form # 调用数据库操作函数将商品添加到收藏 rt = db.insert_favorites(info[\u0026#39;uid\u0026#39;], info[\u0026#39;gid\u0026#39;]) return rt # 定义/remove_cmt路由，处理删除评论操作 @page_briefing.route(\u0026#39;/remove_cmt\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def rm_comment(): \u0026#34;\u0026#34;\u0026#34; 删除评论，级别为3和2的用户有权限删除任何评论， 级别1的用户只能删除自己发布的评论 :return: 操作状态 \u0026#34;\u0026#34;\u0026#34; # 获取表单数据 info = flask.request.form # 获取当前登录用户的ID（通过cookies获取） cur_user = flask.request.cookies.get(\u0026#39;userid\u0026#39;) # 获取当前用户的基本信息、上传商品、交易记录和收藏商品等 basic, up, deals, fav = db.get_user_info(userid=cur_user) # 如果当前用户是评论的发布者，允许删除评论 if info[\u0026#39;commenter\u0026#39;] == basic[\u0026#39;name\u0026#39;]: # 删除自己的评论 db.remove_comment(info.get(\u0026#39;cid\u0026#39;)) return \u0026#39;您发布的评论已删除\u0026#39; # 如果当前用户有删除评论的权限，允许删除其他用户的评论 if basic[\u0026#39;aut\u0026#39;] == 3 or basic[\u0026#39;aut\u0026#39;] == 2: # 用户权限为3或2，有删除权限 db.remove_comment(info.get(\u0026#39;cid\u0026#39;)) return \u0026#39;您已删除其他用户的评论，请不要做权限狗\u0026#39; # 如果用户权限不足，无法删除评论 return \u0026#39;您无权删除别人的评论\u0026#39; ​\t8.main\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import flask from flask import Flask from datetime import timedelta import configparser import os # 导入各个蓝图模块 from page_front import page_front from page_upload import page_upload from page_login import page_login from page_briefing import page_briefing from page_register import page_register from page_myinfo import page_myinfo from page_history import page_history # 创建配置解析器对象 config = configparser.ConfigParser() # 程序入口 if __name__ == \u0026#39;__main__\u0026#39;: # 创建Flask应用对象 app = Flask(__name__, template_folder=\u0026#39;./\u0026#39;) # 设置模板文件的根目录为当前目录 # 注册各个蓝图（模块化的路由和视图） app.register_blueprint(page_front) # 前端页面蓝图 app.register_blueprint(page_upload) # 上传商品蓝图 app.register_blueprint(page_login) # 登录页面蓝图 app.register_blueprint(page_briefing) # 商品详情页面蓝图 app.register_blueprint(page_register) # 注册页面蓝图 app.register_blueprint(page_myinfo) # 用户个人信息页面蓝图 app.register_blueprint(page_history) # 历史记录页面蓝图 # 读取配置文件（config.cfg） config.read(\u0026#39;config.cfg\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) # 使用配置文件中的项目目录，切换到该目录 os.system(\u0026#39;cd \u0026#39; + config.get(\u0026#39;App\u0026#39;, \u0026#39;proj_dir\u0026#39;)) # 设置缓存时间为1秒 app.config[\u0026#39;SEND_FILE_MAX_AGE_DEFAULT\u0026#39;] = timedelta(seconds=1) # 设置Flask应用的secret_key，用于会话管理和签名 app.secret_key = config.get(\u0026#39;App\u0026#39;, \u0026#39;key\u0026#39;) # 启动Flask应用 app.run(host=config.get(\u0026#39;App\u0026#39;, \u0026#39;host\u0026#39;), port=config.get(\u0026#39;App\u0026#39;, \u0026#39;port\u0026#39;)) ​\n​\n","date":"2024-11-11T23:44:00+08:00","permalink":"https://1878247293.github.io/p/%E4%BA%8C%E6%89%8B%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F-%E4%BA%8C/","title":"二手交易系统-（二）"},{"content":"一. 本次讲解\n​\tsql语句关于python的相关操作\n二. 代码讲解：\n​\t1. 配置文件读取与数据库连接\n1 2 3 4 5 6 7 # 导入 pymysql 库，用于连接 MySQL 数据库 import pymysql # 导入 configparser 模块，用于读取配置文件 import configparser # 读取数据库配置信息 config = configparser.ConfigParser() config.read(\u0026#39;config.cfg\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) 功能：读取config.cfg配置文件，以便从中获取数据库连接所需的参数，如主机、用户、密码等。\n作用：便于管理数据库连接参数的变化，将配置与代码分离，提升可维护性。\n​\t2.向商品表中插入一个新的商品。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def insert_goods(name, price, des, img, uploader, gid): \u0026#34;\u0026#34;\u0026#34; 向商品表中添加一个商品项 :param gid: 上传时传入原始商品ID，若不是上传则传入\u0026#39;-1\u0026#39; :param name: 商品名称，字符串类型 :param price: 商品价格，字符串类型，如 \u0026#39;10.50\u0026#39; :param des: 商品描述，字符串类型 :param img: 商品图片路径，必须存放在 ../static/img/ 目录下 :param uploader: 上传者的用户名，字符串类型 :return: 无返回值 \u0026#34;\u0026#34;\u0026#34; db = pymysql.connect(port=3340,host=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;host\u0026#39;), user=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;user\u0026#39;), password=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;password\u0026#39;), database=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;database\u0026#39;), charset=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;charset\u0026#39;)) cursor = db.cursor() # 获取上传者的用户ID cursor.execute(\u0026#39;select uID from user where uName=\u0026#34;%s\u0026#34;\u0026#39; % uploader) uID = str(cursor.fetchone()[0]) # 调用存储过程将商品信息插入数据库 cursor.execute(\u0026#39;call add_upload_goods(\u0026#34;%s\u0026#34;,\u0026#34;%s\u0026#34;,%s,\u0026#34;%s\u0026#34;,%s,%s)\u0026#39; % (name, des, price, img, uID, gid)) db.commit() cursor.close() db.close() 功能：向数据库中插入商品信息。通过用户名获取上传者的用户ID (uID)，并调用存储过程add_upload_goods来插入商品信息。\n注意事项：确保数据库中存在上传者的用户名，否则uID将导致错误。\n​\t3.随机获取指定数量的商品信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def get_some_goods(num): \u0026#34;\u0026#34;\u0026#34; 从商品表中随机选择若干个商品项 :param num: 选择的商品数量 :return: 返回一个字典列表，包含选中的商品信息 \u0026#34;\u0026#34;\u0026#34; db = pymysql.connect(port=3340,host=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;host\u0026#39;), user=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;user\u0026#39;), password=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;password\u0026#39;), database=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;database\u0026#39;), charset=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;charset\u0026#39;)) cursor = db.cursor() # 调用存储过程获取推荐的商品 cursor.execute(\u0026#39;call get_recommend(%d)\u0026#39; % num) result = cursor.fetchall() info = [] # 遍历结果，将每个商品的信息存入字典列表 for item in result: info.append({ \u0026#39;gid\u0026#39;: item[0], # 商品ID \u0026#39;name\u0026#39;: item[1], # 商品名称 \u0026#39;des\u0026#39;: item[2], # 商品描述 \u0026#39;price\u0026#39;: str(item[3]), # 商品价格，转换为字符串 \u0026#39;img\u0026#39;: item[4] # 商品图片路径 }) cursor.close() db.close() return info 功能：调用数据库中的存储过程get_recommend来随机获取指定数量的商品。\n返回值：字典列表，其中每个字典包含商品的基本信息。\n​\t4.验证用户ID和密码是否匹配\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def login_check(id, psw): \u0026#34;\u0026#34;\u0026#34; 查询数据库并检查用户名和密码是否匹配 :param id: 用户名（用户ID） :param psw: 密码 :return: 如果匹配返回0，否则返回1；同时返回用户ID和权限等级 \u0026#34;\u0026#34;\u0026#34; db = pymysql.connect(port=3340,host=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;host\u0026#39;), user=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;user\u0026#39;), password=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;password\u0026#39;), database=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;database\u0026#39;), charset=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;charset\u0026#39;)) cursor = db.cursor() # 执行SQL查询，查找与给定用户名匹配的用户 cursor.execute(\u0026#39;select * from user where uName=\u0026#34;%s\u0026#34;\u0026#39; % id) result = cursor.fetchone() print(result) uid = -1 authority = -1 if result is None: # 如果查询结果为空，说明用户名不存在，返回1 status = 1 elif result[2] == psw: # 如果密码匹配，返回0，并记录用户ID和权限 status = 0 uid = result[0] authority = result[9] else: # 如果密码不匹配，返回1 status = 1 cursor.close() db.close() return status, uid, authority 功能：验证用户名和密码是否正确，返回状态码和用户信息。\n注意事项：如果用户名不存在或密码不匹配，返回错误状态。\n​\t5.插入新用户信息，默认权限等级为最低\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def insert_user(name, psw, cps, sid, tel, vx, qq, email): \u0026#34;\u0026#34;\u0026#34; 向用户表中添加一个新用户，默认权限为1（最低权限） :param vx: 用户的微信号 :param qq: 用户的QQ号 :param email: 用户的电子邮件 :param name: 用户的姓名 :param psw: 用户的密码 :param cps: 用户所在的校区，长安校区或友谊校区 :param sid: 用户的学号 :param tel: 用户的电话号码 :return: 返回\u0026#39;good\u0026#39;表示成功，返回\u0026#39;fail\u0026#39;表示失败 \u0026#34;\u0026#34;\u0026#34; db = pymysql.connect(port=3340,host=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;host\u0026#39;), user=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;user\u0026#39;), password=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;password\u0026#39;), database=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;database\u0026#39;), charset=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;charset\u0026#39;)) cursor = db.cursor() result = \u0026#39;good\u0026#39; try: # 执行插入操作，将用户信息插入到数据库的user表中 cursor.execute(\u0026#39;insert into user(uName,uPsw,uCampus,schoolID,uTel,uVX,uQQ,uEmail) values(\u0026#34;%s\u0026#34;,\u0026#34;%s\u0026#34;,\u0026#34;%s\u0026#34;,\u0026#34;%s\u0026#34;,\u0026#39; \u0026#39;\u0026#34;%s\u0026#34;,\u0026#34;%s\u0026#34;,\u0026#34;%s\u0026#34;,\u0026#34;%s\u0026#34;)\u0026#39; % (name, psw, cps, sid, tel, vx, qq, email)) db.commit() except Exception as e: # 如果发生异常，输出错误信息，并标记为插入失败 print(e) print(\u0026#39;create user failed.\u0026#39;) result = \u0026#39;fail\u0026#39; finally: cursor.close() db.close() return result 功能：添加新用户信息到user表中，设置默认权限。\n注意事项：若用户名或其他约束条件冲突，会返回fail。\n​\t6.获取指定商品的详细信息和评论信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def get_item_info(gid): \u0026#34;\u0026#34;\u0026#34; 获取某个商品的详细信息，包括商品的基本信息和评论 :param gid: 商品的ID :return: 返回两个字典，一个是商品的基本信息，一个是商品的评论信息 \u0026#34;\u0026#34;\u0026#34; db = pymysql.connect(port=3340,host=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;host\u0026#39;), user=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;user\u0026#39;), password=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;password\u0026#39;), database=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;database\u0026#39;), charset=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;charset\u0026#39;)) cursor = db.cursor() # 查询商品的详细信息，包括商品的基本信息和发布者的用户名 cursor.execute(\u0026#39;select goods.*,user.uName from goods,user where gID=%d and goods.uploader=user.uID\u0026#39; % gid) result_info = cursor.fetchone() # 构建商品的基本信息字典 goods_info = { \u0026#39;gid\u0026#39;: str(gid), # 商品ID \u0026#39;name\u0026#39;: result_info[1], # 商品名称 \u0026#39;des\u0026#39;: result_info[2], # 商品描述 \u0026#39;price\u0026#39;: str(result_info[3]), # 商品价格 \u0026#39;img_src\u0026#39;: result_info[4][3:], # 商品图片路径，去除前缀的\u0026#39;../\u0026#39; \u0026#39;seller_id\u0026#39;: result_info[5], # 卖家ID \u0026#39;seller_name\u0026#39;: result_info[8], # 卖家姓名 \u0026#39;time\u0026#39;: result_info[6].strftime(\u0026#39;%Y-%m-%d\u0026#39;) # 商品发布时间 } # 查询商品的评论信息 cursor.execute(\u0026#39;call get_goods_comment(%d)\u0026#39; % gid) result_comment = cursor.fetchall() comment_info = [] for c in result_comment: comment_info.append({ \u0026#39;rid\u0026#39;: None, # 评论的回复ID，暂时没有处理 \u0026#39;cid\u0026#39;: c[0], # 评论ID \u0026#39;commenter\u0026#39;: c[1], # 评论者用户名 \u0026#39;replyto\u0026#39;: c[2], # 被回复的评论者 \u0026#39;time\u0026#39;: str(c[3]), # 评论时间 \u0026#39;text\u0026#39;: c[4] # 评论内容 }) # 以下为注释掉的部分，如果需要获取评论的回复信息，可以取消注释 # cursor.execute(\u0026#39;call get_goods_reply(%d)\u0026#39; % gid) # result_reply = cursor.fetchall() # for r in result_reply: # comment_info.append({ # \u0026#39;rid\u0026#39;: r[0], # \u0026#39;cid\u0026#39;: None, # \u0026#39;commenter\u0026#39;: r[1], # \u0026#39;replyto\u0026#39;: r[2], # \u0026#39;time\u0026#39;: str(r[3]), # \u0026#39;text\u0026#39;: r[4] # }) cursor.close() db.close() return goods_info, comment_info 功能：获取商品详情信息，包括评论信息。调用get_goods_comment存储过程以获取评论。\n注意事项：返回结构包含商品的详细信息和评论内容。\n​\t7.插入商品的评论信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def insert_comment(gid, time, commenter, text, reply_to): \u0026#34;\u0026#34;\u0026#34; 向评论表中添加一条新评论 :param gid: 评论所属商品的ID，必须传入商品的gID :param time: 评论时间，格式为 \u0026#39;YYYY-MM-DD HH:MM:SS\u0026#39; :param commenter: 评论者的用户名，必须传入uName :param text: 评论内容 :param reply_to: 评论回复对象的用户ID，若不回复任何人，则传入空字符串 :return: 无返回值 \u0026#34;\u0026#34;\u0026#34; db = pymysql.connect(port=3340,host=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;host\u0026#39;), user=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;user\u0026#39;), password=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;password\u0026#39;), database=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;database\u0026#39;), charset=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;charset\u0026#39;)) cursor = db.cursor() # 查询评论者的用户ID cursor.execute(\u0026#39;select uID from user where uName=\u0026#34;%s\u0026#34;\u0026#39; % commenter) uID = str(cursor.fetchone()[0]) # 如果没有回复对象，设置为null if reply_to == \u0026#39;\u0026#39;: reply_to = \u0026#39;null\u0026#39; # 调用存储过程添加评论 cursor.execute(\u0026#39;call add_comment(%s,%s,\u0026#34;%s\u0026#34;,\u0026#34;%s\u0026#34;)\u0026#39; % (uID, gid, reply_to, text)) db.commit() cursor.close() db.close() 功能描述：insert_comment 用于在平台上插入商品的评论信息，将用户对商品的评论记录到数据库中。\n作用：通过存储过程 add_comment 将用户的评论内容和关联商品、用户信息存入数据库，用于显示在商品的评论区域。\n​\t8.删除指定 ID 的评论信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def remove_comment(cid): \u0026#34;\u0026#34;\u0026#34; 删除一条评论 :param cid: 评论的ID :return: 无返回值 \u0026#34;\u0026#34;\u0026#34; db = pymysql.connect(port=3340,host=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;host\u0026#39;), user=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;user\u0026#39;), password=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;password\u0026#39;), database=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;database\u0026#39;), charset=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;charset\u0026#39;)) cursor = db.cursor() # 执行删除操作，删除指定cid的评论 cursor.execute(\u0026#39;delete from comments where cid=%s\u0026#39; % cid) db.commit() cursor.close() db.close() 功能描述：remove_comment 函数通过 comment_id 从数据库中删除一条评论。\n作用：在二手平台上提供删除评论的功能，供用户或管理员清理不当或过时的评论内容。\n​\t9.创建新的交易记录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def new_deal(buyer_id, seller_id, gid): \u0026#34;\u0026#34;\u0026#34; 创建一笔新的交易，价格将设置为商品上传时的价格 :param buyer_id: 买家的用户ID :param seller_id: 卖家的用户ID :param gid: 商品的ID :return: 返回交易是否成功的状态码，0表示成功，其他表示失败 \u0026#34;\u0026#34;\u0026#34; db = pymysql.connect(port=3340, host=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;host\u0026#39;), user=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;user\u0026#39;), password=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;password\u0026#39;), database=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;database\u0026#39;), charset=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;charset\u0026#39;)) cursor = db.cursor() # 调用存储过程创建交易，传入买家、卖家和商品ID cursor.execute(\u0026#39;call create_deal(%s, %s, %s, @suc)\u0026#39; % (buyer_id, seller_id, gid)) db.commit() # 提交事务 # 获取存储过程的返回值，判断交易是否成功 cursor.execute(\u0026#39;select @suc\u0026#39;) ret = cursor.fetchone() cursor.close() # 关闭游标 db.close() # 关闭数据库连接 return int(ret[0]) # 返回交易结果，0表示成功 功能描述：new_deal 用于在商品被购买时创建交易记录。\n作用：在平台上保存商品交易信息，为后续的订单管理、交易记录查询提供数据支持。\n​\t10.获取用户的个人信息、交易信息、收藏和上传的商品\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def get_user_info(userid): \u0026#34;\u0026#34;\u0026#34; 根据当前用户ID，返回与用户相关的所有交易和信息 TODO: 添加用户的收藏功能 :param userid: 用户的ID :return: 返回4个字典，分别是用户信息、用户上传商品、用户交易记录、用户收藏 \u0026#34;\u0026#34;\u0026#34; db = pymysql.connect(port=3340, host=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;host\u0026#39;), user=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;user\u0026#39;), password=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;password\u0026#39;), database=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;database\u0026#39;), charset=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;charset\u0026#39;)) cursor = db.cursor() # 获取用户基本信息并封装成字典 cursor.execute(\u0026#39;select * from user where uID=\u0026#34;%s\u0026#34;\u0026#39; % userid) res_info = cursor.fetchone() info = { \u0026#39;uid\u0026#39;: res_info[0], # 用户ID \u0026#39;name\u0026#39;: res_info[1], # 用户姓名 \u0026#39;sid\u0026#39;: res_info[3], # 学号 \u0026#39;campus\u0026#39;: res_info[4], # 所在校园 \u0026#39;tel\u0026#39;: res_info[5], # 电话号码 \u0026#39;vx\u0026#39;: res_info[6], # 微信号 \u0026#39;qq\u0026#39;: res_info[7], # QQ号 \u0026#39;email\u0026#39;: res_info[8], # 邮箱 \u0026#39;aut\u0026#39;: res_info[9] # 用户权限 } # 获取用户的交易记录并封装成字典数组 cursor.execute(\u0026#39;call get_user_deal(%s)\u0026#39; % userid) res_deal = cursor.fetchall() deals = [] for d in res_deal: deal_item = { \u0026#39;gid\u0026#39;: d[0], # 商品ID \u0026#39;seller_id\u0026#39;: d[1], # 卖家ID \u0026#39;buyer_id\u0026#39;: d[2], # 买家ID \u0026#39;time\u0026#39;: d[3], # 交易时间 \u0026#39;price\u0026#39;: d[4], # 交易价格 \u0026#39;status\u0026#39;: d[5], # 交易状态 \u0026#39;goods_name\u0026#39;: d[6], # 商品名称 \u0026#39;seller_name\u0026#39;: d[7], # 卖家姓名 \u0026#39;buyer_name\u0026#39;: d[8] # 买家姓名 } deals.append(deal_item) # 获取用户的收藏信息 cursor.execute(\u0026#39;call get_user_fav(%s)\u0026#39; % userid) res_fav = cursor.fetchall() fav = [] for f in res_fav: fav.append({ \u0026#39;gid\u0026#39;: f[0], # 商品ID \u0026#39;gName\u0026#39;: f[1], # 商品名称 \u0026#39;fTime\u0026#39;: f[2], # 收藏时间 \u0026#39;seller\u0026#39;: f[3] # 卖家ID }) # 获取用户上传的商品 cursor.execute(\u0026#39;call get_user_upload(%s)\u0026#39; % userid) res_up = cursor.fetchall() up = [] for u in res_up: up.append({ \u0026#39;gid\u0026#39;: u[0], # 商品ID \u0026#39;gName\u0026#39;: u[1], # 商品名称 \u0026#39;gPrice\u0026#39;: u[2], # 商品价格 \u0026#39;time\u0026#39;: u[3] # 上传时间 }) cursor.close() # 关闭游标 db.close() # 关闭数据库连接 return info, up, deals, fav # 返回用户信息、上传商品、交易记录和收藏信息 功能描述：get_user_info 函数获取指定用户的所有信息。\n作用：该函数用于显示用户主页，包括用户信息、交易记录、收藏列表和已上传商品等内容。\n​\t11.修改交易记录的状态或价格\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def modify_deal(gid, buyer, seller, op, text): \u0026#34;\u0026#34;\u0026#34; 修改一笔交易，按给定的gid、买家ID和卖家ID进行索引 合法的操作（op）值有：remove（删除交易）、status（修改状态）、price（修改价格） :param gid: 商品ID :param buyer: 买家用户ID :param seller: 卖家用户ID :param op: 操作类型（remove, status, price） :param text: 设置操作的目标值（如状态、价格等） :return: 无返回值 \u0026#34;\u0026#34;\u0026#34; db = pymysql.connect(port=3340, host=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;host\u0026#39;), user=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;user\u0026#39;), password=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;password\u0026#39;), database=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;database\u0026#39;), charset=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;charset\u0026#39;)) cursor = db.cursor() # 构建存储过程的调用语句，执行修改交易的操作 q = \u0026#39;call modify_deal(%s,%s,%s,\u0026#34;%s\u0026#34;,\u0026#34;%s\u0026#34;)\u0026#39; % (seller, buyer, gid, op, text) print(q) # 打印SQL查询语句，供调试时使用 cursor.execute(q) # 执行修改交易的存储过程 db.commit() # 提交事务 cursor.close() # 关闭游标 db.close() # 关闭数据库连接 功能描述：modify_deal 用于更新交易记录的状态或价格。\n作用：支持管理员或卖家修改交易信息，如更新订单状态或重新定价。\n​\t12.添加用户收藏\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def insert_favorites(uid, gid): \u0026#34;\u0026#34;\u0026#34; 将商品添加到用户的收藏夹中 :param uid: 用户ID :param gid: 商品ID :return: 返回操作结果信息，成功时返回\u0026#34;收藏成功\u0026#34;，失败时返回\u0026#34;已在收藏夹中，不能重复收藏\u0026#34; \u0026#34;\u0026#34;\u0026#34; db = pymysql.connect(port=3340, host=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;host\u0026#39;), user=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;user\u0026#39;), password=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;password\u0026#39;), database=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;database\u0026#39;), charset=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;charset\u0026#39;)) cursor = db.cursor() rt = \u0026#39;收藏成功\u0026#39; # 默认返回成功消息 try: # 调用存储过程将商品添加到用户的收藏夹 cursor.execute(\u0026#39;call add_fav(\u0026#34;%s\u0026#34;,\u0026#34;%s\u0026#34;)\u0026#39; % (uid, gid)) db.commit() # 提交事务 except Exception as e: print(e) # 打印异常信息 rt = \u0026#39;已在收藏夹中，不能重复收藏\u0026#39; # 如果发生异常，说明商品已经在收藏夹中 finally: cursor.close() # 关闭游标 db.close() # 关闭数据库连接 return rt # 返回操作结果 ​\t13.从商品表中删除指定商品\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def remove_goods(gid): \u0026#34;\u0026#34;\u0026#34; 从商品表中删除指定商品 :param gid: 商品ID :return: 返回删除结果信息，成功时返回\u0026#34;删除成功\u0026#34;，失败时返回\u0026#34;删除失败，有相关交易\u0026#34; \u0026#34;\u0026#34;\u0026#34; db = pymysql.connect(port=3340, host=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;host\u0026#39;), user=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;user\u0026#39;), password=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;password\u0026#39;), database=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;database\u0026#39;), charset=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;charset\u0026#39;)) cursor = db.cursor() # 调用存储过程删除商品 cursor.execute(\u0026#39;call remove_goods(%s)\u0026#39; % gid) db.commit() # 提交事务 res = cursor.fetchone() # 获取存储过程的返回结果 print(res, res[0], type(res[0])) # 打印返回结果，供调试使用 # 根据存储过程返回的结果判断删除是否成功 if res[0] == 1: rt = \u0026#39;删除成功\u0026#39; else: rt = \u0026#39;删除失败，有相关交易\u0026#39; # 如果返回结果不为1，说明有相关交易，删除失败 cursor.close() # 关闭游标 db.close() # 关闭数据库连接 return rt # 返回操作结果 ​\t14.从用户的收藏夹中移除指定商品\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def remove_favorites(uid, gid): \u0026#34;\u0026#34;\u0026#34; 从用户的收藏夹中移除指定商品 :param uid: 用户ID :param gid: 商品ID :return: 返回删除结果信息，成功时返回\u0026#34;删除成功\u0026#34; \u0026#34;\u0026#34;\u0026#34; db = pymysql.connect(port=3340, host=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;host\u0026#39;), user=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;user\u0026#39;), password=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;password\u0026#39;), database=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;database\u0026#39;), charset=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;charset\u0026#39;)) cursor = db.cursor() # 从收藏表中删除指定用户和商品的记录 cursor.execute(\u0026#39;delete from favorites where uid=%s and gid=%s\u0026#39; % (uid, gid)) db.commit() # 提交事务 cursor.close() # 关闭游标 db.close() # 关闭数据库连接 return \u0026#39;删除成功\u0026#39; # 返回操作结果 ​\t15.修改用户信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def modify_info(info): \u0026#34;\u0026#34;\u0026#34; 修改用户信息 :param info: 包含用户信息的字典，包含uID（用户ID）和需要修改的其他字段 :return: 返回操作结果信息，成功时返回\u0026#34;修改成功\u0026#34;，失败时返回\u0026#34;用户名已存在\u0026#34; \u0026#34;\u0026#34;\u0026#34; db = pymysql.connect(port=3340, host=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;host\u0026#39;), user=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;user\u0026#39;), password=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;password\u0026#39;), database=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;database\u0026#39;), charset=config.get(\u0026#39;MySQL\u0026#39;, \u0026#39;charset\u0026#39;)) cursor = db.cursor() rt = \u0026#39;修改成功\u0026#39; # 默认返回成功消息 try: cursor.execute(\u0026#39;start transaction\u0026#39;) # 开始事务 # 更新用户名 cursor.execute(\u0026#39;update user set uName=\u0026#34;%s\u0026#34; where uID=%s\u0026#39; % (info[\u0026#39;uName\u0026#39;], info[\u0026#39;uID\u0026#39;])) # 遍历并更新其他字段（排除uID和uName） for item in info: if item != \u0026#39;uID\u0026#39; and item != \u0026#39;uName\u0026#39;: cursor.execute(\u0026#39;update user set %s=\u0026#34;%s\u0026#34; where uID=%s\u0026#39; % (item, info[item], info[\u0026#39;uID\u0026#39;])) db.commit() # 提交事务 except Exception as e: print(e) # 打印异常信息 db.rollback() # 如果发生异常，回滚事务 rt = \u0026#39;用户名已存在\u0026#39; # 如果发生异常，可能是用户名已存在 finally: cursor.close() # 关闭游标 db.close() # 关闭数据库连接 return rt # 返回操作结果 ​\n​\n","date":"2024-11-11T23:44:00+08:00","permalink":"https://1878247293.github.io/p/%E4%BA%8C%E6%89%8B%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F-%E4%B8%80/","title":"二手交易系统-（一）"},{"content":"一. 本次讲解\n​\t管理用户的订单评价、查看并管理待评价订单、处理用户对订单的评论操作\n二. 代码讲解：\n​\t1.管理用户的订单评价\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #管理用户的订单评价 @app.route(\u0026#39;/MyComments\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def MyCommentsPage(): msg = \u0026#34;\u0026#34; # 全局变量，记录未完成或未评价订单数量 global notFinishedNum # 处理 GET 请求，显示用户评论页面 if request.method == \u0026#39;GET\u0026#39;: msg = \u0026#34;\u0026#34; # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询已完成但未评价的订单数量 presql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text = \u0026#39;\u0026#39; \u0026#34; % username cursor.execute(presql) #将 cursor.execute(sql) 返回的所有结果行提取出来 res1 = cursor.fetchall() # 记录未评价订单数量 notFinishedNum = len(res1) # 查询已完成且已评价的订单信息 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; and isFinished = 1 and text \u0026lt;\u0026gt; \u0026#39;\u0026#39; \u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MyComments.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MyComments.html\u0026#39;, username=username, messages=msg) #按时间排序 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按时间排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 按时间排序已完成且已评价的订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text is not null Order BY transactiontime DESC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MyComments.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MyComments.html\u0026#39;, username=username, messages=msg) #按价格排序 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按价格排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询按价格升序排序的订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text is not null Order BY cost ASC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() # 渲染页面并传入结果 if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MyComments.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MyComments.html\u0026#39;, username=username, messages=msg, notFinishedNum=notFinishedNum) #待评价订单 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;待评价订单\u0026#34;: # 查看未评价的订单并跳转到写评论页面 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询所有已完成但未评价的订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text = \u0026#39;\u0026#39; \u0026#34; % username cursor.execute(sql) res = cursor.fetchall() # 渲染写评论页面并传入结果 if len(res): msg = \u0026#34;done\u0026#34; print(msg) return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=len(res)) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, messages=msg, notFinishedNum=len(res)) # 返回到该界面 else: return render_template(\u0026#39;MyComments.html\u0026#39;, username=username, messages=msg) 此代码实现了一个 /MyComments 路由，用于管理用户的订单评价。它提供了多种排序和筛选功能，帮助用户查看并管理其已完成和已评价的订单。\n作用 显示用户的已评价订单：查询已完成且已评价的订单，并在页面中显示。 按时间或价格排序：用户可以选择按时间或价格对已评价的订单进行排序。 查看待评价订单：筛选出用户已完成但未评价的订单，并跳转到“写评论”页面，方便用户进行评价。 ​\t2.查看并管理待评价订单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #查看并管理待评价订单 @app.route(\u0026#39;/WriteComments\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def WriteCommentsPage(): msg=\u0026#34;\u0026#34; # GET 请求：显示待评价订单 if request.method == \u0026#39;GET\u0026#39;: # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询用户已完成但未评价的订单信息 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text = \u0026#39;\u0026#39; \u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; print(msg) return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, result=res, messages=msg) else: print(\u0026#34;WriteCommentsPage - GET - NULL\u0026#34;) msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, messages=msg) # 按交易时间排序 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按交易时间排序\u0026#34;: # TODO: 排序之后显示的是空的，不显示的问题没有解决 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询用户未评价订单按交易时间降序排列 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text = \u0026#39;\u0026#39; Order BY transactiontime DESC\u0026#34; % username cursor.execute(sql) # 获取查询结果 res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, result=res, messages=msg) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, messages=msg) # 按价格排序 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按价格排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询用户未评价订单按价格升序排列 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text = \u0026#39;\u0026#39; Order BY cost ASC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, messages=msg, notFinishedNum=notFinishedNum) # 未完成订单 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;未完成订单\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询用户未完成的订单信息 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 0 AND text = \u0026#39;\u0026#39; \u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; print(msg) return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, result=res, messages=msg, notFinishedNum=len(res)) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, messages=msg, notFinishedNum=notFinishedNum) # 默认情况，直接渲染评论页面 else: return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, messages=msg) 该代码定义了一个 Flask 路由 /WriteComments，用于用户查看并管理待评价订单。主要功能是根据用户请求展示待评价的订单列表，包括支持按交易时间或价格排序，并允许用户查看未完成订单。查询的结果会渲染到 WriteComments.html 模板。\n逻辑总结 GET 请求：从数据库中查询用户已完成但未评价的订单，并显示在页面上。 按交易时间排序：查询已完成、待评价的订单，按交易时间降序显示。 按价格排序：查询已完成、待评价的订单，按价格升序显示。 未完成订单：查询用户的未完成订单并显示在页面上。 页面展示：根据查询结果，渲染页面 WriteComments.html 并传递相关数据给前端。 ​\t3.处理用户对订单的评论操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #处理用户对订单的评论操作 @app.route(\u0026#39;/CommentForm\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def CommentFormPage(): msg = \u0026#34;\u0026#34; # 判断用户请求的操作类型 if request.form[\u0026#34;action\u0026#34;] == \u0026#34;写评论\u0026#34;: orderID = request.form[\u0026#39;orderID\u0026#39;] msg = \u0026#34;WriteRequest\u0026#34; return render_template(\u0026#39;CommentForm.html\u0026#39;, username=username, orderID=orderID, messages=msg) # 提交评论操作 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;提交评论\u0026#34;: # 获取表单数据：订单ID、评分、评论文本 orderID = request.form.get(\u0026#39;orderID\u0026#39;) c_rank = request.form.get(\u0026#39;rank\u0026#39;) text = request.form.get(\u0026#39;text\u0026#39;) # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 更新评论内容和评分 sql = \u0026#34;Update ORDER_COMMENT SET text = \u0026#39;{}\u0026#39;, c_rank = {} where orderID = \u0026#39;{}\u0026#39;\u0026#34;.format(text, c_rank, orderID) try: cursor.execute(sql) db.commit() msg = \u0026#34;done\u0026#34; except ValueError as e: msg = \u0026#34;fail\u0026#34; # 渲染评论页面并显示提交结果 return render_template(\u0026#39;CommentForm.html\u0026#39;, messages = msg, username=username) ​\t该代码定义了一个 Flask 路由 /CommentForm，用于处理用户对订单的评论操作，包括填写评论表单和提交评论内容。当用户点击“写评论”或“提交评论”按钮时，程序会相应地渲染评论页面或更新数据库中的评论数据。\n逻辑总结 写评论：当用户点击“写评论”按钮时，获取该订单的 orderID 并渲染 CommentForm.html 模板，以便用户在表单中填写评论内容。 提交评论：当用户提交评论时，将用户输入的评论文本和评分插入数据库的 ORDER_COMMENT 表中。若插入成功，显示“提交成功”消息；否则显示“提交失败”消息。 ​\n","date":"2024-11-11T23:44:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E4%BA%94/","title":"外卖订餐系统-（五）"},{"content":"一. 本次讲解\n​\t404跳转，购物车，个人中心页面，修改个人信息页面，修改密码页面，查看、管理和更新订单信息\n二. 代码讲解：\n​\t1.404跳转\n1 2 3 4 5 # 当发生 404 错误时调用此装饰的函数 @app.errorhandler(404) # 使用 render_template 渲染一个自定义的 404 页面 def page_not_found(error): return render_template(\u0026#34;404.html\u0026#34;), 404 ​\t2.购物车\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 @app.route(\u0026#39;/myOrder\u0026#39;,methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def shoppingCartPage(): # 当请求方法为 GET 时执行以下代码块 if request.method == \u0026#39;GET\u0026#39;: # 连接到 MySQL 数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 执行查询 SHOPPINGCART 表中所有记录的 SQL 语句 sql = \u0026#34;SELECT * FROM SHOPPINGCART\u0026#34; cursor.execute(sql) res = cursor.fetchall() # 如果查询结果不为空 if len(res) != 0: msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;myOrder.html\u0026#39;, username=username, result=res, messages=msg) else:# 如果查询结果为空 msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;myOrder.html\u0026#39;, username=username, messages=msg) # 当 POST 请求的表单字段 \u0026#34;action\u0026#34; 为 \u0026#34;加入购物车\u0026#34; 时 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;加入购物车\u0026#34;: # 获取表单字段的数据 restaurant = request.form[\u0026#39;restaurant\u0026#39;] dishname = request.form[\u0026#39;dishname\u0026#39;] price = (float)(request.form[\u0026#39;price\u0026#39;]) img_res = request.form[\u0026#39;img_res\u0026#39;] db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 插入新记录到 SHOPPINGCART 表 sql1 = \u0026#34;insert into SHOPPINGCART (username,restaurant,dishname,price,img_res) values (\u0026#39;{}\u0026#39;,\u0026#39;{}\u0026#39;,\u0026#39;{}\u0026#39;,{},\u0026#39;{}\u0026#39;) \u0026#34;.format(username,restaurant,dishname,price,img_res) cursor.execute(sql1) # 查询 SHOPPINGCART 表的所有记录 sql = \u0026#34;SELECT * FROM SHOPPINGCART\u0026#34; cursor.execute(sql) res = cursor.fetchall() # 检查查询结果 if len(res) != 0: msg = \u0026#34;done\u0026#34; print(msg) print(len(res)) return render_template(\u0026#39;myOrder.html\u0026#39;, username=username, result=res, messages=msg) else: print(\u0026#34;NULL\u0026#34;) msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;myOrder.html\u0026#39;, username=username, messages=msg) # 当 POST 请求的表单字段 \u0026#34;action\u0026#34; 为 \u0026#34;结算\u0026#34; 时 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;结算\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 从表单字段获取数据 restaurant = request.form[\u0026#39;restaurant\u0026#39;] dishname = request.form[\u0026#39;dishname\u0026#39;] price = request.form[\u0026#39;price\u0026#39;] img_res = request.form[\u0026#39;img_res\u0026#39;] mode = request.form[\u0026#39;mode\u0026#39;] # 获取结算模式（堂食或外送） return render_template(\u0026#39;index.html\u0026#39;) else: return render_template(\u0026#39;index.html\u0026#39;) 这个 Flask 路由处理了三种情况：\nGET 请求：查询购物车中的商品并渲染结果到 myOrder.html 页面。如果购物车为空，显示相关消息。 POST 请求 - 加入购物车：将用户选择的商品信息插入到 SHOPPINGCART 数据库表中，然后查询购物车中的商品并更新显示。 POST 请求 - 结算：获取商品信息和结算模式（堂食或外送），根据模式输出相应的日志，最终跳转到 index.html 页面。 ​\t3.个人中心页面\n1 2 3 4 # 定义路由 \u0026#39;/personal\u0026#39;，用于访问个人页面 @app.route(\u0026#39;/personal\u0026#39;) def personalPage(): return render_template(\u0026#39;personal.html\u0026#39;) ​\t该代码定义了一个用于访问个人页面的路由 /personal。当用户在浏览器中访问该路径时，Flask 会调用 personalPage 函数，该函数通过 render_template 函数渲染 personal.html 模板，并将该页面返回给用户的浏览器展示。\n​\t4.修改个人信息页面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @app.route(\u0026#39;/ModifyPersonalInfo\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def ModifyPersonalInfo(): msg = \u0026#34;\u0026#34; # 处理 GET 请求，显示修改个人信息的页面 if request.method == \u0026#39;GET\u0026#39;: # 渲染 ModifyPersonalInfo.html 模板，传入用户名 return render_template(\u0026#39;ModifyPersonalInfo.html\u0026#39;, username=username) # 处理 POST 请求，用于更新个人信息 if request.method == \u0026#39;POST\u0026#39;: # 从表单中获取用户输入的数据 address = request.form[\u0026#39;address\u0026#39;] phonenum = request.form[\u0026#39;phonenum\u0026#39;] # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 构建 SQL 更新语句，将 address 和 phone 字段更新为用户提供的值 sql = \u0026#34;Update {} SET address = \u0026#39;{}\u0026#39;, phone = \u0026#39;{}\u0026#39; where username = \u0026#39;{}\u0026#39;\u0026#34;.format(userRole, address, phonenum,username) # 执行更新操作 try: cursor.execute(sql) db.commit() msg = \u0026#34;done\u0026#34; except ValueError as e: msg = \u0026#34;fail\u0026#34; # 渲染 ModifyPersonalInfo.html 模板，传入操作结果消息和用户名 return render_template(\u0026#39;ModifyPersonalInfo.html\u0026#39;, messages=msg, username=username) 该代码定义了 /ModifyPersonalInfo 路由，用于显示和更新用户的个人信息页面，支持 GET 和 POST 两种请求：\nGET 请求：显示用户的修改个人信息页面 ModifyPersonalInfo.html，并传入用户名信息以便显示。 POST 请求：更新用户的地址和电话号码。在接收到用户输入后，将其写入数据库。如果操作成功，页面显示成功消息，否则显示失败消息。 ​\t5.修改密码页面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @app.route(\u0026#39;/ModifyPassword\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def ModifyPassword(): msg = \u0026#34;\u0026#34; # 处理 GET 请求，显示修改密码的页面 if request.method == \u0026#39;GET\u0026#39;: # 渲染 ModifyPassword.html 模板，并传入用户名 return render_template(\u0026#39;ModifyPassword.html\u0026#39;, username=username) # 处理 POST 请求，用于更新密码 if request.method == \u0026#39;POST\u0026#39;: psw1 = request.form[\u0026#39;psw1\u0026#39;] psw2 = request.form[\u0026#39;psw2\u0026#39;] # 两次输入密码是否相同 if psw1 == psw2: # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 构建 SQL 更新语句，将用户的密码更新为新值 sql = \u0026#34;Update {} SET password = \u0026#39;{}\u0026#39; where username = \u0026#39;{}\u0026#39;\u0026#34;.format(userRole, psw1, username) try: cursor.execute(sql) db.commit() msg = \u0026#34;done\u0026#34; except ValueError as e: msg = \u0026#34;fail\u0026#34; return render_template(\u0026#39;ModifyPassword.html\u0026#39;, messages=msg, username=username) # 如果两次输入的密码不一致 else: msg = \u0026#34;not equal\u0026#34; return render_template(\u0026#39;ModifyPassword.html\u0026#39;, messages=msg, username=username) 该代码定义了 /ModifyPassword 路由，用于显示和更新用户密码页面，支持 GET 和 POST 两种请求：\nGET 请求：显示 ModifyPassword.html 页面，让用户输入新密码。 POST 请求：处理修改密码操作。若用户两次输入的密码一致，则将新密码更新到数据库中，并显示成功消息；否则，提示密码不一致。 ​\t6.查看、管理和更新订单信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 @app.route(\u0026#39;/OrderPage\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def OrderPage(): msg = \u0026#34;\u0026#34; # 全局变量，用于存储未完成订单数量 global notFinishedNum # 处理 GET 请求，显示订单页面 if request.method == \u0026#39;GET\u0026#39;: msg = \u0026#34;\u0026#34; # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询未完成订单数量 presql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 0\u0026#34; % username cursor.execute(presql) res1 = cursor.fetchall() # 获取未完成订单数量 notFinishedNum = len(res1) # 查询用户的所有订单信息 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39;\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() # 如果有数据 if len(res): msg = \u0026#34;done\u0026#34; print(msg) return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: print(\u0026#34;NULL\u0026#34;) msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, messages=msg) # 按时间降序排序 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按时间排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询按时间降序排序的订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; Order BY transactiontime DESC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, messages=msg) # 按价格升序排序 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按价格排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询按价格升序排序的订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; Order BY cost ASC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, messages=msg, notFinishedNum=notFinishedNum) # 查询未完成订单 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;未完成订单\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询未完成订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 0 \u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=len(res)) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, messages=msg, notFinishedNum=notFinishedNum) #确认收货 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;确认收货\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) orderID = request.form[\u0026#39;orderID\u0026#39;] # 确认订单已完成 sql1 = \u0026#34;Update ORDER_COMMENT SET isFinished = 1, text = \u0026#39;\u0026#39; WHERE orderID = \u0026#39;%s\u0026#39; \u0026#34; % orderID cursor.execute(sql1) db.commit() # 获取订单信息，增加菜品销量 sql2 = \u0026#34;select * from ORDER_COMMENT WHERE orderID = \u0026#39;%s\u0026#39; \u0026#34; % orderID cursor.execute(sql2) res1 = cursor.fetchone() restaurant = res1[1] dishname = res1[2] sql = \u0026#34;Update DISHES SET sales = sales+1 WHERE dishname = \u0026#39;{}\u0026#39; AND restaurant = \u0026#39;{}\u0026#39;\u0026#34; .format(dishname, restaurant) cursor.execute(sql) res = cursor.fetchall() msg = \u0026#34;UpdateSucceed\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, messages=msg) else: return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, messages=msg) 该代码定义了一个 /OrderPage 路由，用户可以查看、管理和更新订单信息。根据请求的类型和内容，它执行以下几种操作：\nGET 请求：获取用户订单数据和未完成订单数量，并显示在页面上。 按时间排序：根据订单的交易时间降序排序并显示。 按价格排序：根据订单的价格升序排序并显示。 未完成订单：过滤并显示所有未完成的订单。 确认收货：用户确认收货后，将订单标记为完成，同时更新菜品销量。 ","date":"2024-11-11T22:27:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E5%9B%9B/","title":"外卖订餐系统-（四）"},{"content":"项目网址： 项目 #0 - C++ 入门 |CMU 15-445/645 ：： 数据库系统简介（2023 年秋季）\n在进行下列任务时可以先学习一些前置知识点： 【C++算法模板】字典树，超详细注释带例题讲解_c++字典树-CSDN博客\n[让内存无处可逃：智能指针C++11]_接口用智能指针-CSDN博客\n一.需要具备的基础知识：\n1.智能指针：\nshared_ptr.作用如同指针，但会记录有多少个shared_ptr共同指向一个对象。这便是所谓的引用计数（reference counting）。 一旦最后一个这样的指针被销毁，也就是一旦某个对象的引用计数变为0，这个对象会被自动删除。\n创建时利用make_shared\u0026lt;\u0026gt;.例如\nstd::shared_ptr val_p = std::make_shared(std::move(value)); 2.move()函数\n将对象的状态或所有权转换给另一对象，之后传入的对象就为空了，这样做只是转移，没有内存的搬迁或者内存拷贝，如果不加则需要先将传入对象拷贝一份为临时对象，然后给属性成员赋值，之后销毁临时对象。因此，通过std::move()，可以避免不必要的拷贝操作。这样的构造函数称为移动构造函数\n3.auto 函数() -\u0026gt; 类型{…} 作用是推导出函数的返回类型\nauto Trie::Put(std::string_view key, T value) const -\u0026gt; Trie { 如此，put()函数返回的就是Trie对象。\n4.类型转换\nstd::dynamic_cast\u0026lt;目标类型*\u0026gt;(被转换对象) std::dynamic_pointer_cast\u0026lt;目标类型\u0026gt;(被转换智能指针) dynamic_pointer_cast与dynamic_cast的区别 适用对象类型：dynamic_pointer_cast适用于智能指针类型，如std::shared_ptr和std::weak_ptr，用于进行智能指针的动态类型转换。而dynamic_cast适用于指针和引用类型，用于进行指针或引用类型的动态类型转换。\nconst auto *value_node = dynamic_cast\u0026lt;const TrieNodeWithValue *\u0026gt;(node.get()); 在Get()函数中用到了类型转换。\n任务 #1 - Copy-On-Write Trie 一.先说一下俩个问题：\n1.为啥Put的实现这么奇葩，要求返回一颗新树，不会很耗资源吗？ 显而易见Put是比较耗资源的，但是没有想象中的那么耗资源，因为Trie其实不负责具体资源的分配的，Trie代表的仅仅是一些索引而已，里面只存了一堆指针。 2.为啥Get的实现要求先dynamic_cast到const TrieNodeWithValue，不嫌麻烦吗？ 这其实是为了实现异类集合，想想就知道了。\n二.在 task1 中我们一共需要用到三个文件：\n/src/include/primer/trie.h\n/src/primer/trie.cpp\ntest/primer/trie_test.cpp\ntire.h:头文件，需要我们读懂，并且用到一些变量名 tire.cpp:在此文件里写代码 tire_test.cpp：给定好的测试文件，用来测试TASK 1是否通过\n在写代码之前一件很很很重要的事情：代码格式！！！\nGoogle C++ Style Guide\n真心建议大家好好学习一下，并在编写代码的时候耐心遵守，一方面是最后提交的时候会少很多麻烦。另一方面，优秀的代码风格跟我们的发型，衣服一样——很帅！\n三.任务实战：\n3.1 GET：\n关于GET部分，我们只需根据官方的注释要求正常做就行了。\n1 你应该遍历 trie 来查找对应于键的节点。如果节点不存在，返回 nullptr。在找到节点之后，你应该使用 `dynamic_cast` 将其转换为 `const TrieNodeWithValue\u0026lt;T\u0026gt; *`。如果 `dynamic_cast` 返回 `nullptr`，这意味着值的类型不匹配，你应该返回 nullptr。否则，返回该值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 如果key为空，则查找根节点 if (key.empty()) { const bustub::TrieNodeWithValue\u0026lt;T\u0026gt; *tnwv = dynamic_cast\u0026lt;const bustub::TrieNodeWithValue\u0026lt;T\u0026gt; *\u0026gt;(root_.get()); return tnwv == nullptr ? nullptr : tnwv-\u0026gt;value_.get(); } // 检查根节点是否为空，则返回当前的 Trie if (this-\u0026gt;root_ == nullptr) { return nullptr; } std::shared_ptr\u0026lt;const bustub::TrieNode\u0026gt; cur = this-\u0026gt;root_; for (size_t i = 0; i \u0026lt; key.length(); i++) { auto it = cur-\u0026gt;children_.find(key[i]); // 没找到 if (it == cur-\u0026gt;children_.end()) { return nullptr; } // 找到了 cur = it-\u0026gt;second; } if (cur-\u0026gt;is_value_node_) { const bustub::TrieNodeWithValue\u0026lt;T\u0026gt; *tnwv = dynamic_cast\u0026lt;const bustub::TrieNodeWithValue\u0026lt;T\u0026gt; *\u0026gt;(cur.get()); return tnwv == nullptr ? nullptr : tnwv-\u0026gt;value_.get(); } return nullptr; 需要注意的是，提示要求我们在找到目标节点之后，需要使用dynamic_cast，这里对我来说就要再补一下课了：\n​\tdynamic_cast：是 C++ 中用于在类层次结构中进行类型转换的一种运算符。它主要用于在运行时执行安全的类型转换\ndynamic_cast 主要用于以下场景：\n​\t向下转型（Downcasting）：将基类指针或引用转换为派生类的指针或引用。 ​\t类型检查：在多态类层次结构中确定对象的实际类型。 ​\t安全转换：确保转换在运行时是有效的，避免类型错误。\n只有在以下条件下，dynamic_cast 才能正常工作：\n​\t多态类型：参与转换的类至少有一个虚函数，这使得类拥有 RTTI。 ​\t有效的类层次结构：目标类型和源类型必须在同一个继承体系中。 转换结果：\n​\t指针转换： ​\t成功：返回指向目标类型的指针。 ​\t失败：返回 nullptr。 ​\t引用转换： ​\t成功：返回引用类型。 ​\t失败：抛出 std::bad_cast 异常。\n3.2 PUT\nPUT方法就有些复杂了，fall 2023要求每次put都要返回一个新的TRIE实例，而不是在原有树上修改，这种设计在多线程环境或需要历史版本数据的场景中非常有用，也为TAKS2做了铺垫。\n这里讲解以下，这题关于put的意思是什么： 一旦put调用，一定会创建一个新的root替换旧root，然后针对key依次访问，如果查的到，就新建对应结点来替换旧结点（如果为叶子节点，就没有clone这一说了），查不到就直接在原本的基础上创建结点并且连接。\n对照示意图，一种比较好的写法是递归！先设置一个递归函数，递归函数思路大致如下：\n查找匹配的首字符：\n​\t遍历当前节点的所有子节点，寻找与键的第一个字符匹配的子节点。\n​\t如果找到匹配的子节点：\n​\t递归情况：如果键长度大于1（非叶子节点），克隆该子节点并递归插入剩余的键部分。\n​\t叶子节点：如果键长度为1（是叶子节点），创建一个TrieNodeWithValue节点，存储值T。\n​\t未找到匹配的子节点：\n​\t如果当前节点没有匹配的子节点，根据键的长度决定如何插入：\n​\t单字符键：直接插入一个TrieNodeWithValue节点。\n​\t多字符键：创建一个新的空TrieNode，并递归插入剩余部分。\n不可变性保证：\n​\t通过Clone方法克隆节点，确保原有节点不被修改。\n​\t更新子节点时，使用新的克隆节点或新创建的节点，确保Trie的不可变性。\n有了递归函数，PUT就很好实现了：\n处理空键：\n​\t如果key为空，将值存储在根节点。\n​\t创建一个新的TrieNodeWithValue作为根节点，存储值T。\n​\t如果原根节点有子节点，新的根节点将保留这些子节点，并添加值T。\n处理非空键：\n​\t克隆当前根节点（如果存在），以确保不可变性。\n​\t调用递归函数递归插入键值对。\n​\t返回一个新的Trie实例，包含更新后的根节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 void put(std::shared_ptr\u0026lt;bustub::TrieNode\u0026gt; new_root, std::string_view key, T val) { bool find = false; // 在new_root的children找key的第一个元素 for (auto \u0026amp;pair : new_root-\u0026gt;children_) { // 如果找到了 if (key.at(0) == pair.first) { find = true; // 剩余键长度大于1 if (key.size() \u0026gt; 1) { // 复制一份找到的子节点，然后递归对其写入 std::shared_ptr\u0026lt;bustub::TrieNode\u0026gt; ptr = pair.second-\u0026gt;Clone(); // 递归写入 put\u0026lt;T\u0026gt;(ptr, key.substr(1, key.size() - 1), std::move(val)); // 覆盖原本的子节点 pair.second = std::shared_ptr\u0026lt;const TrieNode\u0026gt;(ptr); } else { // 剩余键长度小于等于1，则直接插入 // 创建新的带value的子节点 std::shared_ptr\u0026lt;T\u0026gt; val_p = std::make_shared\u0026lt;T\u0026gt;(std::move(val)); TrieNodeWithValue node_with_val(pair.second-\u0026gt;children_, val_p); // 覆盖原本的子节点 pair.second = std::make_shared\u0026lt;const TrieNodeWithValue\u0026lt;T\u0026gt;\u0026gt;(node_with_val); } return; } } if (!find) { // 没找到，则新建一个子节点 char c = key.at(0); // 如果为键的最后一个元素 if (key.size() == 1) { // 直接插入children std::shared_ptr\u0026lt;T\u0026gt; val_p = std::make_shared\u0026lt;T\u0026gt;(std::move(val)); new_root-\u0026gt;children_.insert({c, std::make_shared\u0026lt;const TrieNodeWithValue\u0026lt;T\u0026gt;\u0026gt;(val_p)}); } else { // 创建一个空的children节点 auto ptr = std::make_shared\u0026lt;TrieNode\u0026gt;(); // 递归 put\u0026lt;T\u0026gt;(ptr, key.substr(1, key.size() - 1), std::move(val)); // 插入 new_root-\u0026gt;children_.insert({c, std::move(ptr)}); } } } // ===----------------------------------------------------------------------===// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* 这里先判断是否是只对根节点的处理，是的话就直接新建根，然后判断树是否为空，空的话就返回，不空的话就新根代替旧根 */ auto Trie::Put(std::string_view key, T value) const -\u0026gt; Trie { // Note that `T` might be a non-copyable type. Always use `std::move` when creating `shared_ptr` on that value. // ===----------------------------------------------------------------------===// // ! 在根节点插入 if (key.empty()) { std::shared_ptr\u0026lt;T\u0026gt; val_p = std::make_shared\u0026lt;T\u0026gt;(std::move(value)); std::shared_ptr\u0026lt;bustub::TrieNodeWithValue\u0026lt;T\u0026gt;\u0026gt; newRoot = nullptr; // 如果根节点无子节点 if (root_-\u0026gt;children_.empty()) { // 直接修改根节点 newRoot = std::make_unique\u0026lt;TrieNodeWithValue\u0026lt;T\u0026gt;\u0026gt;(std::move(val_p)); } else { // 如果有，构造一个新节点，children指向root_的children newRoot = std::make_unique\u0026lt;TrieNodeWithValue\u0026lt;T\u0026gt;\u0026gt;(root_-\u0026gt;children_, std::move(val_p)); } // 返回新的Trie return Trie(std::move(newRoot)); } // ! 拷贝根节点，如果为空，则新建一个空的TrieNode std::shared_ptr\u0026lt;bustub::TrieNode\u0026gt; newRoot = nullptr; if (this-\u0026gt;root_ == nullptr) { newRoot = std::make_unique\u0026lt;TrieNode\u0026gt;(); } else { newRoot = root_-\u0026gt;Clone(); // 调用 Clone() 方法拷贝根节点 } // ! 递归插入 put\u0026lt;T\u0026gt;(newRoot, key, std::move(value)); // ! 返回新的Trie return Trie(std::move(newRoot)); // ===----------------------------------------------------------------------===// // You should walk through the trie and create new nodes if necessary. If the node corresponding to the key already // exists, you should create a new `TrieNodeWithValue`. } 3.3 REMOVE：(remove的思路：在删除对应的（key，value）后，没有值以及没有子结点的结点是不应该存在的)\nput顺利实现后，remove就依葫芦画瓢了，思路基本一致：\n​\t先写一个递归函数，实现思路如下：\n​\t查找匹配的首字符：\n​\t遍历当前节点的所有子节点，寻找与键的第一个字符匹配的子节点。\n​\t如果未找到匹配的子节点，函数返回false，表示删除失败。\n​\t删除逻辑：\n​\t键长度为1：\n​\t检查对应的子节点是否为值节点（is_value_node_）。\n​\t如果不是值节点，说明键不存在，返回false。\n​\t如果是值节点：\n​\t且没有子节点：直接删除该子节点。\n​\t有子节点：将该子节点转换为普通的TrieNode，即删除其值，但保留子节点。\n​\t返回true，表示删除成功。\n​\t键长度大于1：\n​\t克隆当前子节点（确保不可变性）。\n​\t递归调用递归函数，传入克隆后的子节点和键的剩余部分（去掉首字符）。\n​\t如果递归调用返回false，表示删除失败，返回false。\n​\t删除后处理：\n​\t如果克隆后的子节点没有子节点且不是值节点，删除该子节点。\n​\t否则，更新子节点为克隆后的子节点。\n​\t返回true，表示删除成功。\n再实现Remove函数：\n​\t处理根节点为空的情况：\n​\t如果root_为空，说明Trie为空，直接返回当前Trie实例（无变化）。\n​\t处理空键（空字符串）的情况：\n​\t如果key为空，意味着要删除存储在根节点的值。\n​\t根节点是值节点：\n​\t**且没有子节点：**删除根节点，返回一个空的Trie。\n​\t**有子节点：**将根节点转换为普通的TrieNode，删除其值，但保留子节点，返回新的Trie。\n​\t**根节点不是值节点：**键不存在，返回当前Trie实例（无变化）。\n​\t处理非空键：\n​\t克隆当前根节点，确保不可变性。\n​\t调用RemoveCycle递归删除键值对。\n​\t删除成功：\n​\t如果新的根节点没有子节点且不是值节点，设置new_root为nullptr（Trie为空）。\n​\t否则，使用更新后的new_root创建并返回一个新的Trie实例。\n​\t删除失败：键不存在，返回当前Trie实例（无变化）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // ===----------------------------------------------------------------------===// bool remove(std::shared_ptr\u0026lt;bustub::TrieNode\u0026gt; new_root, std::string_view key) { // 在new_root的children找key的第一个元素 for (auto \u0026amp;pair : new_root-\u0026gt;children_) { // 继续找 if (key.at(0) != pair.first) { continue; } if (key.size() == 1) { // 是键结尾 if (!pair.second-\u0026gt;is_value_node_) { return false; } // 如果子节点为空，直接删除 if (pair.second-\u0026gt;children_.empty()) { new_root-\u0026gt;children_.erase(pair.first); } else { // 否则转为tirenode pair.second = std::make_shared\u0026lt;const TrieNode\u0026gt;(pair.second-\u0026gt;children_); } return true; } // 拷贝一份当前节点 std::shared_ptr\u0026lt;bustub::TrieNode\u0026gt; ptr = pair.second-\u0026gt;Clone(); // 递归删除 bool flag = remove(ptr, key.substr(1, key.size() - 1)); // 如果没有可删除的键 if (!flag) { return false; } // 如果删除后当前节点无value且子节点为空，则删除 if (ptr-\u0026gt;children_.empty() \u0026amp;\u0026amp; !ptr-\u0026gt;is_value_node_) { new_root-\u0026gt;children_.erase(pair.first); } else { // 否则将删除的子树覆盖原来的子树 pair.second = std::shared_ptr\u0026lt;const TrieNode\u0026gt;(ptr); } return true; } return false; } // ===----------------------------------------------------------------------===// auto Trie::Remove(std::string_view key) const -\u0026gt; Trie { // throw NotImplementedException(\u0026#34;Trie::Remove is not implemented.\u0026#34;); // ===----------------------------------------------------------------------===// // 树为空 if (this-\u0026gt;root_ == nullptr) { return *this; } // 键为空 if (key.empty()) { // 根节点有value if (root_-\u0026gt;is_value_node_) { // 根节点无子节点 if (root_-\u0026gt;children_.empty()) { // 直接返回一个空的trie return Trie(); } else { // 根节点有子节点，转为tirenode std::shared_ptr\u0026lt;bustub::TrieNode\u0026gt; newRoot = std::make_shared\u0026lt;TrieNode\u0026gt;(root_-\u0026gt;children_); return Trie(newRoot); } } // 根节点无value，直接返回 return *this; } // 创建一个当前根节点的副本作为新的根节点 std::shared_ptr\u0026lt;bustub::TrieNode\u0026gt; newRoot = root_-\u0026gt;Clone(); // 删除 bool flag = remove(newRoot, key); if (!flag) { return *this; } if (newRoot-\u0026gt;children_.empty() \u0026amp;\u0026amp; !newRoot-\u0026gt;is_value_node_) { newRoot = nullptr; } return Trie(std::move(newRoot)); //===----------------------------------------------------------------------===// // You should walk through the trie and remove nodes if necessary. If the node doesn\u0026#39;t contain a value any more, // you should convert it to `TrieNode`. If a node doesn\u0026#39;t have children any more, you should remove it. } 任务 #2 - 并发键值存储 这里并发的逻辑是并发键值存储应同时为多个读取器和单个写入器提供服务。也就是说，当有人修改 trie 时，仍然可以在旧根上执行读取作。当有人正在读取时，仍然可以执行写入，而无需等待读取。\n也就是说是同一时刻可以有多个读，但是只能有一个写（由于复制的原理，可以边写边读，只需要写只能写副本就行）\n4.1 GET：\n依旧很简单，照着注释写就行，只需要使用互斥锁保护一下根节点的读取即可。\n1 2 3 // (1) 获取根锁，得到根节点，然后释放根锁。在持有根锁时不要在 trie 中查找值。 // (2) 在 trie 中查找值。 // (3) 如果找到值，返回一个 ValueGuard 对象，该对象持有对值和根节点的引用。否则，返回 std::nullopt。 1 2 3 4 5 6 7 8 9 10 11 12 auto TrieStore::Get(std::string_view key) -\u0026gt; std::optional\u0026lt;ValueGuard\u0026lt;T\u0026gt;\u0026gt; { //===----------------------------------------------------------------------===// root_lock_.lock(); auto cur_root = root_; root_lock_.unlock(); auto value = cur_root.Get\u0026lt;T\u0026gt;(key); if (value == nullptr) { return std::nullopt; } return {ValueGuard\u0026lt;T\u0026gt;(std::move(cur_root), *value)}; //===----------------------------------------------------------------------===// } 4.2 PUT： 这里注释提示得很明显了，结合对trie.h的理解，不难想出，要先上一把读写锁。\n除此之外，// The logic should be somehow similar to TrieStore::Get.也提示我们：要复制一份当前根节点，继续保护一下根节点，以保证每个线程都操作的是副本，不会直接修改母本。\n1 2 3 4 5 6 7 8 9 10 11 void TrieStore::Put(std::string_view key, T value) { // 你需要确保同一时间只有一个写入者。想一想如何实现这一点。 // 逻辑应该与 TrieStore::Get 有某种相似之处。 //===----------------------------------------------------------------------===// std::lock_guard\u0026lt;std::mutex\u0026gt; lk(write_lock_); auto new_root = root_.Put\u0026lt;T\u0026gt;(key, std::move(value)); root_lock_.lock(); root_ = new_root; root_lock_.unlock(); //===----------------------------------------------------------------------===// } 4.3 Remove： 如法炮制即可，不做过多赘述。\n1 2 3 4 5 6 7 8 9 10 11 void TrieStore::Remove(std::string_view key) { // 你需要确保同一时间只有一个写入者。想一想如何实现这一点。 // 逻辑应该与 TrieStore::Get 有某种相似之处。 //===----------------------------------------------------------------------===// std::lock_guard\u0026lt;std::mutex\u0026gt; lk(write_lock_); auto new_root = root_.Remove(key); root_lock_.lock(); root_ = new_root; root_lock_.unlock(); //===----------------------------------------------------------------------===// } 任务 #3 - 调试 这里就没什么可讲的了，调试一下看结果就行了。 这里可以参考这篇文章的task3的处理：（全网最详细！！！）CMU15-445（Fall 2023）——从环境搭建开始的P0详细历程及踩坑经历_cmu15445-CSDN博客\n任务 #4 - SQL 字符串函数 task4只需要我们简单编写两个函数，分别是：\n/src/planner/plan_func_call.cpp 里的 ：auto Planner::GetFuncCallFromFactory ()\n/src/include/execution/expressions/string_expression.h 里的 auto Compute ()\n整体不难，大家理解注释，基本上就是写几个条件语句进行调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // NOLINTNEXTLINE auto Planner::GetFuncCallFromFactory(const std::string \u0026amp;func_name, std::vector\u0026lt;AbstractExpressionRef\u0026gt; args) -\u0026gt; AbstractExpressionRef { // 1. 检查解析后的函数名是否为 \u0026#34;lower\u0026#34; 或 \u0026#34;upper\u0026#34;。 // 2. 验证参数的数量（应为 1 个），参考测试用例以确定何时应抛出 Exception 异常。 // 3. 返回一个 StringExpression 的 std::shared_ptr。 //------------------------------------------------------- if (func_name == \u0026#34;lower\u0026#34;) { if (args.size() != 1) { throw Exception(fmt::format(\u0026#34;func lower the number of args should be 1 not {} \u0026#34;, args.size())); } return std::make_shared\u0026lt;StringExpression\u0026gt;(args.front(), bustub::StringExpressionType::Lower); } if (func_name == \u0026#34;upper\u0026#34;) { if (args.size() != 1) { throw Exception(fmt::format(\u0026#34;func upper the number of args should be 1 not {} \u0026#34;, args.size())); } return std::make_shared\u0026lt;StringExpression\u0026gt;(args.front(), bustub::StringExpressionType::Upper); } //------------------------------------------------------- throw Exception(fmt::format(\u0026#34;func call {} not supported in planner yet\u0026#34;, func_name)); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //===----------------------------------------------------------------------===// auto ToLower(const std::string \u0026amp;val) const -\u0026gt; std::string { std::string lower; lower.resize(val.size()); std::transform(val.begin(), val.end(), lower.begin(), ::tolower); return lower; } auto ToUpper(const std::string \u0026amp;val) const -\u0026gt; std::string { std::string upper; upper.resize(val.size()); std::transform(val.begin(), val.end(), upper.begin(), ::toupper); return upper; } //===----------------------------------------------------------------------===// auto Compute(const std::string \u0026amp;val) const -\u0026gt; std::string { // TODO(student): implement upper / lower. //===----------------------------------------------------------------------===// switch (expr_type_) { case StringExpressionType::Lower: return ToLower(val); case StringExpressionType::Upper: return ToUpper(val); default: //===----------------------------------------------------------------------===// return {}; } } 任务 #5 - 提交 （全网最详细！！！）CMU15-445（Fall 2023）——从环境搭建开始的P0详细历程及踩坑经历_cmu15445-CSDN博客\n提交的过程见以上文章即可\n提交网址： View Submission | Gradescope\n参考文献：\n【C++算法模板】字典树，超详细注释带例题讲解_c++字典树-CSDN博客\n[让内存无处可逃：智能指针C++11]_接口用智能指针-CSDN博客\nCMU15445（2023 Spring） - Project 0. C++ Primer_cmu15445 project0-CSDN博客\nCMU15445（2023 Spring） - Project 0. C++ Primer_cmu15445 project0-CSDN博客\ncmu15445 2023fall project0 C++ prime-CSDN博客\n（全网最详细！！！）CMU15-445（Fall 2023）——从环境搭建开始的P0详细历程及踩坑经历_cmu15445-CSDN博客\nCMU15445 Fall2023 Project 0-4 通关全记录 - 知乎\nCMU15445 2023fall project0详细过程_15445 2023 fall-CSDN博客\n[CMU15445-2023Fall，Lab0 C++Primer 个人流程记录-CSDN博客](https://blog.csdn.net/EQUINOX1/article/details/142740875?ops_request_misc=%7B%22request%5Fid%22%3A%2283adc256f0232def1afe12b892ef5e58%22%2C%22scm%22%3A%2220140713.130102334..%22%7D\u0026request_id=83adc256f0232def1afe12b892ef5e58\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-142740875-null-null.142^v101^pc_search_result_base5\u0026utm_term=cmu15445 2023fall\u0026amp;spm=1018.2226.3001.4187)\n[CMU15445 2023fall project0详细过程_15445 2023 fall-CSDN博客](https://blog.csdn.net/qq_40878302/article/details/136005292?ops_request_misc=%7B%22request%5Fid%22%3A%2283adc256f0232def1afe12b892ef5e58%22%2C%22scm%22%3A%2220140713.130102334..%22%7D\u0026request_id=83adc256f0232def1afe12b892ef5e58\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-136005292-null-null.142^v101^pc_search_result_base5\u0026utm_term=cmu15445 2023fall\u0026amp;spm=1018.2226.3001.4187)\ncmu15445clang-tidy培养码风 - 知乎\nCMU15-445：Project #0 - C++ Primer - M1kanN - 博客园\n","date":"2024-11-11T15:29:00+08:00","permalink":"https://1878247293.github.io/p/cmu15445-2023-fall-p0/","title":"cmu15445 2023 fall   p0"},{"content":"项目网址： Project #1 - Buffer Pool | CMU 15-445/645 :: Intro to Database Systems (Fall 2023)\n在进行下列任务时可以先学习一些前置知识点： 缓存替换策略：LRU-K算法详解及其C++实现 CMU15-445 Project#1-CSDN博客https://blog.csdn.net/EQUINOX1/article/details/134897555)\n在数据库系统中，框架（Frame）和页面（Page）是两个密切相关的概念，它们在内存管理和数据存储中扮演着不同的角色。下面我将详细解释它们之间的关系：\n页面（Page）\n页面是数据库系统中数据存储的基本单位。每个页面通常具有相同的大小，例如 4KB、8KB 等。页面可以包含表数据、索引数据或其他类型的数据库对象。页面是数据库系统中数据的逻辑表示，是数据在磁盘和内存之间的传输单位。\n框架（Frame）\n框架是内存中用于存储页面的物理位置。框架是内存管理的基本单位，每个框架可以存储一个页面。框架的大小与页面的大小相同，通常是固定的。\n任务 #1 - LRU-K 更换政策 LRU-K是在LRU 的基础上，出现次数小于K的，时间按无穷大算，反之，按倒数第k次出现的时间算。依次我们只需要建立俩个表，小于k的放到表1，采用先进先出的方式进行淘汰，大等于k的放在表二，并且记录k次的出现时间，采用LRU的策略进行淘汰。\n先在.h文件中添加以下定义变量：\n1 2 3 4 5 6 7 8 9 10 //===----------------------------------------------------------------------===// public: std::list\u0026lt;size_t\u0026gt; history_; // 存储最近的K个时间戳历史记录 size_t k_; // K值，表示最近访问的历史记录数量 frame_id_t fid_; // 框架ID，表示页面ID bool is_evictable_{false}; // 是否可淘汰 auto GetBackKTimeStamp() { return history_.front(); } // 获取最早的K个时间戳 auto GetLatestTimeStamp() { return history_.front(); } // 获取最新的时间戳 //===----------------------------------------------------------------------===// 1 2 3 4 5 6 7 8 //===----------------------------------------------------------------------===// std::unordered_map\u0026lt;frame_id_t, LRUKNode\u0026gt; node_store_; // 存储LRUK节点的哈希表 size_t current_timestamp_{0}; // 当前时间戳 size_t current_size_{0}; // 当前大小 size_t replacer_size_; // 替换器大小 size_t k_; // k值 std::mutex latch_; // 互斥量，用于保护并发访问 //===----------------------------------------------------------------------===// Task 1一共需要我们完成如下五个函数，也就是上面提到的缓冲池内部对frame的具体操作：\nEvict(frame_id_t frame_id) ：*\nSize() :\nRecordAccess(frame_id_t frame_id) :\nRemove(frame_id_t frame_id) :\nSetEvictable(frame_id_t frame_id, bool set_evictable) :\n建议跟着我的顺序完成五个函数：\n1 Size() : 直接返回当前的curr_size即可\n1 2 3 4 auto LRUKReplacer::Size() -\u0026gt; size_t //{ return 0; } //===----------------------------------------------------------------------===// { return current_size_; } //===----------------------------------------------------------------------===// 2 RecordAccess : RecordAccess 方法的主要功能是记录缓存帧的访问，依据 LRU-K 算法更新帧的访问历史和状态。该方法通过判断帧的访问次数，决定该帧是留在未满 K 次访问的队列，还是移入满 K 次访问的队列。\n具体实现思路为：\n1.更新访问时间戳current_timestamp_和访问次数recorded_cnt_[frame_id]\n2.对访问次数进行判断，若是第一次访问：先更新相关记录标志，如 evictable，curr_size等等，然后将其加入new_frame，即未满K次队列\n3.若访问次数达到K次：首先从 new_frame_ 中删除该帧及其位置信息，取出该帧在 hist_ 中的第一个时间戳（即第 K 次访问时的时间），将帧插入 cache_frame_。\n这里要注意：cache_frame_ 是一个按时间戳有序的队列，要保证插入后仍然有序。\n4.访问次数超过 K：如果该帧的访问次数超过 K，则需要更新 cache_frame_ 中该帧的时间戳。\n这里同样要注意：我们只保留最近 K 次的访问记录，所以首先删除该帧在 hist_ 中最早的访问时间戳；其次，还要按照新的时间将该帧戳重新插入到 cache_frame_ 中，并更新该帧在 cache_frame_ 中的位置信息，保证cache_frame_ 按时间戳有序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void LRUKReplacer::RecordAccess(frame_id_t frame_id, [[maybe_unused]] AccessType access_type)// {} //===----------------------------------------------------------------------===// { std::scoped_lock\u0026lt;std::mutex\u0026gt; lock(latch_); auto helper = static_cast\u0026lt;size_t\u0026gt;(frame_id); BUSTUB_ASSERT(helper \u0026lt;= replacer_size_, \u0026#34;invalid frame_id\u0026#34;); auto iter = node_store_.find(frame_id); if (iter == node_store_.end()) { // Fail to find out the LRUKNode. auto new_node_ptr = std::make_unique\u0026lt;LRUKNode\u0026gt;(); if (access_type != AccessType::Scan) { new_node_ptr-\u0026gt;history_.push_back(current_timestamp_++); } node_store_.insert(std::make_pair(frame_id, *new_node_ptr)); } else { auto \u0026amp;node = iter-\u0026gt;second; if (access_type != AccessType::Scan) { if (node.history_.size() == k_) { node.history_.pop_front(); } node.history_.push_back(current_timestamp_++); } } } //===----------------------------------------------------------------------===// 3 Evict： 完成并理解RecordAccess之后，Evict 就很容易了：\n1.先在未满 K 次队列进行驱逐：这里注意，new_frame队列用的数据结构是list，所以我们可以采取LRU策略，从后往前遍历，找到可驱逐帧，然后将相关标志量处理以完成驱逐操作，这里也有 evictable_[frame]进行辅助判断，很简单。当然，new_frame队列中的驱逐策略很多选，大家选择合适的喜欢的即可。\n2.在满k队列中进行驱逐： 得益于之前我们悉心维护cache_frame队列的“按时间戳有序”特性，这里的驱逐只需从前往后遍历，按上一步的操作进行具体驱逐即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 auto LRUKReplacer::Evict(frame_id_t *frame_id) -\u0026gt; bool// { return false; } //===----------------------------------------------------------------------===// { std::scoped_lock\u0026lt;std::mutex\u0026gt; lock(latch_); size_t largest_bkd = 0; size_t largest_distance = 0; bool success_evict = false; bool is_inf = false; LRUKNode *evict_node_ptr = nullptr; for (auto \u0026amp;pair : node_store_) { auto \u0026amp;node = pair.second; if (!node.is_evictable_) { continue; } success_evict = true; if (node.history_.empty()) { *frame_id = pair.first; evict_node_ptr = \u0026amp;node; break; } if (node.history_.size() == k_ \u0026amp;\u0026amp; !is_inf) { auto current_bkd = current_timestamp_ - node.GetBackKTimeStamp(); if (current_bkd \u0026gt; largest_bkd) { largest_bkd = current_bkd; *frame_id = pair.first; evict_node_ptr = \u0026amp;node; } } else if (node.history_.size() \u0026lt; k_) { is_inf = true; auto current_distance = current_timestamp_ - node.GetLatestTimeStamp(); if (current_distance \u0026gt; largest_distance) { largest_distance = current_distance; *frame_id = pair.first; evict_node_ptr = \u0026amp;node; } } } if (success_evict) { current_size_--; evict_node_ptr-\u0026gt;history_.clear(); node_store_.erase(*frame_id); } return success_evict; } //===----------------------------------------------------------------------===// 4 SetEvictable(frame_id_t frame_id, bool set_evictable) : 这个简单，按传进来的bool参数，把可驱逐的设置成不可驱逐，把不可驱逐的设置成可驱逐即可。\n只是别恰巧搞混了（别问我为什么要这么说）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void LRUKReplacer::SetEvictable(frame_id_t frame_id, bool set_evictable) //{} //===----------------------------------------------------------------------===// { std::scoped_lock\u0026lt;std::mutex\u0026gt; lock(latch_); auto helper = static_cast\u0026lt;size_t\u0026gt;(frame_id); BUSTUB_ASSERT(helper \u0026lt;= replacer_size_, \u0026#34;invalid frame_id\u0026#34;); std::unique_ptr\u0026lt;LRUKNode\u0026gt; new_node_ptr; auto iter = node_store_.find(frame_id); if (iter == node_store_.end()) { // Fail to find out the LRUKNode. new_node_ptr = std::make_unique\u0026lt;LRUKNode\u0026gt;(); node_store_.insert(std::make_pair(frame_id, *new_node_ptr)); } auto \u0026amp;node = (iter == node_store_.end()) ? *new_node_ptr : iter-\u0026gt;second; if (set_evictable \u0026amp;\u0026amp; !node.is_evictable_) { node.is_evictable_ = set_evictable; current_size_++; } if (!set_evictable \u0026amp;\u0026amp; node.is_evictable_) { node.is_evictable_ = set_evictable; current_size_--; } } //===----------------------------------------------------------------------===// 5 Remove : 这里先补充一下Remove 和 Evict 的区别：看着好像都是“去除，删除”的意思。但主要区别在于使用场景不同：\n一般当缓冲池的空间不足，需要加载新的页面（frame）时，会调用Evict函数来腾出空间，而Remove 函数用于显式地移除指定的页面，前提是该页面可以被驱逐（即是可驱逐的，并且存在于缓存中）。（如果这里的字面解释你还看不太懂，可以跳到后面Task 3 的部分，找两个函数的具体应用场景，就很容易理解了）\n那么具体的实现思路如下：\n1.首先检查输入合法性，frame_id的范围等等，最重要的，要主动Remove的帧必须首先是可驱逐的。然后判断该帧访问次数cnt。\n2.若cnt \u0026lt; k，则在new_frame队列中删除，若cnt \u0026gt;= k，则在cache_frame队列中删除。\n到这里，task1就完成了，主要难度还是在理解整体架构，维护数据结构上，有了顶层概念以后，具体实现就都是按部就班，没什么额外难度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void LRUKReplacer::Remove(frame_id_t frame_id)// {} //===----------------------------------------------------------------------===// { std::scoped_lock\u0026lt;std::mutex\u0026gt; lock(latch_); auto iter = node_store_.find(frame_id); if (iter == node_store_.end()) { return; } auto \u0026amp;node = iter-\u0026gt;second; BUSTUB_ASSERT(node.is_evictable_, \u0026#34;Called on a non-evictable frame.\u0026#34;); node.history_.clear(); node_store_.erase(frame_id); current_size_--; } //===----------------------------------------------------------------------===// 任务 #2 - 磁盘调度程序 这里类似实现的是用请求队列来对请求排序，实现单线程按顺序处理请求。\n1 其他组件（在本例中为任务 #3）可以使用磁盘调度程序对磁盘请求进行排队，由结构体（已在 `src/include/storage/disk/disk_scheduler.h` 中定义）表示。磁盘调度程序将维护一个后台工作线程，该线程负责处理计划的请求。`BufferPoolManager``DiskRequest` 1.后台异步线程 后台线程用于异步执行某些操作而不阻塞主线程。通过启动一个后台线程异步处理磁盘请求，实现了生产者-消费者模型：\n​\tSchedule 方法相当于生产者，将磁盘请求放入队列。 ​\tStartWorkerThread 方法相当于消费者，从队列中取出请求并执行实际的磁盘读写操作。 ​\t通过 std::optional 来管理请求队列，使用 std::nullopt 作为特殊信号来停止后台线程。 ​\t异步线程通常用于需要执行耗时任务的场景（比如磁盘读写操作），而主线程可以继续执行其他任务。这种方式通过并行处理提高了程序的性能。\n2.std::optional std::optional 是 C++17 引入的一个标准库类型，它用于表示一个值可能存在或不存在的情况。可以把它看作是一个可以为空的值的包装器，类似于指针，但是更安全和简洁。\n​\t如果 std::optional 包含值，可以通过 has_value() 来检查是否有值，或者使用 operator bool() 检查。\n​\t如果值不存在，可以用 std::nullopt 来表示。\n3.emplace emplace 是一种避免临时对象构造的方法，能够在容器中“原地构造”对象，避免不必要的拷贝操作，提高性能。具体到此处：emplace方法直接在std::thread对象内部构造线程，而不需要先创建一个线程对象然后再赋值给std::thread。它接受与构造函数相同的参数，并直接用于初始化线程对象。\n4.lambda 表达式和 [\u0026amp;] lambda 表达式是 C++11 引入的用于定义匿名函数的特性，它使得我们可以在函数内部定义和传递小型的、临时的函数。\n​\tlambda 表达式的基本形式为：\ncapture -\u0026gt; return_type { body }\ncapture 是捕获列表，用于指定 lambda 可以访问哪些外部变量：\n[\u0026amp;]：按引用捕获所有外部变量，可以在 lambda 中修改这些变量。\n[=]：按值捕获所有外部变量，仅能在 lambda 内读取这些变量。\n[x]：按值捕获变量 x。\n[\u0026amp;x]：按引用捕获变量 x。\ncapture 捕获完成后，body中应用这些捕获到的变量进行具体操作。\n5.函数实现： 1.Schedule 方法： Schedule 方法用于向 request_queue_ 中添加一个磁盘请求 DiskRequest，实现请求的调度，直接put就行。\n1 2 3 4 5 6 void DiskScheduler::Schedule(DiskRequest r) { //===----------------------------------------------------------------------===// request_queue_.Put(std::move(r));//将请求 r 放入请求队列中。std::move 用于将请求的所有权转移给队列。 //===----------------------------------------------------------------------===// } ​\t2.StartWorkerThread 方法： StartWorkerThread 是一个在后台线程中运行的函数，负责从队列中获取磁盘请求并执行读写操作。判断队列中的每一个请求类型，然后调用channel.h中的读写函数完成操作即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void DiskScheduler::StartWorkerThread() { //===----------------------------------------------------------------------===// //用于存储从队列中获取的请求。 std::optional\u0026lt;DiskRequest\u0026gt; request; //从请求队列中获取请求，直到获取到 std::nullopt while ((request = request_queue_.Get())) { if (request) { if (request-\u0026gt;is_write_) {// 如果请求有效，处理请求 disk_manager_-\u0026gt;WritePage(request-\u0026gt;page_id_, request-\u0026gt;data_);//如果请求是写操作，调用 disk_manager_-\u0026gt;WritePage 写入页面。 request-\u0026gt;callback_.set_value(true);//设置回调函数的值，表示操作完成 continue; } // 如果请求是读操作，调用 disk_manager_-\u0026gt;ReadPage 读取页面。 disk_manager_-\u0026gt;ReadPage(request-\u0026gt;page_id_, request-\u0026gt;data_); request-\u0026gt;callback_.set_value(true);//和这个promise 有关 } } //===----------------------------------------------------------------------===// } 任务 #3 - 缓冲池管理器 ​\tTask #3是宏观上调用控制各个部分,也就是通过调用task1和task2所涉及到的代码，来实现缓冲池管理器，其中，task1是关于内存处的替换策略，task2是关于对磁盘进行处理的请求处理。\n​\t利用page_table对缓冲池进行操作，利用disk_scheduler后台异步线程处理磁盘读写。\n​\t那么只要脑子里有上图这个宏观架构，我们就只需要按照注释一步步实现Task 3中的6个函数即可：\n1.相关知识补课： 1.std::scoped_lock： 这里半途了解到std::scoped_lock，就和之前用的std::lock_guard区别一下：\n​\tstd::scoped_lock：\n​\t可以同时锁定多个互斥锁。\n​\t它通过可变参数模板的方式，可以同时锁住多个互斥锁，避免手动嵌套锁定多个互斥锁时可能引发的死锁问题。\n​\t它内部会自动使用 std::lock()，保证多个锁按正确的顺序同时加锁，防止死锁。\n​\tstd::lock_guardstd::mutex：\n​\t只能锁定单个互斥锁。\n​\t如果需要锁定多个互斥锁，需要手动嵌套多个 lock_guard，这会引入死锁风险，尤其是如果锁的顺序不一致的情况下。\n​\t2.std::future和std::promise ​\t由于task2中采用了后台异步多线程的操作，那么我们在调用的时候，也要采用异步线程操作。\n​\t具体学习看这篇：\n​\tc++11多线程编程同步——使用future和promise_c++ future同步超时-CSDN博客\n2.Flush page(刷新，即写回磁盘) FlushPage 函数的主要功能是：\n​\t将指定 page_id 对应的页面从缓冲池写回磁盘。\n​\t如果该页面没有发生过修改（即不是脏页），则不执行写回操作。\n​\t在写回操作后，页面的脏标志位被重置为 false。\n​\t这里重点解析一下异步写入调度：\n​\t创建一个 promise 对象，用于通知主线程磁盘写入操作的结果。promise 与 future 相互关联，主线程可以通过 future.get() 来等待异步操作的结果。\n​\t调用 disk_scheduler_-\u0026gt;Schedule() 方法，将页面的写入任务提交给后台异步线程处理。Schedule() 方法会构造一个磁盘请求对象 DiskRequest，表示将该页面的数据写入磁盘，并将其调度到 DiskScheduler 的后台线程执行。\n​\tfuture.get() 会阻塞主线程，直到后台线程完成写入任务，确保页面写入磁盘操作已经完成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 刷新页面 auto BufferPoolManager::FlushPage(page_id_t page_id) -\u0026gt; bool //{ return false; } {//===----------------------------------------------------------------------===// std::scoped_lock\u0026lt;std::mutex\u0026gt; lock(latch_); BUSTUB_ASSERT(page_id != INVALID_PAGE_ID, \u0026#34;page_id is invalid\u0026#34;); auto itr = page_table_.find(page_id); if (itr == page_table_.end()) {// 检查页面表：如果页面不在缓冲池中，返回失败。 return false; } auto target_id = itr-\u0026gt;second; auto promise = disk_scheduler_-\u0026gt;CreatePromise(); auto future = promise.get_future(); // 写回磁盘：将页面数据写回磁盘。 disk_scheduler_-\u0026gt;Schedule({true, pages_[target_id].data_, pages_[target_id].page_id_, std::move(promise)}); future.get(); pages_[target_id].is_dirty_ = false;// 清除脏标志：清除页面的脏标志。 return true; }//===----------------------------------------------------------------------===// 3.FlushAllPages 将所有有效的缓存页写回磁盘，无视is_dirty_标志\n具体实现和Flush page一样。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 刷新所有页面 void BufferPoolManager::FlushAllPages()//{} {//===----------------------------------------------------------------------===// std::scoped_lock\u0026lt;std::mutex\u0026gt; lock(latch_); for (auto \u0026amp;pair : page_table_) {// 遍历页面表：将所有页面写回磁盘。 page_id_t page_id = pair.first; BUSTUB_ASSERT(page_id != INVALID_PAGE_ID, \u0026#34;page_id is invalid\u0026#34;); auto iter = page_table_.find(page_id); auto target_id = iter-\u0026gt;second; auto promise = disk_scheduler_-\u0026gt;CreatePromise(); auto future = promise.get_future(); disk_scheduler_-\u0026gt;Schedule({true, pages_[target_id].data_, pages_[target_id].page_id_, std::move(promise)}); future.get(); pages_[target_id].is_dirty_ = false;// 清除脏标志：清除所有页面的脏标志。 } }//===----------------------------------------------------------------------===// 4.UnpinPage 用于减少页在缓冲池中的 pin_count_（引用计数），并标记该页是否脏页（即是否需要在未来写回磁盘）。如果 pin_count_ 变为零，表示该页不再被使用，此时可以将该页标记为可逐出的页，从而允许其被替换。\n其中关键的概念如下：\npin_count_: 用于跟踪某个页的被引用次数。每个进程调用 FetchPage 时，pin_count_ 增加；调用 UnpinPage 时，pin_count_ 减少。当 pin_count_ 为 0 时，表示该页不再被使用，可以被逐出。\n脏页标记: 如果数据页发生修改，它会被标记为脏页。脏页必须在替换时写回磁盘以防止数据丢失。is_dirty 参数用于指定页面是否已经修改过。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 解除页面固定 auto BufferPoolManager::UnpinPage(page_id_t page_id, bool is_dirty, [[maybe_unused]] AccessType access_type) -\u0026gt; bool //{return false;} {//===----------------------------------------------------------------------===// std::scoped_lock\u0026lt;std::mutex\u0026gt; lock(latch_); auto itr = page_table_.find(page_id); if (itr == page_table_.end() || pages_[itr-\u0026gt;second].pin_count_ \u0026lt;= 0) { return false; } if ((--pages_[itr-\u0026gt;second].pin_count_) == 0) {// 减少固定计数：减少页面的固定计数。 replacer_-\u0026gt;SetEvictable(itr-\u0026gt;second, true); } if (is_dirty) { pages_[itr-\u0026gt;second].is_dirty_ = is_dirty;// 设置脏标志：如果页面被修改，设置脏标志。 } return true; }//===----------------------------------------------------------------------===// 5.NewPage 用于为缓冲池分配一个新的页。当需要创建一个新的页时，这个函数负责在缓冲池中找到一个空闲的页框，初始化该页并返回新创建的页\n主要实现流程（其实就是按照.h文件里的注释来）：\n尝试从空闲页列表 free_list_ 中获取页框。 如果 free_list_ 为空，尝试通过页替换器逐出一个页框。如果需要，先将脏页写回磁盘。 为新页分配一个新的 page_id。 初始化新页的内存，更新页表并设置引用计数。 返回新页指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 新建一个页面，用于之后来存储数据 auto BufferPoolManager::NewPage(page_id_t *page_id) -\u0026gt; Page * //{ return nullptr; } {//===----------------------------------------------------------------------===// std::scoped_lock\u0026lt;std::mutex\u0026gt; lock(latch_); frame_id_t replacement_frame_id; if (!free_list_.empty()) {//如果有空闲框架，直接使用。 replacement_frame_id = free_list_.front(); free_list_.pop_front(); } else {//如果没有空闲框架，使用替换器选择一个框架 if (!replacer_-\u0026gt;Evict(\u0026amp;replacement_frame_id)) { page_id = nullptr; return nullptr; } auto \u0026amp;helper = pages_[replacement_frame_id]; if (helper.IsDirty()) {// 如果替换的框架包含脏页，将其写回磁盘。 auto promise = disk_scheduler_-\u0026gt;CreatePromise(); auto future = promise.get_future(); disk_scheduler_-\u0026gt;Schedule({true, helper.GetData(), helper.page_id_, std::move(promise)}); future.get(); } page_table_.erase(helper.page_id_); } // 获取一个新的页面ID。 auto new_page_id = AllocatePage(); *page_id = new_page_id; //重置框架的内存和元数据。 pages_[replacement_frame_id].ResetMemory(); pages_[replacement_frame_id].pin_count_ = 0; pages_[replacement_frame_id].is_dirty_ = false; // 将新页面的ID和框架ID插入页面表。 page_table_.insert(std::make_pair(new_page_id, replacement_frame_id)); // 调用 replacer_-\u0026gt;SetEvictable。设置框架不可替换 replacer_-\u0026gt;SetEvictable(replacement_frame_id, false); // 记录访问历史 replacer_-\u0026gt;RecordAccess(replacement_frame_id); pages_[replacement_frame_id].pin_count_++; pages_[replacement_frame_id].page_id_ = new_page_id; return \u0026amp;pages_[replacement_frame_id]; }//===----------------------------------------------------------------------===// 6.FetchPage 负责从磁盘或其他存储介质中加载特定页面到内存的缓冲池中。该操作通常与页面缓冲管理和数据库查询紧密相关。\n实现流程：\n检查page_table，查看请求的页面是否已在缓冲池中：\n如果找到，增加 pin_count_，返回页面指针\n如果未找到，检查free_list：\n如果有空闲页框frame_id，使用之；\n如果没有，尝试通过页替换器replacer_逐出一个页框。\n从磁盘加载新页面，初始化状态，并更新页表page_table。\n返回新加载页面的指针。\n总结下来有两种情况： (1)先在缓冲池里找这个页面，如果有直接返回就行。 (2)如果没有，和上面的newpage一样，申请一个新帧。区别在于，newpage放进去的内容是AllocatePage()给的，这个是从磁盘读取的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // 电脑获取页面的数据 auto BufferPoolManager::FetchPage(page_id_t page_id, [[maybe_unused]] AccessType access_type) -\u0026gt; Page * //{return nullptr;} {//===----------------------------------------------------------------------===// std::scoped_lock\u0026lt;std::mutex\u0026gt; lock(latch_); // 检查页面表：如果页面已在缓冲池中，直接返回。 auto iter = page_table_.find(page_id); if (iter != page_table_.end()) { auto frame_id = iter-\u0026gt;second; replacer_-\u0026gt;SetEvictable(frame_id, false); replacer_-\u0026gt;RecordAccess(frame_id, access_type); pages_[iter-\u0026gt;second].pin_count_++; return \u0026amp;pages_[iter-\u0026gt;second]; } //选择替换框架：如果页面不在缓冲池中，选择一个框架。 frame_id_t replacement_frame_id; if (!free_list_.empty()) { replacement_frame_id = free_list_.front(); free_list_.pop_front(); } else { if (!replacer_-\u0026gt;Evict(\u0026amp;replacement_frame_id)) { return nullptr; } auto \u0026amp;helper = pages_[replacement_frame_id]; if (helper.IsDirty()) {// 处理脏页：如果替换的框架包含脏页，将其写回磁盘。 auto promise1 = disk_scheduler_-\u0026gt;CreatePromise(); auto future1 = promise1.get_future(); disk_scheduler_-\u0026gt;Schedule({true, helper.data_, helper.page_id_, std::move(promise1)}); future1.get(); } page_table_.erase(helper.page_id_); } // 加载页面：从磁盘加载页面数据到框架。 pages_[replacement_frame_id].ResetMemory(); pages_[replacement_frame_id].pin_count_ = 0; pages_[replacement_frame_id].is_dirty_ = false; auto promise2 = disk_scheduler_-\u0026gt;CreatePromise(); auto future2 = promise2.get_future(); disk_scheduler_-\u0026gt;Schedule({false, pages_[replacement_frame_id].GetData(), page_id, std::move(promise2)}); // 更新页面表：将页面的ID和框架ID插入页面表。 page_table_.insert(std::make_pair(page_id, replacement_frame_id)); // 设置框架不可替换： replacer_-\u0026gt;SetEvictable(replacement_frame_id, false); // 记录访问历史 replacer_-\u0026gt;RecordAccess(replacement_frame_id, access_type); pages_[replacement_frame_id].pin_count_++; pages_[replacement_frame_id].page_id_ = page_id; future2.get(); return pages_ + replacement_frame_id; }//===----------------------------------------------------------------------===// 7.Delete page 用于从内存中的缓冲池和相关数据结构中删除一个特定的页面，涉及到减少或更新与该页面相关的信息，如页表、引脚计数等。\n实现流程：\n查找page_table，确认要删除的页面是否存在：\n如果未找到，返回 false。\n获取对应的帧 ID 和页面指针。\n检查并处理脏页，必要时将其写回磁盘。\n从页表中移除该页面（这里可以直接调用Remove函数），并更新相关状态（如 pin_count_）。\n将帧 ID 添加到空闲列表中，以备后续使用。\n返回 true，表示删除成功。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 删除页面 auto BufferPoolManager::DeletePage(page_id_t page_id) -\u0026gt; bool //{ return false; } {//===----------------------------------------------------------------------===// std::scoped_lock\u0026lt;std::mutex\u0026gt; lock(latch_); auto iter = page_table_.find(page_id); if (iter == page_table_.end()) {// 检查页面表：如果页面不在缓冲池中，返回成功。 return true; } auto target_id = iter-\u0026gt;second; if (pages_[target_id].pin_count_ \u0026gt; 0) {// 检查固定计数：如果页面被固定，返回失败。 return false; } // 删除页面：从页面表中删除页面，释放框架。 page_table_.erase(page_id); replacer_-\u0026gt;Remove(target_id); free_list_.push_back(target_id); pages_[target_id].ResetMemory(); // reset metadata of the page // 重置页面：重置框架的内存和元数据。 pages_[target_id].page_id_ = INVALID_PAGE_ID; pages_[target_id].pin_count_ = 0; pages_[target_id].is_dirty_ = false; // 释放页面：调用 DeallocatePage。 DeallocatePage(page_id); return true; }//===----------------------------------------------------------------------===// 以下是参考的文章：\nCMU15445 Fall2023 Project 0-4 通关全记录 - 知乎\nCMU15-445 Fall 2023 PROJECT #1 - BUFFER POOL - 知乎\nCMU15-445-P1全局思路及详细实现过程（超超超超详细，我奶都能看懂！！！）-CSDN博客\nc++11多线程编程同步——使用future和promise_c++ future同步超时-CSDN博客\nCMU 15445 Project 1 - xxxl\u0026rsquo;s Blog\n缓存替换策略：LRU-K算法详解及其C++实现 CMU15-445 Project#1-CSDN博客\nCMU15445 2023project1详细过程（上）lru-k替换算法_cmu15445 lru-k-CSDN博客\n","date":"2024-11-11T15:29:00+08:00","permalink":"https://1878247293.github.io/p/cmu15445-2023-fall-p1/","title":"cmu15445 2023 fall   p1"},{"content":"项目网址： 项目 #2 - 可扩展哈希索引 |CMU 15-445/645 ：： 数据库系统简介（2023 年秋季）\n全局思路： 总的来说，我们要在数据库系统中实现磁盘支持的哈希索引，使用可扩展哈希的变体作为哈希方案，如下图：\n可见整个索引结构被分成了三级结构： Hash Table Header Page\n​\tHash Table Directory Page\n​\tHash Table Bucket Page\n也就是Task #2 - Extendible Hash Table Pages要实现的三个部分\n​\t而整个大结构都是在P1：buffer_pool的基础上的，为了实现磁盘支持，进行查找，删除，插入操作，必须借用buffer_pool_manager这一中介来进行操作，而这部分内容也就是我们的Task #3 - Extendible Hashing Implementation，也是整个P2的重中之重，难中之难！\n​\t回头来看，整个项目的最大难点我个人认为在支持并发多线程上，为达成此目的，2023 fall的版本，15445课程方要求我们先实现一个page_guard来管理buffer_pool中的page。为什么要强调版本2023 fall呢？因为对比2022 fall版本的B+ tree_index,我们会发现，在实现并发多线程时，需要大量的手动上锁解锁，FetchPage之后必须及时手动UnpinPage：\n​\t针对上述情况，2023 fall版本提出了一种优化方案，即：Task #1 - Read/Write Page Guards：\n任务 #1 - 读/写页面守卫 1 “FetchPage 和 NewPage 函数返回指向已固定页面的指针。固定机制可确保在页面上不再有读取和写入之前不会逐出页面。要指示内存中不再需要该页，程序员必须手动调用 UnpinPage。如果程序员忘记调用 UnpinPage，则永远不会将页面从缓冲池中逐出。由于缓冲池使用较少的帧数运行，因此将有更多的页面换入和换出磁盘。不仅性能受到影响，而且 bug 也很难被发现。您将实现 BasicPageGuard，它存储指向 BufferPoolManager 和 Page 对象的指针。Page Guard 确保在相应的 Page 对象超出范围时立即调用 UnpinPage。” ​\t所以可见，如果我们完成了Task #1 ，并在Task #3的实现中严格遵守并借助Task #1 中的三种不同类型的Page Guard：BasicPageGuard、ReadPageGuard和WritePageGuard，那么Task #4 - Concurrency Control的完成是水到渠成，不需要做额外工作的：\n1 “We recommend that you complete this task by using the FetchPageWrite or FetchPageRead buffer pool API, depending on whether you want to access a page with read or write privileges. Then modify your implementation to grab and release read and write latches as necessary to implement the latch crabbing algorithm.\u0026#34; 好，那么废话少说，我们直接进入Task #1 - Read/Write Page Guards：\n​\t在page.cpp文件里主要实现以下三个类的各种“类定义”函数，即构造函数，移动构造函数，移动操作符，赋值操作符等等，和c++课程当时的实验课要做的东西差不多，写起来也很轻松，具体思路如下，基本上都是官网以及头文件里提供的思路：\nBasicPageGuard BasicPageGuard是基础的页面保护器（page_guard)(很尬的直译\u0026hellip;），用于维护对BufferPoolManager和Page对象的指针。在其生命周期结束时，它会自动调用UnpinPage来解除页面的固定状态，确保页面可以在不再需要时被缓冲池驱逐。\n构造函数与移动操作符：实现了移动构造函数和移动赋值运算符，能够将其他BasicPageGuard对象的内容转移到当前实例，同时保证原实例的指针置空。 Drop()函数：用于解除页面的固定状态，调用UnpinPage方法，确保不会因忘记解除固定而导致页面一直滞留在缓冲池中。 UpgradeRead与UpgradeWrite：分别升级为ReadPageGuard或WritePageGuard，从而启用读写锁定保护，在多线程环境中确保读写的正确性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 这是一个基本的页面保护类，用于管理对页面的访问并确保在适当的时候释放资源。 BasicPageGuard::BasicPageGuard(BasicPageGuard \u0026amp;\u0026amp;that) noexcept {////////////////////////////////////////////////////////////////////// // 移动构造函数。它从另一个 BasicPageGuard 对象中接管资源 // 被用来访问缓冲池管理器的功能。在代码中，它被用来调用 BufferPoolManager 的方法 this-\u0026gt;bpm_ = that.bpm_; this-\u0026gt;page_ = that.page_; this-\u0026gt;is_dirty_ = that.is_dirty_; that.bpm_ = nullptr; that.page_ = nullptr; that.is_dirty_ = false; }////////////////////////////////////////////////////////////////////// // Drop 方法用于释放页面资源。它调用 UnpinPage 方法来解除对页面的驻留，并将资源设置为无效状态。 void BasicPageGuard::Drop() {////////////////////////////////////////////////////////////////////// if (bpm_ != nullptr) { bpm_-\u0026gt;UnpinPage(this-\u0026gt;PageId(), this-\u0026gt;is_dirty_); } this-\u0026gt;bpm_ = nullptr; this-\u0026gt;page_ = nullptr; this-\u0026gt;is_dirty_ = false; } ////////////////////////////////////////////////////////////////////// // 移动赋值运算符。它将当前对象的资源释放，并从另一个对象中接管资源。 auto BasicPageGuard::operator=(BasicPageGuard \u0026amp;\u0026amp;that) noexcept -\u0026gt; BasicPageGuard \u0026amp; //{ return *this; } { ////////////////////////////////////////////////////////////////////// this-\u0026gt;Drop(); this-\u0026gt;bpm_ = that.bpm_; this-\u0026gt;page_ = that.page_; this-\u0026gt;is_dirty_ = that.is_dirty_; that.bpm_ = nullptr; that.page_ = nullptr; that.is_dirty_ = false; return *this; } ////////////////////////////////////////////////////////////////////// // 析构函数调用 Drop 方法来确保在对象销毁时释放资源。 BasicPageGuard::~BasicPageGuard()//{}; // NOLINT { ////////////////////////////////////////////////////////////////////// this-\u0026gt;Drop(); }////////////////////////////////////////////////////////////////////// ReadPageGuard ReadPageGuard专门用于处理页面的读操作，并在生命周期结束时自动解锁页面的读锁（RUnlatch）。\n移动构造函数与赋值操作符：允许从其他ReadPageGuard对象中转移内容，并确保源对象的状态被重置。 Drop()函数：自动解除页面的读锁，确保在ReadPageGuard对象销毁时释放读锁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 移动构造函数，用于从另一个 ReadPageGuard 对象中接管资源。 // 可能是一个 BasicPageGuard 类型的对象。 ReadPageGuard::ReadPageGuard(ReadPageGuard \u0026amp;\u0026amp;that) //noexcept = default; noexcept { this-\u0026gt;guard_ = std::move(that.guard_); } ////////////////////////////////////////////////////////////////////// // 移动赋值运算符，用于从另一个对象中接管资源 auto ReadPageGuard::operator=(ReadPageGuard \u0026amp;\u0026amp;that) noexcept -\u0026gt; ReadPageGuard \u0026amp;// { return *this; } { ////////////////////////////////////////////////////////////////////// this-\u0026gt;Drop(); this-\u0026gt;guard_ = std::move(that.guard_); return *this; } ////////////////////////////////////////////////////////////////////// // Drop 方法用于释放页面资源，并解除对页面的只读锁定。 void ReadPageGuard::Drop() //{} { ////////////////////////////////////////////////////////////////////// auto \u0026amp;guard = this-\u0026gt;guard_; if (guard.page_ != nullptr) { guard.bpm_-\u0026gt;UnpinPage(guard.PageId(), guard.is_dirty_); guard.page_-\u0026gt;RUnlatch(); } guard.page_ = nullptr; guard.bpm_ = nullptr; guard.is_dirty_ = false; } ////////////////////////////////////////////////////////////////////// // 析构函数调用 Drop 方法来确保在对象销毁时释放资源。 ReadPageGuard::~ReadPageGuard() //{} // NOLINT { ////////////////////////////////////////////////////////////////////// this-\u0026gt;Drop(); } ////////////////////////////////////////////////////////////////////// WritePageGuard WritePageGuard用于页面的写操作，具有自动管理写锁的功能。在销毁时调用Drop来解除写锁，同时将页面标记为已修改（is_dirty_设为true）。\n移动构造函数与赋值操作符：允许从其他WritePageGuard对象转移内容。 Drop()函数：在生命周期结束时自动解除页面的写锁，并设置脏标志。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 移动构造函数，用于从另一个 WritePageGuard 对象中接管资源。 WritePageGuard::WritePageGuard(WritePageGuard \u0026amp;\u0026amp;that)noexcept //noexcept = default; { this-\u0026gt;guard_ = std::move(that.guard_); }; ////////////////////////////////////////////////////////////////////// // 移动赋值运算符，用于从另一个对象中接管资源。 auto WritePageGuard::operator=(WritePageGuard \u0026amp;\u0026amp;that) noexcept -\u0026gt; WritePageGuard \u0026amp;// { return *this; } { ////////////////////////////////////////////////////////////////////// this-\u0026gt;Drop(); this-\u0026gt;guard_ = std::move(that.guard_); return *this; } ////////////////////////////////////////////////////////////////////// // Drop 方法用于释放页面资源，并解除对页面的写入锁定 void WritePageGuard::Drop() { ////////////////////////////////////////////////////////////////////// auto \u0026amp;guard = this-\u0026gt;guard_; if (guard.page_ != nullptr) { guard.bpm_-\u0026gt;UnpinPage(guard.PageId(), guard.is_dirty_); guard.page_-\u0026gt;WUnlatch(); } guard.page_ = nullptr; guard.bpm_ = nullptr; guard.is_dirty_ = false; } ////////////////////////////////////////////////////////////////////// // 析构函数调用 Drop 方法来确保在对象销毁时释放资源。 WritePageGuard::~WritePageGuard() { ////////////////////////////////////////////////////////////////////// this-\u0026gt;Drop(); } // NOLINT ////////////////////////////////////////////////////////////////////// 缓冲池管理器\n(这里得提一下，对页面的读写是通过先获取页面的信息，在对这个信息进行读写，因此读写操作需要对Fetch进行加锁) 新增的FetchPageBasic、FetchPageRead和FetchPageWrite函数，分别返回BasicPageGuard、ReadPageGuard和WritePageGuard，以简化页面的读写锁定管理：\nFetchPageBasic：提供基础的页面获取保护，不涉及锁定操作。 FetchPageRead与FetchPageWrite：分别在返回的页面上加读锁和写锁，保证在多线程环境中页面的读写操作安全。 NewPageGuarded：创建并返回一个新页面的BasicPageGuard。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 获取页面的保护版本 auto BufferPoolManager::FetchPageBasic(page_id_t page_id) -\u0026gt; BasicPageGuard //{ return {this, nullptr}; } {//===----------------------------------------------------------------------===// // 获取页面的基本保护版本。 auto pg_ptr = FetchPage(page_id); return {this, pg_ptr}; }//===----------------------------------------------------------------------===// auto BufferPoolManager::FetchPageRead(page_id_t page_id) -\u0026gt; ReadPageGuard //{ return {this, nullptr}; } {//===----------------------------------------------------------------------===// // 获取页面的读保护版本。 auto pg_ptr = FetchPage(page_id); pg_ptr-\u0026gt;RLatch(); assert(pg_ptr != nullptr); return {this, pg_ptr}; }//===----------------------------------------------------------------------===// auto BufferPoolManager::FetchPageWrite(page_id_t page_id) -\u0026gt; WritePageGuard //{ return {this, nullptr}; } {//===----------------------------------------------------------------------===// // 获取页面的写保护版本。 auto pg_ptr = FetchPage(page_id); pg_ptr-\u0026gt;WLatch(); assert(pg_ptr != nullptr); return {this, pg_ptr}; }//===----------------------------------------------------------------------===// auto BufferPoolManager::NewPageGuarded(page_id_t *page_id) -\u0026gt; BasicPageGuard //{ return {this, nullptr}; } {//===----------------------------------------------------------------------===// // 调用 NewPage：创建新页面。 // 返回保护版本：返回带有保护的页面。 auto pg_ptr = NewPage(page_id); assert(pg_ptr != nullptr); return {this, pg_ptr}; }//===----------------------------------------------------------------------===// 值得注意的是：\n​\t1.WritePageGuard::Drop() 和 ReadPageGuard::Drop() 函数里要进行解锁操作，这一点和FetchPageRead/Write 里面的上锁操作刚好对应。后面在Task#3中进行插入删除查找等操作时，由于是索引结构是三级可拓展的，就需要我们谨慎小心的层层剥笋式的先从Hash Table Header Page经由 Hash Table Directory Page最后到达Hash Table Bucket Page ，再进行各种操作。而这整个过程，都得保证线程安全，那么就全依赖于task1实现的基础。\n​\tTask#1难度不大，仔细研读page.h以及page_guard.h的话会很好实现。\n​\t2.前面写代码一定要谨慎小心，每一个函数都要写仔细，包括P1如果有瑕疵，也要及时更改完善，不然攒到最后写完P2在线提交的时候，一下子涉及二十几个文件，DEBUG难度十分之大，坐牢感十分之强！\n任务 #2 - 可扩展哈希表页面 一、整体思路： ​\t本节主要是要实现三级可拓展哈希的每一层结构（如下图）。代码难度不大，主要是得理解一个操作实现的时候，依次在三层结构中的历程，以及“拆分”“扩展”时哈希结构的动态变化。例如在执行插入操作时，第一级是header采用hash值的高位决定将key-value插入到哪个directory，第二级是dierctory，第二级采用hash值的低位决定将key-value插入到哪个bucket，最后找到bucket后将key-value键值对插入。\n​\t这里先说明以下，header和directory的maxdepth以及bucket的size是提前人为设置的，不是动态变化的（bucke的大小是固定的，不是2^local），这里注意一下，local只代表bucket中的key的后几位中，有几位是相同的。2^(global-local)为每个桶的最大被directory指向的数量。\n二、Hash Table Header Page 这部分整体很简单，大家细心按.h文件注释完成即可\n这里提供一种HashToDirectoryIndex（）函数的实现：\n​\t注：这里的idx为索引，代表着从头到目录对应数组下的索引；而id是页面id，是唯一的。\n​\t然后这里使用的是directory_page_ids_数组，通过索引获得对应的页面id。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 void ExtendibleHTableHeaderPage::Init(uint32_t max_depth) {// 初始化标题页面。 //throw NotImplementedException(\u0026#34;ExtendibleHTableHeaderPage is not implemented\u0026#34;); //===----------------------------------------------------------------------===// this-\u0026gt;max_depth_ = max_depth;// 表示标题页可以处理的最大深度。 uint32_t len = MaxSize();// 计算最大目录项数 len，通过调用 MaxSize() 方法。 for (uint32_t i = 0; i \u0026lt; len; i++) {// 遍历 directory_page_ids_ 数组，将每个元素初始化为 INVALID_PAGE_ID，表示初始时没有目录页面。 directory_page_ids_[i] = INVALID_PAGE_ID; //===----------------------------------------------------------------------===// } } // 计算哈希到目录索引 auto ExtendibleHTableHeaderPage::HashToDirectoryIndex(uint32_t hash) const -\u0026gt; uint32_t// { return 0; } {//===----------------------------------------------------------------------===// if (max_depth_ == 0) { return 0; } // 通过右移操作将哈希值的高位部分提取出来，作为目录索引。 // 这利用了位运算的特性，将哈希值的前 max_depth_ 位作为索引。 return hash \u0026gt;\u0026gt; (32 - max_depth_); }//===----------------------------------------------------------------------===// // 获取目录页面 ID auto ExtendibleHTableHeaderPage::GetDirectoryPageId(uint32_t directory_idx) const -\u0026gt; uint32_t //{ return 0; } {//===----------------------------------------------------------------------===// assert(directory_idx \u0026lt; MaxSize());// 使用 assert 确保目录索引在有效范围内。 return directory_page_ids_[directory_idx];// 返回 directory_page_ids_ 数组中对应索引的值。 }//===----------------------------------------------------------------------===// // 设置目录页面 ID void ExtendibleHTableHeaderPage::SetDirectoryPageId(uint32_t directory_idx, page_id_t directory_page_id) { //throw NotImplementedException(\u0026#34;ExtendibleHTableHeaderPage is not implemented\u0026#34;); //===----------------------------------------------------------------------===// assert(directory_idx \u0026lt; MaxSize()); directory_page_ids_[directory_idx] = directory_page_id;// 设置 directory_page_ids_ 数组中对应索引的值为传入的 directory_page_id }//===----------------------------------------------------------------------===// // 计算最大目录项数 auto ExtendibleHTableHeaderPage::MaxSize() const -\u0026gt; uint32_t //{ return 0; } //===----------------------------------------------------------------------===// //通过位运算 1 \u0026lt;\u0026lt; max_depth_ 计算最大目录项数。这相当于计算 2 的 max_depth_ 次方。 { return (1 \u0026lt;\u0026lt; max_depth_); } } // namespace bustub 三、Hash Table Directory Page ​\t这里使用了local_depths数组，bucket_page_ids数组，Global Depth和Local Depth这四个，具体意思参考上面的头部和以下内容：\n这一部分的重点在于一定要理解Global Depth和Local Depth\n1.global_mask 是干啥的？ 答：用于记录当前global_depth的整体特征值。\n公式：(1 \u0026lt;\u0026lt; global_depth) - 1; 举个例子：101和111的global_mask都是111，即它俩对应的depth都是3。 所以当我们拥有一个hash_key的时候，直接hash_key\u0026amp;global_mask就能帮我们得到他在dirctory_page中的index，这里也可以看出global_mask是干啥的。\n2.local_mask 是干啥的？ 答：与global_mask类似，只不过是在局部桶中记录深度的掩码。 3.扩容过程： 假设现在有索引结构如下：\n现在要插入1011，就需要 IncrGlobalDepth()：\n现在我们来好好解析上面这张图：\nglobal_depth从1拓展到2的过程，拓展出来的entry的指向就是直接复制一份原来的指针（上图的蓝色箭头复制绿色箭头），因为Directory Pages是靠hash值的低位索引的，试想我们每次拓展 ：1+1，2+2，4+4 \u0026hellip; 拓展出来的这部分正好是原来entry的对等实体，这里真的好巧妙啊！！！！！\n再继续看：\nlocal_depth为1的含义就是，该桶中的最低一位都相等。且记得local_depth永远不能大于global_depth\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 // 初始化目录页面。 void ExtendibleHTableDirectoryPage::Init(uint32_t max_depth) {// max_depth 表示目录页面可以处理的最大深度。 //throw NotImplementedException(\u0026#34;ExtendibleHTableDirectoryPage is not implemented\u0026#34;); max_depth_ = max_depth; global_depth_ = 0; for (uint32_t i = 0; i \u0026lt; MaxSize(); ++i) { bucket_page_ids_[i] = INVALID_PAGE_ID;// 始时没有存储桶页面。 } } // 计算哈希到存储桶索引 auto ExtendibleHTableDirectoryPage::HashToBucketIndex(uint32_t hash) const -\u0026gt; uint32_t// { return 0; } { return hash \u0026amp; ((1 \u0026lt;\u0026lt; global_depth_) - 1); //使用按位与操作提取哈希值的最低 global_depth_ 位作为存储桶索引 } ////////////////////////////////////////////////////////// // 获取最大深度 auto ExtendibleHTableDirectoryPage::GetMaxDepth() const -\u0026gt; uint32_t { return max_depth_; } //////////////////////////////////////////////////// //获取存储桶页面 ID auto ExtendibleHTableDirectoryPage::GetBucketPageId(uint32_t bucket_idx) const -\u0026gt; page_id_t// { return INVALID_PAGE_ID; } { assert(bucket_idx \u0026lt; pow(2, max_depth_)); //判断下标有没有超限值 return bucket_page_ids_[bucket_idx];// 返回 bucket_page_ids_ 数组中对应索引的值 } // 设置存储桶页面 ID void ExtendibleHTableDirectoryPage::SetBucketPageId(uint32_t bucket_idx, page_id_t bucket_page_id) { //throw NotImplementedException(\u0026#34;ExtendibleHTableDirectoryPage is not implemented\u0026#34;); assert(bucket_idx \u0026lt; pow(2, max_depth_)); bucket_page_ids_[bucket_idx] = bucket_page_id;// 设置 bucket_page_ids_ 数组中对应索引的值为传入的 bucket_page_id。 } //分裂桶，这里是为了获得一个桶对应的另一个桶的索引（eg：00和10是一对，通过这个函数，这俩个可以互相获得） // 获取分裂图像索引 auto ExtendibleHTableDirectoryPage::GetSplitImageIndex(uint32_t bucket_idx) const -\u0026gt; uint32_t// { return 0; } { auto local_depth_mask = GetLocalDepthMask(bucket_idx); // 11 auto local_depth = GetLocalDepth(bucket_idx); //假设为2 return (bucket_idx \u0026amp; local_depth_mask) ^ (1 \u0026lt;\u0026lt; (local_depth - 1)); // 10-\u0026gt;00 01-\u0026gt;11 11-\u0026gt;01 00-\u0026gt;10 } // 获取全局深度 auto ExtendibleHTableDirectoryPage::GetGlobalDepth() const -\u0026gt; uint32_t// { return 0; } { assert(global_depth_ \u0026lt;= max_depth_);// 使用 assert 确保全局深度不超过最大深度。 return global_depth_;// 返回 global_depth_ } //////////////////////////////////////////////////// // 获取全局深度掩码(这个函数没有用到) auto ExtendibleHTableDirectoryPage::GetGlobalDepthMask() const -\u0026gt; uint32_t { auto global_depth = GetGlobalDepth(); return (1 \u0026lt;\u0026lt; global_depth) - 1;// 计算 1 \u0026lt;\u0026lt; global_depth，然后减去 1，得到掩码。 } //////////////////////////////////////////////////// // 增加全局深度 void ExtendibleHTableDirectoryPage::IncrGlobalDepth() { //throw NotImplementedException(\u0026#34;ExtendibleHTableDirectoryPage is not implemented\u0026#34;); assert(global_depth_ \u0026lt;= max_depth_);// 使用 assert 确保全局深度不超过最大深度。 if (global_depth_ == max_depth_) {// 如果当前全局深度已经达到最大深度，直接返回。 return; } // 增加目录的全局深度，也就是目前所有桶中的最大深度 // 计算增加深度前后的目录大小。 uint32_t pre_size = Size(); global_depth_++; uint32_t curr_size = Size(); //增加以为要乘以2就是翻一倍 //官网这么指示，要把其扩展后的初始化为相应位置，不清楚为什么这样初始化 //是因为对应位置最后xx位是一样的所以可以先这样初始化？？？ // 将新扩展的部分初始化为对应位置的值。 for (uint32_t i = pre_size; i \u0026lt; curr_size; ++i) { bucket_page_ids_[i] = bucket_page_ids_[i - pre_size]; local_depths_[i] = local_depths_[i - pre_size]; } } // 减少全局深度 void ExtendibleHTableDirectoryPage::DecrGlobalDepth() { //throw NotImplementedException(\u0026#34;ExtendibleHTableDirectoryPage is not implemented\u0026#34;); if (global_depth_ \u0026gt; 0) {// 如果当前全局深度大于 0，减少 1 global_depth_--; } } // 检查是否可以收缩 auto ExtendibleHTableDirectoryPage::CanShrink() -\u0026gt; bool //{ return false; } { if (global_depth_ == 0) {// 如果全局深度为 0，直接返回 false。 return false; } // 遍历所有存储桶，检查是否有存储桶的局部深度等于全局深度。如果有，返回 false。 uint32_t len = Size(); for (uint32_t i = 0; i \u0026lt; len; i++) { if (local_depths_[i] == global_depth_) { return false; } } // 如果所有存储桶的局部深度都小于全局深度，返回 true。 return true; } // 获取目录大小 auto ExtendibleHTableDirectoryPage::Size() const -\u0026gt; uint32_t //{ return 0; } { // 计算 2^global_depth_，并转换为 uint32_t 类型 auto size_float = pow(2, global_depth_); auto size = static_cast\u0026lt;uint32_t\u0026gt;(size_float); return size; } //////////////////////////////////////////////////// // 获取最大目录大小 auto ExtendibleHTableDirectoryPage::MaxSize() const -\u0026gt; uint32_t { // 计算 2^max_depth_，并转换为 uint32_t 类型。 double tmp = pow(2, max_depth_); auto max_size = static_cast\u0026lt;uint32_t\u0026gt;(tmp); return max_size; } //////////////////////////////////////////////////// // 获取局部深度(获取指定存储桶索引对应的局部深度。) auto ExtendibleHTableDirectoryPage::GetLocalDepth(uint32_t bucket_idx) const -\u0026gt; uint32_t //{ return 0; } { return local_depths_[bucket_idx];// 返回 local_depths_ 数组中对应索引的值。 } //////////////////////////////////////////////////// // 获取局部深度掩码（掩码就是获取二进制的前local_depth位） auto ExtendibleHTableDirectoryPage::GetLocalDepthMask(uint32_t bucket_idx) const -\u0026gt; uint32_t { auto local_depth = GetLocalDepth(bucket_idx); return (1 \u0026lt;\u0026lt; local_depth) - 1;// 计算 1 \u0026lt;\u0026lt; local_depth，然后减去 1，得到掩码。 } //////////////////////////////////////////////////// // 设置局部深度 void ExtendibleHTableDirectoryPage::SetLocalDepth(uint32_t bucket_idx, uint8_t local_depth) { //throw NotImplementedException(\u0026#34;ExtendibleHTableDirectoryPage is not implemented\u0026#34;); assert(bucket_idx \u0026lt; pow(2, max_depth_)); local_depths_[bucket_idx] = local_depth;// 设置 local_depths_ 数组中对应索引的值为传入的 local_depth。 } // 增加局部深度 void ExtendibleHTableDirectoryPage::IncrLocalDepth(uint32_t bucket_idx) { // throw NotImplementedException(\u0026#34;ExtendibleHTableDirectoryPage is not implemented\u0026#34;); local_depths_[bucket_idx] += 1; //直接增加 local_depths_ 数组中对应索引的值。 } // 减少局部深度 void ExtendibleHTableDirectoryPage::DecrLocalDepth(uint32_t bucket_idx) { //throw NotImplementedException(\u0026#34;ExtendibleHTableDirectoryPage is not implemented\u0026#34;); if (local_depths_[bucket_idx] \u0026gt; 0) {// 如果当前局部深度大于 0，减少 1。 local_depths_[bucket_idx]--; } } 四、Hash Table Bucket Page 这部分的任务就很轻松了，桶中\u0026lt;key,value\u0026gt;的存储结构用的是数组，且已经给好了比较工具 cmp_，所以大量进行遍历，一个个按注释完成相应函数要求即可，不再做过多赘述。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 // 初始化存储桶页面。 void ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;::Init(uint32_t max_size) { //throw NotImplementedException(\u0026#34;ExtendibleHTableBucketPage not implemented\u0026#34;); this-\u0026gt;max_size_ = max_size;// 存储桶页面可以存储的最大键值对数量。 this-\u0026gt;size_ = 0;// 初始化 size_ 为 0，表示当前存储桶页面中没有键值对。 } // 查找键值对 template \u0026lt;typename K, typename V, typename KC\u0026gt; auto ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;::Lookup(const K \u0026amp;key, V \u0026amp;value, const KC \u0026amp;cmp) const -\u0026gt; bool { //return false; for (uint32_t i = 0; i \u0026lt; size_; ++i) {// 遍历存储桶页面中的键值对数组 array_ if (cmp(array_[i].first, key) == 0) {// 使用比较器 cmp 比较每个键与目标键。 value = array_[i].second;// 如果找到匹配的键，将对应的值存储在 value 中并返回 true。 return true; } } return false; } // 插入键值对 template \u0026lt;typename K, typename V, typename KC\u0026gt; auto ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;::Insert(const K \u0026amp;key, const V \u0026amp;value, const KC \u0026amp;cmp) -\u0026gt; bool { //return false; if (size_ == max_size_) {// 检查存储桶页面是否已满，如果已满，返回 false。 return false; } for (uint32_t i = 0; i \u0026lt; size_; ++i) {// 遍历存储桶页面中的键值对数组 array_，检查是否已存在相同的键。 if (cmp(array_[i].first, key) == 0) {// 如果存在相同的键，返回 false。 return false; } } // 如果不存在相同的键，将键值对插入到数组的末尾，并增加 size_。 array_[size_].first = key; array_[size_].second = value; size_++; return true; } // 删除键值对 template \u0026lt;typename K, typename V, typename KC\u0026gt; auto ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;::Remove(const K \u0026amp;key, const KC \u0026amp;cmp) -\u0026gt; bool { //return false; //遍历存储桶页面中的键值对数组 array_，找到要删除的键的位置。 uint32_t i = 0; for (; i \u0026lt; size_; ++i) { if (cmp(array_[i].first, key) == 0) { break; } } // 如果找到匹配的键，将该位置之后的键值对向前移动，覆盖该位置。 if (i == size_) { return false; } for (uint32_t j = i + 1; j \u0026lt; size_; ++j) { array_[j - 1].first = array_[j].first; array_[j - 1].second = array_[j].second; } // 减少 size_ 并返回 true。 size_--; return true; } // 按索引删除键值对 template \u0026lt;typename K, typename V, typename KC\u0026gt; void ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;::RemoveAt(uint32_t bucket_idx) { //throw NotImplementedException(\u0026#34;ExtendibleHTableBucketPage not implemented\u0026#34;); if (bucket_idx \u0026gt;= size_) {// 检查索引是否有效。 return; } // 将该索引之后的键值对向前移动，覆盖该索引位置。 for (uint32_t i = bucket_idx + 1; i \u0026lt; size_; ++i) { array_[i - 1].first = array_[i].first; array_[i - 1].second = array_[i].second; } size_--; } // 获取指定索引的键 template \u0026lt;typename K, typename V, typename KC\u0026gt; auto ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;::KeyAt(uint32_t bucket_idx) const -\u0026gt; K { //return {}; return array_[bucket_idx].first;// 直接返回 array_ 中对应索引的键。 } // 获取指定索引的值 template \u0026lt;typename K, typename V, typename KC\u0026gt; auto ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;::ValueAt(uint32_t bucket_idx) const -\u0026gt; V { //return {}; return array_[bucket_idx].second;// 直接返回 array_ 中对应索引的值。 } // 获取指定索引的键值对 template \u0026lt;typename K, typename V, typename KC\u0026gt; auto ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;::EntryAt(uint32_t bucket_idx) const -\u0026gt; const std::pair\u0026lt;K, V\u0026gt; \u0026amp; { //return array_[0]; return array_[bucket_idx];// 直接返回 array_ 中对应索引的键值对。 } // 获取存储桶大小 template \u0026lt;typename K, typename V, typename KC\u0026gt; auto ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;::Size() const -\u0026gt; uint32_t { //return 0; return size_;// 返回 size_ } // 检查存储桶是否已满 template \u0026lt;typename K, typename V, typename KC\u0026gt; auto ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;::IsFull() const -\u0026gt; bool { //return false; return size_ == max_size_; } // 检查存储桶是否为空 template \u0026lt;typename K, typename V, typename KC\u0026gt; auto ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;::IsEmpty() const -\u0026gt; bool { //return false; return size_ == 0; } 任务 #3 - 可扩展哈希实现 一、整体思路：\n思路捋一下：\n​\t首先一个header会指向多个目录，一个目录会指向多个桶\n​\theader通过key的前几位映射到目录，目录通过后几位的key映射到桶\n​\t要实现的插入和移除都应该逐步hash到目标桶\n​\tTASK#3是整个P2的重点和难点，要求我们利用Task#1 实现的page_guard和Task#2实现的三级hash_page来实现最终的可拓展哈希结构，且支持Task#4 并发控制的要求。\n​\t这部分内容过于复杂，我也是参考了众多其他博客的思路来实现的，大致上大家可以参考以下这篇博客里的流程图思路，我就不再重复造轮子了： [CMU15-445 2023 Fall Project#2 - Extensible Hash Index - 知乎](https://zhuanlan.zhihu.com/p/679864158#2 - Extensible Hash Index）)\n二、常用思路和技巧： 上面引用的博客对于细节的描述较少，我在此补充几点：\n1.如何善用page_guard类： 如何善用page_guard类来便利的实现我们的增删查操作并且保证多线程安全？\nTask#3的第一大难点个人感觉就在这里，因为比如拿 GetValue() 举例，最终的查找操作其实就下面这么一两句：即在第三层bucket_page进行查找。但如何在三层可拓展哈希结构和多线程安全的重重要求下层层剥笋的进入第三层bucket_page？具体思路和做法如下（还是以 GetValue()举例）：\n2.Insert时的SplitBucket情况： 当一个桶内的元素数目达到上限时（桶满），就需要分裂桶。分裂的目的是将现有桶中的元素分配到两个新的桶中，从而减少单个桶的负载，保持哈希表的性能。\n这里有一点要记住，原桶会分裂成俩个桶，原桶为0xxx，分裂桶为1xxx，且只有与这俩个桶相关的数据和索引会发生变化（即重新分配），其它桶不会变化。\n3.Romove时的merge情况： Romove操作时，如果当前bucket的local depth不为0，且大于0，对应的Split_Bucket的local depth相同，并且两个bucket其中有一个为空即需要合并桶。\n这里值得一提的是，在计算待合并桶的索引（第三步）以及最后（倒数第二步）计算局部深度和桶索引时都涉及到对掩码的位运算，这里提供以下思路参考：\n3.1 计算待合并桶 merge_bucket_idx：\n先取当前局部深度的二进制位表示，比如局部深度为3，则merge_mask : 0100,\n再与当前桶的idx进行异或，即可得到 merge_bucket_idx。\n3.2 更新目录索引时，计算每个桶的唯一idx：\n这里如果看懂了上一篇博客里对于local_mask作用的讲解的话会很清晰：“\u0026amp;操作得到独特位”\n4.及时释放空间： （这一点我在做之前看别人的经验直接避坑了，所以并没有亲身体会）\n在Insert 和 Romove的过程中，已经使用过的page_guard可以提前手动Drop () 掉，别等析构的时候自动清除，二.1的流程图中也已经包含：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 DiskExtendibleHashTable\u0026lt;K, V, KC\u0026gt;::DiskExtendibleHashTable(const std::string \u0026amp;name, BufferPoolManager *bpm,// 哈希表的名称。 const KC \u0026amp;cmp, const HashFunction\u0026lt;K\u0026gt; \u0026amp;hash_fn, uint32_t header_max_depth, uint32_t directory_max_depth, uint32_t bucket_max_size) : bpm_(bpm),// 缓冲池管理器，用于管理页面的分配和释放。 cmp_(cmp), hash_fn_(std::move(hash_fn)),// 哈希函数，用于计算键的哈希值 header_max_depth_(header_max_depth), directory_max_depth_(directory_max_depth), bucket_max_size_(bucket_max_size) { //***************************************************************************** // throw NotImplementedException(\u0026#34;DiskExtendibleHashTable is not implemented\u0026#34;); index_name_ = name; // Create a new header page page_id_t page_id; // 通过缓冲池管理器创建一个新的页面，并获取其保护版本 auto tmp_header_guard = bpm_-\u0026gt;NewPageGuarded(\u0026amp;page_id); // 升级为 WritePageGuard，以获得对页面的写权限。 auto header_guard = tmp_header_guard.UpgradeWrite(); // 将页面转换为 ExtendibleHTableHeaderPage 类型，以便进行类型安全的操作。 auto header_page = header_guard.AsMut\u0026lt;ExtendibleHTableHeaderPage\u0026gt;(); // 调用标题页面的 Init 方法，初始化标题页面的最大深度。 header_page-\u0026gt;Init(header_max_depth); // 将新创建的标题页面的 ID 存储在成员变量中，以便后续访问。 header_page_id_ = page_id; //***************************************************************************** } /***************************************************************************** * SEARCH *****************************************************************************/ // 查找键值对 // GetValue 方法的主要功能是根据给定的键 key，在可扩展哈希表中查找对应的值，并将结果存储在 result 参数中。 // 如果找到键值对，返回 true；否则返回 false。 template \u0026lt;typename K, typename V, typename KC\u0026gt; auto DiskExtendibleHashTable\u0026lt;K, V, KC\u0026gt;::GetValue(const K \u0026amp;key, std::vector\u0026lt;V\u0026gt; *result, Transaction *transaction) const -\u0026gt; bool { // return false; //***************************************************************************** // 获取标题页面的读保护,确保了在读取标题页面时，页面不会被修改。 auto header_guard = bpm_-\u0026gt;FetchPageRead(header_page_id_); // 将获取到的页面转换为 ExtendibleHTableHeaderPage 类型，以便进行类型安全的操作。 auto header_page = header_guard.As\u0026lt;ExtendibleHTableHeaderPage\u0026gt;(); uint32_t hash = Hash(key);// 使用哈希函数计算键的哈希值。 // 哈希值计算目录页面的索引。这个索引用于在标题页面中找到对应的目录页面。 auto directory_index = header_page-\u0026gt;HashToDirectoryIndex(hash); // 标题页面的 GetDirectoryPageId 方法，获取目录页面的 ID。 page_id_t directory_page_id = header_page-\u0026gt;GetDirectoryPageId(directory_index); // 录页面 ID 无效（即等于 INVALID_PAGE_ID），返回 false，表示查找失败。 if (static_cast\u0026lt;int\u0026gt;(directory_page_id) == INVALID_PAGE_ID) { return false; } // 缓冲池管理器的 FetchPageRead 方法获取目录页面的读保护。 ReadPageGuard directory_guard = bpm_-\u0026gt;FetchPageRead(directory_page_id); // 获取到的页面转换为 ExtendibleHTableDirectoryPage 类型，以便进行类型安全的操作。 auto directory_page = directory_guard.As\u0026lt;ExtendibleHTableDirectoryPage\u0026gt;(); // 调用目录页面的 HashToBucketIndex 方法，根据哈希值计算存储桶页面的索引。 // 这个索引用于在目录页面中找到对应的存储桶页面。 auto bucket_index = directory_page-\u0026gt;HashToBucketIndex(hash); // 调用目录页面的 GetBucketPageId 方法，获取存储桶页面的 ID page_id_t bucket_page_id = directory_page-\u0026gt;GetBucketPageId(bucket_index); // 如果存储桶页面 ID 无效（即等于 INVALID_PAGE_ID），返回 false，表示查找失败。 if (static_cast\u0026lt;int\u0026gt;(bucket_page_id) == INVALID_PAGE_ID) { return false; } // 使用缓冲池管理器的 FetchPageRead 方法获取存储桶页面的读保护。 ReadPageGuard bucket_guard = bpm_-\u0026gt;FetchPageRead(bucket_page_id); // 获取到的页面转换为 ExtendibleHTableBucketPage 类型，以便进行类型安全的操作。 auto bucket_page = bucket_guard.As\u0026lt;ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;\u0026gt;(); V value;// 声明一个值变量，用于存储查找结果 // 调用存储桶页面的 Lookup 方法，在存储桶页面中查找键值对。如果找到，value 将被设置为对应的值。 bool lookup_success = bucket_page-\u0026gt;Lookup(key, value, cmp_); if (!lookup_success) { return false; } result-\u0026gt;push_back(value); return true; //***************************************************************************** } /***************************************************************************** * INSERTION 先找header_page，判断目录页面 ID是否有效，没有，则InsertToNewDirectory 方法创建新的目录页面并插入键值对，然后释放 找directory_page，判断存储桶页面 ID是否有效，没有，则 InsertToNewBucket 方法创建新的存储桶页面并插入键值对 到处理存储桶时，有重复则返回false；桶没满，则插入成功； 桶满时： 如果local\u0026lt;Global: 则通过缓冲池管理器创建新的存储桶页面，然后local++；再把旧桶里的数据重新分配到新桶里，再把旧桶中被分配出来的数据删掉。如果新桶也满了，则进行循环。 如果local=Global: 如果Global=maxdepth: 则返回失败。 如果Global\u0026lt;maxdepth: 则Global++(新增的部分的内容为原部分的复制),然后再按local\u0026lt;Global的状况处理。 *****************************************************************************/ // 将键值对插入到可扩展哈希表中。如果键已存在，返回 false；如果插入成功，返回 true。如果存储桶满，则需要进行分裂操作。 template \u0026lt;typename K, typename V, typename KC\u0026gt; auto DiskExtendibleHashTable\u0026lt;K, V, KC\u0026gt;::Insert(const K \u0026amp;key, const V \u0026amp;value, Transaction *transaction) -\u0026gt; bool { //return false; //***************************************************************************** //要插入元素先一步一步映射到桶 // 缓冲池管理器的 FetchPageWrite 方法获取标题页面的写保护。这确保了在写入标题页面时，页面不会被其他操作修改。 auto header_guard = bpm_-\u0026gt;FetchPageWrite(header_page_id_); auto header_page = header_guard.AsMut\u0026lt;ExtendibleHTableHeaderPage\u0026gt;(); uint32_t hash = Hash(key); uint32_t directory_index = header_page-\u0026gt;HashToDirectoryIndex(hash); auto directory_page_id = header_page-\u0026gt;GetDirectoryPageId(directory_index); // 如果目录页面 ID 无效（即等于 INVALID_PAGE_ID），调用 InsertToNewDirectory 方法创建新的目录页面并插入键值对。 if (static_cast\u0026lt;int\u0026gt;(directory_page_id) == INVALID_PAGE_ID) { auto insert_success = InsertToNewDirectory(header_page, directory_index, hash, key, value); return insert_success; } // 释放标题页面的写保护，因为后续操作不需要再修改标题页面。 header_guard.Drop(); // 获取目录页面的写保护： WritePageGuard directory_guard = bpm_-\u0026gt;FetchPageWrite(directory_page_id); auto directory_page = directory_guard.AsMut\u0026lt;ExtendibleHTableDirectoryPage\u0026gt;(); auto bucket_index = directory_page-\u0026gt;HashToBucketIndex(hash); auto bucket_page_id = directory_page-\u0026gt;GetBucketPageId(bucket_index); // 如果存储桶页面 ID 无效（即等于 INVALID_PAGE_ID），调用 InsertToNewBucket 方法创建新的存储桶页面并插入键值对。 if (static_cast\u0026lt;int\u0026gt;(bucket_page_id) == INVALID_PAGE_ID) { //要显示转换类型，使其等号左右两边相等 auto insert_success = InsertToNewBucket(directory_page, bucket_index, key, value); return insert_success; } // Check whether the bucket is full or not. bool insert_success = false;// 声明一个布尔变量，用于标记插入操作是否成功。 // 使用缓冲池管理器的 FetchPageWrite 方法获取存储桶页面的写保护。 WritePageGuard bucket_guard = bpm_-\u0026gt;FetchPageWrite(bucket_page_id); auto bucket_page = bucket_guard.AsMut\u0026lt;ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;\u0026gt;(); V tmp_val;// 声明一个临时值变量，用于存储查找结果。 //如果已存在该键值则不需要插入直接返回false if (bucket_page-\u0026gt;Lookup(key, tmp_val, cmp_)) { return false; } // 如果存储桶未满，直接插入键值对并返回结果。 if (!bucket_page-\u0026gt;IsFull()) { insert_success = bucket_page-\u0026gt;Insert(key, value, cmp_); return insert_success; } //桶满了，那么扩展那个桶的局部深度，然后分裂桶，然后将值重新hash，要不停的循环可能分裂后桶在hash后依旧会满 while (!insert_success \u0026amp;\u0026amp; bucket_page-\u0026gt;IsFull()) { if (directory_page-\u0026gt;GetGlobalDepth() == directory_page-\u0026gt;GetLocalDepth(bucket_index)) { if (directory_page-\u0026gt;GetGlobalDepth() == directory_page-\u0026gt;GetMaxDepth()) { return false; } // directory growing directory_page-\u0026gt;IncrGlobalDepth(); } //要分裂桶需要通过缓冲区重新获得一块页 page_id_t new_bucket_page_id; // 通过缓冲池管理器创建新的存储桶页面。 auto tmp_new_bucket_guard = bpm_-\u0026gt;NewPageGuarded(\u0026amp;new_bucket_page_id); auto new_bucket_guard = tmp_new_bucket_guard.UpgradeWrite(); auto new_bucket_page = new_bucket_guard.AsMut\u0026lt;ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;\u0026gt;(); new_bucket_page-\u0026gt;Init(bucket_max_size_); //调用 Init 方法初始化新存储桶页面。 directory_page-\u0026gt;IncrLocalDepth(bucket_index); //增加原桶局部深度（原桶为0，新桶为1） // 获取新的局部深度和掩码： auto new_local_depth = directory_page-\u0026gt;GetLocalDepth(bucket_index); auto local_depth_mask = directory_page-\u0026gt;GetLocalDepthMask(bucket_index); //因为新建了一个桶页那么要重新进行哈希 // 调用 UpdateDirectoryMapping 方法更新目录页面中的映射，确保新存储桶页面被正确引用。 auto new_bucket_idx = UpdateDirectoryMapping(directory_page, bucket_index, new_bucket_page_id, new_local_depth, local_depth_mask); // Rehash the old bucket\u0026#39;s KV pairs. page_id_t rehash_page_id; std::vector\u0026lt;uint32_t\u0026gt; remove_array; // 将当时的满桶里面的页重新hash,因为增加了局部深度和分裂了桶所以需要重新分配 // 遍历当前存储桶中的所有键值对，重新计算它们的哈希值，并将它们插入到新存储桶页面或原存储桶页面中。 // 记录需要从原存储桶中移除的键值对的索引。 // 遍历原桶键值对并重新哈希 for (uint32_t i = 0; i \u0026lt; bucket_page-\u0026gt;Size(); ++i) { auto k = bucket_page-\u0026gt;KeyAt(i); auto v = bucket_page-\u0026gt;ValueAt(i); uint32_t hash_k = Hash(k); auto rehash_idx = directory_page-\u0026gt;HashToBucketIndex(hash_k); rehash_page_id = directory_page-\u0026gt;GetBucketPageId(rehash_idx); if (rehash_page_id == new_bucket_page_id) { new_bucket_page-\u0026gt;Insert(k, v, cmp_); remove_array.push_back(i); } } // 由于每次删除操作会改变原桶的数组下标，需用helper变量记录已删除元素的数量，确保后续删除位置正确。 auto helper = 0; // 考虑array移除时需要删除元素的下标变化 for (auto \u0026amp;remove_id : remove_array) { // 当从数组中按索引顺序删除元素时，每次删除操作会导致后续元素的索引自动前移 bucket_page-\u0026gt;RemoveAt(remove_id - helper); helper++; } // 插入新的键值对 bucket_index = directory_page-\u0026gt;HashToBucketIndex(hash); rehash_page_id = directory_page-\u0026gt;GetBucketPageId(bucket_index); if (rehash_page_id == new_bucket_page_id) { insert_success = new_bucket_page-\u0026gt;Insert(key, value, cmp_); // 如果新桶插入后再次满（例如哈希冲突严重）， // 需重新进入分裂循环（while (!insert_success \u0026amp;\u0026amp; bucket_page-\u0026gt;IsFull())），直到插入成功或达到最大深度。 if (!insert_success \u0026amp;\u0026amp; new_bucket_page-\u0026gt;IsFull()) { bucket_guard = std::move(new_bucket_guard); bucket_page_id = new_bucket_page_id; bucket_page = new_bucket_page; bucket_index = new_bucket_idx; } } else { insert_success = bucket_page-\u0026gt;Insert(key, value, cmp_); } } return insert_success; //***************************************************************************** } // 可扩展哈希表中插入数据时，当需要创建新目录页 template \u0026lt;typename K, typename V, typename KC\u0026gt; auto DiskExtendibleHashTable\u0026lt;K, V, KC\u0026gt;::InsertToNewDirectory(ExtendibleHTableHeaderPage *header, uint32_t directory_idx, uint32_t hash, const K \u0026amp;key, const V \u0026amp;value) -\u0026gt; bool { //return false; //***************************************************************************** // 在磁盘上创建一个新的目录页。 page_id_t dir_page_id; auto tmp_directory_guard = bpm_-\u0026gt;NewPageGuarded(\u0026amp;dir_page_id); auto directory_guard = tmp_directory_guard.UpgradeWrite(); // 将新分配的页初始化为目录页。 auto directory_page = directory_guard.AsMut\u0026lt;ExtendibleHTableDirectoryPage\u0026gt;(); directory_page-\u0026gt;Init(directory_max_depth_); // 将新目录页的ID记录到哈希表的头部页中。 header-\u0026gt;SetDirectoryPageId(directory_idx, dir_page_id); // 根据哈希值计算键值对应在目录页中的桶索引。 auto bucket_idx = directory_page-\u0026gt;HashToBucketIndex(hash); // 将键值对插入到新目录页对应的桶中。 bool insert_success = InsertToNewBucket(directory_page, bucket_idx, key, value); return insert_success; //***************************************************************************** } // 在可扩展哈希表中创建一个新的存储桶（Bucket），并将键值对插入其中 template \u0026lt;typename K, typename V, typename KC\u0026gt; auto DiskExtendibleHashTable\u0026lt;K, V, KC\u0026gt;::InsertToNewBucket(ExtendibleHTableDirectoryPage *directory, uint32_t bucket_idx, const K \u0026amp;key, const V \u0026amp;value) -\u0026gt; bool { //return false; //***************************************************************************** page_id_t bucket_page_id; // ​创建新桶页面 auto tmp_bucket_guard = bpm_-\u0026gt;NewPageGuarded(\u0026amp;bucket_page_id); // 升级为写保护并转换页面类型 auto bucket_guard = tmp_bucket_guard.UpgradeWrite(); auto bucket_page = bucket_guard.AsMut\u0026lt;ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;\u0026gt;(); bucket_page-\u0026gt;Init(bucket_max_size_);// 初始化桶，设置其最大容量 // ​更新目录页信息 directory-\u0026gt;SetBucketPageId(bucket_idx, bucket_page_id);// 将目录项 bucket_idx 绑定到新桶的页面ID。 directory-\u0026gt;SetLocalDepth(bucket_idx, 0);// 设置该桶的局部深度（初始为0） assert(directory-\u0026gt;GetLocalDepth(bucket_idx) \u0026lt;= directory-\u0026gt;GetGlobalDepth()); // 将键值对插入新桶，cmp_为键比较器（如判断键是否相等） auto insert_success = bucket_page-\u0026gt;Insert(key, value, cmp_); return insert_success; //***************************************************************************** } // template \u0026lt;typename K, typename V, typename KC\u0026gt; // void DiskExtendibleHashTable\u0026lt;K, V, KC\u0026gt;::UpdateDirectoryMapping(ExtendibleHTableDirectoryPage *directory, // uint32_t new_bucket_idx, page_id_t new_bucket_page_id, // uint32_t new_local_depth, uint32_t local_depth_mask) { // //throw NotImplementedException(\u0026#34;DiskExtendibleHashTable is not implemented\u0026#34;); // } // 在可扩展哈希表中更新目录页的映射关系，主要发生在桶分裂后重新分配目录项与桶的对应关系。 //（桶分裂时，只有原桶和新桶与目录页面之间的映射会发生变化） template \u0026lt;typename K, typename V, typename KC\u0026gt; auto DiskExtendibleHashTable\u0026lt;K, V, KC\u0026gt;::UpdateDirectoryMapping(ExtendibleHTableDirectoryPage *directory_page, uint32_t old_bucket_idx, page_id_t new_bucket_page_id, uint32_t new_local_depth, uint32_t local_depth_mask) -\u0026gt; uint32_t { //更新映射 // 计算新起始索引 // 这里是通过local_depth_mask \u0026amp; old_bucket_idx（eg：00（000和100的原生，但是由于000等于00，故为旧桶的新idx）） auto new_first_bucket_idx = local_depth_mask \u0026amp; old_bucket_idx; // 111111111\u0026amp; old_bucket_idx auto prime_idx = new_first_bucket_idx; uint32_t distance = pow(2, new_local_depth); //这个意思就是由局部深度得到一个周期长度比如000 001 002 那么000加上8就还是000 //过了一半减去一半，没过一半加上一半 //从最小的下标开始 比如000就要变成100，这里就获得了新桶的idx new_first_bucket_idx = (new_first_bucket_idx \u0026gt;\u0026gt; (new_local_depth - 1)) == 0 ? (new_first_bucket_idx + (distance / 2)) : (new_first_bucket_idx - (distance / 2)); // 重新映射 for (uint32_t i = new_first_bucket_idx; i \u0026lt; directory_page-\u0026gt;Size(); i += distance) { directory_page-\u0026gt;SetBucketPageId(i, new_bucket_page_id); directory_page-\u0026gt;SetLocalDepth(i, new_local_depth); directory_page-\u0026gt;SetLocalDepth(prime_idx, new_local_depth); assert(directory_page-\u0026gt;GetLocalDepth(i) \u0026lt;= directory_page-\u0026gt;GetGlobalDepth()); assert(directory_page-\u0026gt;GetLocalDepth(prime_idx) \u0026lt;= directory_page-\u0026gt;GetGlobalDepth()); prime_idx += distance; } return new_first_bucket_idx; } /***************************************************************************** * REMOVE 可扩展哈希表的键值对删除操作，核心功能包括： ​定位目标存储桶​（三级结构：Header Page → Directory Page → Bucket Page） ​删除键值对​（若存在） ​处理空桶合并​（收缩目录和桶结构） 先获取桶的local深度，为0则无需合并，直接退出循环 否则，开始循环： 获取镜像桶【与原桶共享父桶的另一个子桶（例如原桶索引为0b101，镜像桶为0b001）】 如果空桶和镜像桶深度一样，则合并【更新目录映射，合并存储桶】 获取目录页面中第一个指向空桶和想要合并桶的地方 获取步长【每个指向合并存储桶的目录页面内的相邻的俩个内容之间的间距，这个间距应该是固定大小的】 遍历采用跳跃式更新，例如深度3时每隔4个目录项更新一次【这里是把目录页面数组都指向镜像桶的id】 处理父级合并 先获取桶的local深度，为0则无需合并，直接退出循环 这里由于local--了，所以镜像桶的idx是直接取local位的。【eg:111-\u0026gt;11】 获取该父级的镜像桶【01】 然后把父级的镜像桶的信息放到bucket_index里，再次进入循环 减少目录深度 否则，跳出循环 ​动态调整全局深度【即减少目录深度】 *****************************************************************************/ template \u0026lt;typename K, typename V, typename KC\u0026gt; auto DiskExtendibleHashTable\u0026lt;K, V, KC\u0026gt;::Remove(const K \u0026amp;key, Transaction *transaction) -\u0026gt; bool { //return false; //***************************************************************************** // 获取 Header Page（读保护） auto header_guard = bpm_-\u0026gt;FetchPageRead(header_page_id_); auto header_page = header_guard.As\u0026lt;ExtendibleHTableHeaderPage\u0026gt;(); uint32_t hash = Hash(key); // for test auto directory_index = header_page-\u0026gt;HashToDirectoryIndex(hash); auto directory_page_id = header_page-\u0026gt;GetDirectoryPageId(directory_index); if (static_cast\u0026lt;int\u0026gt;(directory_page_id) == INVALID_PAGE_ID) { return false; } // 获取 Directory Page（写保护） WritePageGuard directory_guard = bpm_-\u0026gt;FetchPageWrite(directory_page_id); auto directory_page = directory_guard.AsMut\u0026lt;ExtendibleHTableDirectoryPage\u0026gt;(); auto bucket_index = directory_page-\u0026gt;HashToBucketIndex(hash); auto bucket_page_id = directory_page-\u0026gt;GetBucketPageId(bucket_index); if (static_cast\u0026lt;int\u0026gt;(bucket_page_id) == INVALID_PAGE_ID) { return false; } // 获取存储桶页（写保护） // find the target key in the third level WritePageGuard bucket_guard = bpm_-\u0026gt;FetchPageWrite(bucket_page_id); auto bucket_page = bucket_guard.AsMut\u0026lt;ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;\u0026gt;(); // 尝试删除键值对 bool remove_success = bucket_page-\u0026gt;Remove(key, cmp_); if (!remove_success) { return false;// 键不存在 } // 当存储桶变为空时，需合并相邻桶并调整目录结构： while (bucket_page-\u0026gt;IsEmpty()) { bucket_guard.Drop(); // 获取当前桶的局部深度 auto bucket_local_depth = directory_page-\u0026gt;GetLocalDepth(bucket_index); if (bucket_local_depth == 0) {// // 局部深度为0时无法合并 break; } //得到分裂的桶，准备重新合并； // 获取镜像桶（Split Image）的索引和页ID // 镜像桶：与原桶共享父桶的另一个子桶（例如原桶索引为0b101，镜像桶为0b001）。 auto merge_bucket_index = directory_page-\u0026gt;GetSplitImageIndex(bucket_index); auto merge_bucket_local_depth = directory_page-\u0026gt;GetLocalDepth(merge_bucket_index); auto merge_bucket_page_id = directory_page-\u0026gt;GetBucketPageId(merge_bucket_index); if (bucket_local_depth == merge_bucket_local_depth) { //空桶和想要合并桶深度一样 // 更新目录映射，合并存储桶 // 获取当前深度的位掩码（我认为是获取目录页面中第一个指向空桶和想要合并桶的地方） uint32_t traverse_bucket_idx =std::min(bucket_index \u0026amp; directory_page-\u0026gt;GetLocalDepthMask(bucket_index), merge_bucket_index); //这里是获取步长，我得理解是每个指向合并存储桶的目录页面内的相邻的俩个内容之间的间距，这个间距应该是固定大小的 uint32_t distance = 1 \u0026lt;\u0026lt; (bucket_local_depth -1); //减小局部深度合并在一起比如 011应该和111合并在一起所以是bucket_local_depth - 1 uint32_t new_local_depth = bucket_local_depth - 1; // 将原桶对应的目录项指向镜像桶 // 局部深度减1（如从3减到2），这类似于哈希表收缩时的重新映射过程 // 遍历采用跳跃式更新，例如深度3时每隔4个目录项更新一次 for (uint32_t i = traverse_bucket_idx; i \u0026lt; directory_page-\u0026gt;Size(); i += distance) { directory_page-\u0026gt;SetBucketPageId(i, merge_bucket_page_id); directory_page-\u0026gt;SetLocalDepth(i, new_local_depth); } // 处理父级合并 if (new_local_depth == 0) { break; } //假设之前是 011满了找到了111 //计算当前镜像桶的父级镜像桶索引 auto split_image_bucket_index = directory_page-\u0026gt;GetSplitImageIndex(merge_bucket_index); // 11-\u0026gt;01 // 获取父级镜像桶的页ID auto split_image_bucket_page_id = directory_page-\u0026gt;GetBucketPageId(split_image_bucket_index); // 获取父级镜像桶的写保护 WritePageGuard split_image_bucket_guard = bpm_-\u0026gt;FetchPageWrite(split_image_bucket_page_id); // 父级镜像桶为无效时，则跳过合并流程。 if (split_image_bucket_page_id == INVALID_PAGE_ID) { break; } // 更新当前桶信息 auto helper = bucket_page_id; // 我当时是咋想的？写出下面这一行抽象代码…… // gradescope不提供测试源码，我这种复现不了测试的菜鸡重新review了一遍代码才找出这个bug。 // directory_page-\u0026gt;SetBucketPageId(bucket_index, 0); // 更新当前操作目标为父级镜像桶 bucket_index = split_image_bucket_index; bucket_page_id = split_image_bucket_page_id; bucket_guard = std::move(split_image_bucket_guard); bucket_page = bucket_guard.AsMut\u0026lt;ExtendibleHTableBucketPage\u0026lt;K, V, KC\u0026gt;\u0026gt;(); // 删除原桶 bpm_-\u0026gt;DeletePage(helper); } else { // Can not merge because of (LD != LD(split_image)) break; } // 减少目录深度：通过递归合并父级桶，可能进一步收缩目录的全局深度，减少目录项数量 while (directory_page-\u0026gt;CanShrink()) { directory_page-\u0026gt;DecrGlobalDepth(); } } // 检查是否所有目录项的局部深度都小于当前全局深度 // 逐步收缩全局深度，这类似于C++哈希表扩容的逆过程 // 全局深度决定了目录项的总数（2^global_depth） while (directory_page-\u0026gt;CanShrink()) { directory_page-\u0026gt;DecrGlobalDepth(); } return remove_success; //***************************************************************************** } 任务 #4 - 并发控制 正如官网所说：\n1 “我们建议您使用 FetchPageWrite 或 FetchPageRead 缓冲池 API 来完成此任务，具体取决于您是要使用读取权限还是写入权限访问页面。” 得益于我们在Task #1自己构建的RAll结构并在后续的严格遵守，所以Task #4 - Concurrency Control的实现是水到渠成的，不再需要什么额外工作。\n参考文章： CMU 15-445(Fall 2023) Project2 Extendible Hash Index个人笔记 - 焚风 - 博客园\nCMU15-445 2023 Fall Project#2 - Extensible Hash Index - 知乎\nCMU 15-445 P1 Extendible Hash Table 可扩展哈希详细理解 - 知乎\n[15-445 fall 2023] P2代码解析-CSDN博客\n鲤鱼_1-CSDN博客\nCMU_15-445（fall 2023）-P2（下）可拓展哈希实现及并发控制_15-445 fall2023 p2-CSDN博客\nCMU15-445-P2（中）三级hash_page详解-CSDN博客\nCMU15-445-P2（上）全局思路以及page_guard详解_cmu15445 p2-CSDN博客\n","date":"2024-11-11T15:29:00+08:00","permalink":"https://1878247293.github.io/p/cmu15445-2023-fall-p2/","title":"cmu15445 2023 fall   p2"},{"content":"项目网址： 项目 #3 - 查询执行 |CMU 15-445/645 ：： 数据库系统简介（2023 年秋季）\n一、SQL语句执行流程 1 总体 这部分课上有很详细的解释\n在收到一条 SQL 语句后，查询处理层首先会通过解析器 Parser 将 SQL 语句解析为一颗抽象句法树 AST（Abstracct Syntax Tree）。接下来绑定器 Binder 会遍历这棵句法树，将表名、列名等映射到数据库中的实际对象上，并由计划器 Planner 生成初步的查询计划。查询计划会以树的形式表示，数据从叶子节点流向父节点。\n最后，优化器 Optimizer 会优化生成最终的查询计划，然后交由查询执行层的执行器执行，而这里面的部分执行器需要我们来实现。\n2 例子 （语句前面加explain可以打印出语句的查询计划）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 bustub\u0026gt; explain select * from test_1; /*这部分描述了查询绑定器（Binder）如何处理SQL查询。它解析了查询，并将SQL的文本表示转换为内部的数据结构。 在这个例子中，它表示查询选择了 test_1 表中的所有列（colA, colB, colC, colD）。 没有使用 GROUP BY, HAVING, WHERE, LIMIT, OFFSET, 或 ORDER BY 子句。 也不是一个DISTINCT查询，并且没有使用公共表表达式（CTE）。 */ === BINDER === BoundSelect { table=BoundBaseTableRef { table=test_1, oid=20 }, columns=[test_1.colA, test_1.colB, test_1.colC, test_1.colD], groupBy=[], having=, where=, limit=, offset=, order_by=[], is_distinct=false, ctes=, } /*这部分展示了查询规划器（Planner）生成的查询执行计划。 Projection：这是一个投影操作，意味着它将从下一级操作（在这种情况下是 SeqScan）中选择特定的列（这里是 #0.0 到 #0.3，它们对应于 test_1 表的 colA 到 colD）。 SeqScan：这是一个顺序扫描操作，意味着它将扫描整个 test_1 表以获取数据。 */ === PLANNER === Projection { exprs=[#0.0, #0.1, #0.2, #0.3] } | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER) SeqScan { table=test_1 } | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER) /*这部分展示了查询优化器（Optimizer）可能如何进一步优化查询执行计划。但在这个例子中，它似乎没有做任何优化，只是简单地返回了与Planner相同的计划。 所以，优化后的计划仍然是一个简单的顺序扫描（SeqScan）操作。 */ === OPTIMIZER === SeqScan { table=test_1 } | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER)bustub\u0026gt; explain select * from test_1; 二、bustub 表结构 不得不说这个图真的做的太好了，这个看懂了才能做下去\n1 图的解读 首先，Bustub 有一个 Catalog。Catalog 维护了几张 hashmap，保存了 table id 和 table name 到 table info 的映射关系。table id 由 Catalog 在新建 table 时自动分配，table name 则由用户指定。\n​\t这里的 table info 包含了一张 table 信息，有 schema、name、id 和指向 table heap 的指针。系统的其他部分想要访问一张 table 时，先使用 name 或 id 从 Catalog 得到 table info，再访问 table info 中的 table heap。\n​\ttable heap 是管理 table 数据的结构，包含 table 相关操作。table heap 可能由多个 table page 组成，仅保存其第一个 table page 的 page id。需要访问某个 table page 时，通过 page id 经由 buffer pool 访问。\n​\ttable page 是实际存储 table 数据的结构，当需要新增 tuple 时，table heap 会找到当前属于自己的最后一张 table page，尝试插入，若最后一张 table page 已满，则新建一张 table page 插入 tuple。table page 低地址存放 header，tuple 从高地址也就是 table page 尾部开始插入。\n​\ttuple 对应数据表中的一行数据。每个 tuple 都由 RID 唯一标识。RID 由 page id + slot num 构成。tuple 由 value 组成，value 的个数和类型由 table info 中的 schema 指定。value 则是某个字段具体的值，value 本身还保存了类型信息。\n2 结合代码解读 首先，我们从所有执行器的基类抽象执行器 AbstractExecutor 入手（路径： src/include/execution/executors/abstract_executor.h），抽象执行器实现了一个 tuple-at-a-time 形式的火山迭代器模型，tuple-at-a-time 表明每次调用 Next() 函数会从当前执行器获取一个 tuple，火山模型则表明数据从子执行器向父执行器传递，根节点的输出即为最终的执行结果。它主要包括 Init() 和 Next() 两个成员函数。\n​\tAbstractExecutor 只有执行器上下文 ExecutorContext 这一个成员变量(路径：src/include/execution/executor_context.h)，ExecutorContext 包括当前事务 Transaction（变量名：transaction）、缓冲池管理器 BufferPoolManager（变量名：bpm）、事务管理器 TransactionManager（变量名：txn_mgr）、锁管理器 LockManager（变量名：lock_mgr） 以及目录 Catalog（变量名：catalog）。\n​\t与表管理直接相关的就是执行器上下文中的目录 Catalog（见上图），目录中主要包含了一个表标识符到表信息 TableInfo 的映射 std::unordered_map\u0026lt;table_oid_t, std::unique_ptr\u0026gt; tables_; 和一个表名到表标识符的映射 std::unordered_map\u0026lt;std::string, table_oid_t\u0026gt; table_names_;(上图中绿色的tableInfo)。\n​\t表信息 TableInfo 主要保存了有关表的一些元数据，其中最主要的就是 TableHeap（路径：Identification: src/include/storage/table/table_heap_.h），TableHeap 表示磁盘上的物理表，它是一个双向链表的页集合，通过 TableHeap 即可得到首个表页面 TablePage 中首个元组 Tuple（每个元组对应表中的一行数据）的迭代器，从而实现表遍历。\n建议充分了解了以后再写代码。\n数据库结构图详解——零基础友好版 一、整体结构：像一本书的图书馆 想象数据库是一个大型图书馆，每本书对应一张表（Table），而这张图展示了图书馆的目录系统（Catalog）、书籍信息卡（Table Info）、书架上的书（Table Heap）和书里的每一页（Table Page）。让我们一步步拆解：\n二、核心组件逐层解析 1. Catalog（目录）——图书馆的总目录 • 作用：记录整个数据库中有哪些“书”（表），相当于图书馆入口的总目录。 • 包含内容： • 每个表的唯一ID（类似书的编号，如T001）。 • 每个表对应的Table Info（书的详细信息卡）。\n2. Table Info（表信息卡）——书的详细信息 • 作用：描述一张表的“结构规则”，就像书的封面和目录页。 • 包含内容： • Schema（表结构）：定义表的列名、数据类型（如姓名是字符串，年龄是整数）。 • Name（表名）：例如用户表或订单表。 • ID（表唯一标识）：例如T001。\n3. Table Heap（表堆）——书架上的多本书 • 作用：实际存放表的所有数据，像一个装满书的书架。 • 组成方式： • 由多个Table Page（表页） 组成，每个页存储一部分数据。 • 数据按页堆叠，类似于一本书的每一页按顺序叠放。\n4. Table Page（表页）——书中的一页纸 • 作用：存储具体数据的最小单位，像书中的一页，写满后换下一页。 • 详细结构： • 页头（Header）：记录本页的元数据： ◦ 页ID：当前页的编号（如P001）。 ◦ 前后页ID：类似书页的前后页码，便于快速翻页。 ◦ 空闲空间：本页还剩多少空白区域可写数据。 • 元组（Tuples）：实际存储的数据行（类似表格中的一行）。 ◦ 每个元组包含： ◦ RID（行唯一标识）：由页ID + 槽号组成，像书中的“第3页第5行”。 ◦ 数据值：例如用户ID为1001，姓名为张三。\n三、数据存取流程示例 以查询用户张三为例：\n查目录：通过Catalog找到用户表的ID（如T001）。 读表信息：根据Table Info得知用户表有ID、姓名、年龄三列。 找数据位置：进入Table Heap，按页ID逐页扫描（类似翻书）。 定位具体行：在某个Table Page中找到RID为P003-S05的元组，读取张三的数据。 四、关键概念总结 组件 类比 核心作用 示例 Catalog 图书馆总目录 管理所有表的基本信息 记录有用户表(T001)和订单表(T002) Table Info 书籍信息卡 定义表的结构规则 用户表包含ID(int)、姓名(varchar) Table Heap 书架上的书 存储表的所有数据 用户表数据分布在100个Table Page中 Table Page 书中的一页 存储具体数据的最小单元 页P003存储了用户张三的数据 五、新手常见疑问解答 为什么分这么多层？\n• 解耦设计：目录、结构、数据分离，便于单独管理（如修改表结构不影响已有数据）。 • 高效查询：通过目录快速定位，避免全盘扫描。\n元组（Tuple）和行（Row）的区别？\n• 在数据库中二者通常等价，但元组更强调“不可变的数据集合”。\n页为什么要记录前后页ID？\n• 支持顺序遍历（如翻页查询），也便于插入新页时维护链表关系。\n通过这个结构，数据库像图书馆一样层次清晰、高效管理海量数据。理解这些基础概念后，后续学习索引、事务等高级特性会更轻松！\n任务 #1 - 访问方法执行程序 在此任务中，您将实现对存储系统中的表进行读取和写入的执行程序。您将在以下文件中完成实施：\nsrc/include/execution/seq_scan_executor.h src/execution/seq_scan_executor.cpp src/include/execution/insert_executor.h src/execution/insert_executor.cpp src/include/execution/update_executor.h src/execution/update_executor.cpp src/include/execution/delete_executor.h src/execution/delete_executor.cpp src/include/execution/index_scan_executor.h src/execution/index_scan_executor.cpp src/optimizer/seqscan_as_indexscan.cpp 1 SeqScan 1.1 思路 Init 方法首先获取要扫描的表的堆（table_heap_），然后创建一个迭代器 iter来遍历这个堆。它遍历堆中的所有记录，并将它们的记录标识符（RID）存储在rids_列表中。最后，它将rid_iter_设置为rids_列表的起始位置。 Next方法用于从表中检索下一个满足条件的元组。它使用一个do-while循环来遍历rids_ 列表中的 RID。对于每个 RID，它首先获取该 RID 对应的元组的元数据（TupleMeta）。如果该元组没有被删除（!meta.is_deleted_），则将该元组复制到传入的 tuple参数中，并将 RID 复制到rid参数中。 然后，它检查是否有过滤条件（plan_-\u0026gt;filter_predicate_）。如果有，它会评估这个过滤条件，并检查结果是否为 true。只有当元组没有被删除且满足过滤条件时，do-while 循环才会结束。\n1.2 代码\n1 2 3 4 5 6 7 8 9 10 private: /** The sequential scan plan node to be executed */ /** 要执行的顺序扫描计划节点 */ const SeqScanPlanNode *plan_; ////////////////////////////////////////////// TableInfo *table_info_; TableHeap *table_heap_; //表堆是表示物理表在磁盘上的存储结构 std::vector\u0026lt;RID\u0026gt; rids_; std::vector\u0026lt;RID\u0026gt;::iterator rids_iter_; ////////////////////////////////////////////// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 //===----------------------------------------------------------------------===// // 构造函数,初始化顺序扫描执行器。 SeqScanExecutor::SeqScanExecutor(ExecutorContext *exec_ctx, const SeqScanPlanNode *plan) : AbstractExecutor(exec_ctx), plan_(plan) {}// exec_ctx：执行上下文（包含事务、目录等）; // plan：顺序扫描计划节点（包含要扫描的表ID、过滤条件等） //===----------------------------------------------------------------------===// // 准备扫描所需的数据结构。 /* 先获取表的信息（到table_heap_） 收集所有的RID（auto iter = table_heap_-\u0026gt;MakeIterator();） 所有行的 RID（行标识符）存入 rids_ 列表 初始化迭代器,rids_iter_ 指向 RID 列表的起始位置。 */ void SeqScanExecutor::Init() //{ throw NotImplementedException(\u0026#34;SeqScanExecutor is not implemented\u0026#34;); } {//===----------------------------------------------------------------------===// // 通过目录（Catalog）根据表OID获取表的元数据（如 Schema、数据存储位置）。 // 目前我的理解是获取表的所有信息 table_info_ = GetExecutorContext()-\u0026gt;GetCatalog()-\u0026gt;GetTable(plan_-\u0026gt;GetTableOid()); // table_heap_ 是实际存储表数据的结构（类似一个数组）。 // 目前我的理解是将表内的数据部分都提取出来,获取所有的表页 table_heap_ = table_info_-\u0026gt;table_.get(); // 收集所有 RID：（行标识符） auto iter = table_heap_-\u0026gt;MakeIterator(); rids_.clear(); //iter 是表堆的迭代器，用于遍历表中每一行。 // 循环将所有行的 RID（行标识符）存入 rids_ 列表。 while (!iter.IsEnd()) { rids_.push_back(iter.GetRID()); ++iter; } // 初始化迭代器,rids_iter_ 指向 RID 列表的起始位置。 rids_iter_ = rids_.begin(); }//===----------------------------------------------------------------------===// // 获取下一行数据，跳过被删除的行和不符合过滤条件的行。 /* 如果 RID 迭代器到达末尾，返回 false，否则继续 通过rids_iter_在table_heap_中获取元数据 检查当前行是否被删除 若未删除，将当前行的数据和 RID 赋值给输出参数，然后退出循环 否则，被删除或者不符合过滤条件的情况下会继续进行循环。 */ auto SeqScanExecutor::Next(Tuple *tuple, RID *rid) -\u0026gt; bool// { return false; } {//===----------------------------------------------------------------------===// TupleMeta meta{}; do { // ​终止条件：如果 RID 迭代器到达末尾，返回 false（无更多数据）。 if (rids_iter_ == rids_.end()) { return false; } meta = table_heap_-\u0026gt;GetTupleMeta(*rids_iter_);// 获取元数据 // 检查当前行是否被删除（meta.is_deleted_）。 if (!meta.is_deleted_) { //若未删除，将当前行的数据和 RID 赋值给输出参数。 *tuple = table_heap_-\u0026gt;GetTuple(*rids_iter_).second; *rid = *rids_iter_; } ++rids_iter_; } while (meta.is_deleted_ || (plan_-\u0026gt;filter_predicate_ != nullptr \u0026amp;\u0026amp;// meta.is_deleted时继续循环。 // Evaluate 方法根据表的 Schema 计算条件表达式的结果。（我认为其实就是不符合过滤条件） !plan_-\u0026gt;filter_predicate_-\u0026gt;Evaluate(tuple, table_info_-\u0026gt;schema_).GetAs\u0026lt;bool\u0026gt;())); return true; }//===----------------------------------------------------------------------===// 2 Insert 2.1 思路 要求： 执行器生成一个整数类型的元组作为输出，并指示有多少行已经被插入到表中。当向表中插入数据时，如果表有关联的索引，请记得更新这些索引。 思路：把要插入的内容放在子执行器 child_executor_中，然后获取一些必要参数，其中插入到表中的行数的整数元组 和插入操作产生的下一个元组RID已经给出了。用while语句把子执行器中的每个元组都插进去（还有更新索引），最后算下一共插入多少行\n2.2 代码\n1 2 3 4 5 6 7 8 9 10 private: /** The insert plan node to be executed*/ /** 要执行的插入计划节点 */ const InsertPlanNode *plan_; /////////////////////////////////////////////////// // 从中获取元组的子执行器 std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; child_executor_; /** Next()之前是否被调用过 */ bool called_; /////////////////////////////////////////////////// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 //===----------------------------------------------------------------------===// // 初始化插入执行器 InsertExecutor::InsertExecutor(ExecutorContext *exec_ctx, const InsertPlanNode *plan, std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; \u0026amp;\u0026amp;child_executor) : AbstractExecutor(exec_ctx), plan_(plan), child_executor_(std::move(child_executor)) {} //child_executor：子执行器（如 ValuesExecutor，用于提供待插入的数据）。 //===----------------------------------------------------------------------===// /* 初始化子执行器,让其准备好待插入的数据。 初始化called_ = false;表示目前没被调用过 */ void InsertExecutor::Init() {//===----------------------------------------------------------------------===// // 初始化子执行器：例如，如果子执行器是 ValuesExecutor，它会准备好待插入的数据。 child_executor_-\u0026gt;Init(); called_ = false;// 表示目前没被调用过 }//===----------------------------------------------------------------------===// /* 获取表、事务、索引信息【tx、table_heap、index_info_vector】 循环读取子执行器的数据 获取要插入的数据和相应的行数 插入元组到表 处理 RID（行标识符）【如果插入的数据没有RID，则自动生成一个新的RID，插入进去】 将插入的数据同步更新到所有关联索引（如 B+树索引） 统计插入行数，重置 RID 继续循环，知道要插入的数据都处理完 构造返回结果 插入行数作为结果 控制返回值，判断返回ture还是false */ auto InsertExecutor::Next([[maybe_unused]] Tuple *tuple, RID *rid) -\u0026gt; bool //{ return false; } {//===----------------------------------------------------------------------===// // 1. 获取表、事务、索引信息 TableInfo *table_info = GetExecutorContext()-\u0026gt;GetCatalog()-\u0026gt;GetTable(plan_-\u0026gt;GetTableOid()); Transaction *tx = GetExecutorContext()-\u0026gt;GetTransaction(); TableHeap *table_heap = table_info-\u0026gt;table_.get(); std::vector\u0026lt;IndexInfo *\u0026gt; index_info_vector = GetExecutorContext()-\u0026gt;GetCatalog()-\u0026gt;GetTableIndexes(table_info-\u0026gt;name_); // 2. 循环读取子执行器的数据 Tuple child_tuple{}; int size = 0; while (child_executor_-\u0026gt;Next(\u0026amp;child_tuple, rid)) {//获取要插入的数据和相应的行数 // 3. 插入元组到表 // 元组元数据，包含事务时间戳（tx-\u0026gt;GetTransactionTempTs()）和删除标记（false 表示未删除）。 // 待插入的数据行 // 锁管理器，用于并发控制（如行级锁） // 事务对象，记录操作日志（如 undo log 和 redo log） auto rid_optional = table_heap-\u0026gt;InsertTuple(TupleMeta{tx-\u0026gt;GetTransactionTempTs(), false}, child_tuple,//要插入的数据 GetExecutorContext()-\u0026gt;GetLockManager(), tx); // 4. 处理 RID（行标识符） //​条件：如果原始 rid 是空值（默认构造的 RID()），且插入操作返回了一个有效的 RID（rid_optional.has_value() 为 true）。 //​操作：将插入后生成的新 RID（rid_optional.value()）赋值给原始 rid 指针。 if (*rid == RID() \u0026amp;\u0026amp; rid_optional.has_value()) { *rid = rid_optional.value(); } // 5. 将插入的数据同步更新到所有关联索引（如 B+树索引） //从数据行中提取索引键（如用户ID），基于表模式（table_info-\u0026gt;schema_）和索引键定义（index_info-\u0026gt;key_schema_） //新插入行的物理地址，用于索引键到数据的映射 // 事务对象，记录索引操作的日志（如 redo log） for (auto \u0026amp;index_info : index_info_vector) { index_info-\u0026gt;index_-\u0026gt;InsertEntry( child_tuple.KeyFromTuple(table_info-\u0026gt;schema_, index_info-\u0026gt;key_schema_, index_info-\u0026gt;index_-\u0026gt;GetKeyAttrs()), *rid, tx);// 行标识符，事务 } size++;// 统计插入行数 *rid = RID();// 重置 RID } // 6. 构造返回结果 std::vector\u0026lt;Value\u0026gt; values{}; values.reserve(GetOutputSchema().GetColumnCount()); // 插入行数作为结果 values.emplace_back(INTEGER, size); *tuple = Tuple{values, \u0026amp;GetOutputSchema()}; // 7. 控制返回值 // 在数据库执行器（如InsertExecutor）中，Next()方法通常采用迭代器模式设计，需要明确两种状态： // 返回true：表示“已处理完成”（无论是否实际执行操作）。 // ​返回false：表示“无更多数据需处理”。 if (size == 0 \u0026amp;\u0026amp; !called_) {//这里我认为目的是为了使得插入0行的情况可以通过，不然就会默认不插入了。 //当然我知道以上猜测不对劲，大概率应该是为了NEXT（）初始化用的 called_ = true; return true;// 插入 0 行且以前没被调用过时返回 true 一次 } called_ = true; return size != 0;// 插入行数 \u0026gt;0 时返回 true 一次 }//===----------------------------------------------------------------------===// 3 UpDate 3.1 思路 要求：执行器将输出一个整数类型的元组，表示已更新的行数。 思路： 更新逻辑是把原来的元组设置为已删除，然后插入新的元组。\n3.2 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private: /** The update plan node to be executed */ /** 要执行的更新计划节点 */ const UpdatePlanNode *plan_; /** Metadata identifying the table that should be updated */ /** 标识应该更新的表的元数据 */ const TableInfo *table_info_; /** The child executor to obtain value from */ /** 从中获取值的子执行器 */ std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; child_executor_; //////////////////////////////////////////////////////////////////////////// bool is_end_; //////////////////////////////////////////////////////////////////////////// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // 初始化更新执行器。 // , plan_{plan}, child_executor_{std::move(child_executor)} //child_executor：子执行器，提供待更新的数据（例如通过 WHERE 条件筛选出的数据） UpdateExecutor::UpdateExecutor(ExecutorContext *exec_ctx, const UpdatePlanNode *plan, std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; \u0026amp;\u0026amp;child_executor) : AbstractExecutor(exec_ctx) , plan_{plan}, child_executor_{std::move(child_executor)}{ // As of Fall 2022, you DON\u0026#39;T need to implement update executor to have perfect score in project 3 / project 4. // 截至 2022 年秋季，您无需实现更新执行器即可在项目 3 / 项目 4 中获得满分。 } // 初始化方法 /* 初始化子执行器,让其准备好待插入的数据。 获取表信息【table_info_】 is_end_ = false;标记是否完成更新操作 */ void UpdateExecutor::Init() //{ throw NotImplementedException(\u0026#34;UpdateExecutor is not implemented\u0026#34;); } { child_executor_-\u0026gt;Init();// 初始化子执行器（如开始扫描数据） // 从数据库目录（Catalog）中获取表结构（如字段名、类型） table_info_ = exec_ctx_-\u0026gt;GetCatalog()-\u0026gt;GetTable(plan_-\u0026gt;GetTableOid()); is_end_ = false;// 标记是否完成更新操作 } /* 诺已执行过更新，直接返回false 获取事务、表信息、索引信息【tx、table_info、index_info_vector】 循环读取子执行器的数据 生成新数据（根据更新表达式和旧的元组数据） 更新表中的数据行 统计更新行数以及更新所有索引（先删除旧索引，再插入新索引） 子执行器的数据读取完后退出循环 构造返回结果（更新的行数） */ auto UpdateExecutor::Next([[maybe_unused]] Tuple *tuple, RID *rid) -\u0026gt; bool //{ return false; } { if (is_end_) {// 已执行过更新，直接返回 return false; } // 获取事务、表信息、索引信息 Transaction *tx = GetExecutorContext()-\u0026gt;GetTransaction(); TableInfo *table_info = GetExecutorContext()-\u0026gt;GetCatalog()-\u0026gt;GetTable(plan_-\u0026gt;GetTableOid()); std::vector\u0026lt;IndexInfo *\u0026gt; index_info_vector = GetExecutorContext()-\u0026gt;GetCatalog()-\u0026gt;GetTableIndexes(table_info-\u0026gt;name_); Tuple old_tuple{};// 旧数据（待更新的原始行） int32_t update_count = 0;// 统计更新的行数 // 循环读取子执行器的数据 while (child_executor_-\u0026gt;Next(\u0026amp;old_tuple, rid)) { // 生成新数据（根据更新表达式） std::vector\u0026lt;Value\u0026gt; values{}; values.reserve(child_executor_-\u0026gt;GetOutputSchema().GetColumnCount()); for (const auto \u0026amp;expr : plan_-\u0026gt;target_expressions_) { values.push_back(expr-\u0026gt;Evaluate(\u0026amp;old_tuple, child_executor_-\u0026gt;GetOutputSchema())); } auto to_update_tuple = Tuple{values, \u0026amp;child_executor_-\u0026gt;GetOutputSchema()}; // 更新表中的数据行 bool updated =// 元数据（时间戳、未删除）；// 新数据；// 行标识符（定位要修改的行） table_info_-\u0026gt;table_-\u0026gt;UpdateTupleInPlace(TupleMeta{tx-\u0026gt;GetTransactionTempTs(), false}, to_update_tuple, *rid); if (updated) { update_count++; // 统计成功更新的行数 // 更新所有索引（先删除旧索引，再插入新索引） for (auto \u0026amp;index_info : index_info_vector) { index_info-\u0026gt;index_-\u0026gt;DeleteEntry( old_tuple.KeyFromTuple(table_info-\u0026gt;schema_, index_info-\u0026gt;key_schema_, index_info-\u0026gt;index_-\u0026gt;GetKeyAttrs()), *rid, tx); index_info-\u0026gt;index_-\u0026gt;InsertEntry(to_update_tuple.KeyFromTuple(table_info-\u0026gt;schema_, index_info-\u0026gt;key_schema_, index_info-\u0026gt;index_-\u0026gt;GetKeyAttrs()), *rid, tx); } } } // 构造返回结果（更新的行数） std::vector\u0026lt;Value\u0026gt; values{}; values.reserve(GetOutputSchema().GetColumnCount()); values.emplace_back(TypeId::INTEGER, update_count); *tuple = Tuple{values, \u0026amp;GetOutputSchema()}; is_end_ = true;// 标记已执行完成 return true; // 返回true表示有结果 } 4 Delete 没什么说的，和update差不多，把更新的部分删掉，删除的部分保留就行\n1 2 3 4 5 6 7 8 9 10 11 12 private: /** The delete plan node to be executed */ /** 要执行的删除计划节点 */ const DeletePlanNode *plan_; /** The child executor from which RIDs for deleted tuples are pulled */ /** 子执行器，从中提取已删除元组的 RID */ std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; child_executor_; //===----------------------------------------------------------------------===// /** Whether the Next() has been called before */ bool called_; //===----------------------------------------------------------------------===// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // , plan_(plan), child_executor_(std::move(child_executor)) //child_executor_：子执行器，用于提供待删除的数据（例如通过 WHERE 条件筛选出的数据）。 DeleteExecutor::DeleteExecutor(ExecutorContext *exec_ctx, const DeletePlanNode *plan, std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; \u0026amp;\u0026amp;child_executor) : AbstractExecutor(exec_ctx), plan_(plan), child_executor_(std::move(child_executor)) {} // 初始化删除执行器。 /* 初始化子执行器,让其准备好待插入的数据。 初始化called_ = false;表示目前没被调用过 */ void DeleteExecutor::Init() {//===----------------------------------------------------------------------===// child_executor_-\u0026gt;Init();// 例如，若子执行器是扫描执行器（SeqScanExecutor），会开始扫描表数据。 called_ = false; }//===----------------------------------------------------------------------===// /* 获取表、事务、索引信息【tx、table_heap、index_info_vector】 循环读取子执行器的数据 标记数据为已删除 更新所有索引 统计删除行数 子执行器的数据读取完后退出循环 构造返回结果（删除行数） 判断返回ture还是false */ auto DeleteExecutor::Next([[maybe_unused]] Tuple *tuple, RID *rid) -\u0026gt; bool //{ return false; } {//===----------------------------------------------------------------------===// // 获取表、事务、索引信息 TableInfo *table_info = GetExecutorContext()-\u0026gt;GetCatalog()-\u0026gt;GetTable(plan_-\u0026gt;GetTableOid()); Transaction *tx = GetExecutorContext()-\u0026gt;GetTransaction(); TableHeap *table_heap = table_info-\u0026gt;table_.get(); std::vector\u0026lt;IndexInfo *\u0026gt; index_info_vector = GetExecutorContext()-\u0026gt;GetCatalog()-\u0026gt;GetTableIndexes(table_info-\u0026gt;name_); Tuple child_tuple{}; int size = 0; // 循环读取子执行器的数据 while (child_executor_-\u0026gt;Next(\u0026amp;child_tuple, rid)) { // 标记数据为已删除 table_heap-\u0026gt;UpdateTupleMeta(TupleMeta{tx-\u0026gt;GetTransactionTempTs(), true}, *rid); // 更新所有索引 for (auto \u0026amp;index_info : index_info_vector) { index_info-\u0026gt;index_-\u0026gt;DeleteEntry( child_tuple.KeyFromTuple(table_info-\u0026gt;schema_, index_info-\u0026gt;key_schema_, index_info-\u0026gt;index_-\u0026gt;GetKeyAttrs()), *rid, tx); } size++;// 统计删除行数 } // 构造返回结果（删除行数） std::vector\u0026lt;Value\u0026gt; values{}; values.reserve(GetOutputSchema().GetColumnCount()); values.emplace_back(INTEGER, size); *tuple = Tuple{values, \u0026amp;GetOutputSchema()}; // 控制返回值 if (size == 0 \u0026amp;\u0026amp; !called_) {// 删除0行时返回一次true called_ = true; return true; } called_ = true; return size != 0;// 删除行数\u0026gt;0时返回true一次 }//===----------------------------------------------------------------------===// 5 Indexscan 5.1 思路 要求： 使用哈希索引执行点查找以检索元组的RID。然后逐个发出这些元组。 思路： 把索引得到的值放到result_rids里，然后判断result_rids 是不是空，删除标志，都不是就把数据和RID分别赋值给传入的 tuple 和 rid 指针所指向的变量\n5.2 代码\n1 2 3 4 5 6 7 8 private: /** The index scan plan node to be executed. */ /** 要执行的索引扫描计划节点。 */ const IndexScanPlanNode *plan_; //////////////////////////////////////////////// std::vector\u0026lt;RID\u0026gt; rids_; std::vector\u0026lt;RID\u0026gt;::iterator rids_iter_; //////////////////////////////////////////////// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 // 初始化索引扫描执行器。 // 参数： // exec_ctx：执行上下文（包含事务、锁管理器等）。 // plan：索引扫描的执行计划（例如使用哪个索引、过滤条件等）。 IndexScanExecutor::IndexScanExecutor(ExecutorContext *exec_ctx, const IndexScanPlanNode *plan) : AbstractExecutor(exec_ctx), plan_(plan) {}// , plan_(plan) /* 获取索引信息且转换为哈希索引 如果有过滤条件（例如 WHERE id = 1001） 提取过滤条件的常量值（例如1001） 使用索引查找匹配的RID（例如找到所有id=1001的行位置） 初始化迭代器，准备遍历RID列表 */ void IndexScanExecutor::Init() //{ throw NotImplementedException(\u0026#34;IndexScanExecutor is not implemented\u0026#34;); } {/////////////////////////////////////////////// // 获取索引信息（例如索引类型、关联的表） IndexInfo *index_info = GetExecutorContext()-\u0026gt;GetCatalog()-\u0026gt;GetIndex(plan_-\u0026gt;index_oid_); // 将索引转换为哈希索引（假设索引类型是哈希索引） auto *hash_index = dynamic_cast\u0026lt;HashTableIndexForTwoIntegerColumn *\u0026gt;(index_info-\u0026gt;index_.get()); rids_.clear();// 清空存储行标识符（RID）的列表 // 如果有过滤条件（例如 WHERE id = 1001） if (plan_-\u0026gt;filter_predicate_ != nullptr) { // 提取过滤条件的常量值（例如1001） const auto right_exptr = dynamic_cast\u0026lt;ConstantValueExpression *\u0026gt;(plan_-\u0026gt;filter_predicate_-\u0026gt;children_[1].get()); Value v = right_exptr-\u0026gt;val_; // 使用索引查找匹配的RID（例如找到所有id=1001的行位置） hash_index-\u0026gt;ScanKey(Tuple{{v}, index_info-\u0026gt;index_-\u0026gt;GetKeySchema()}, \u0026amp;rids_, GetExecutorContext()-\u0026gt;GetTransaction()); } // 初始化迭代器，准备遍历RID列表 rids_iter_ = rids_.begin(); }/////////////////////////////////////////////// /* 获取索引和表信息【index_info、table_info】 进入循环 如果RID列表遍历完成，返回false 获取当前RID（行位置） 获取该行的元数据（例如是否被删除） 从表中读取该行的实际数据 迭代器指向下一个RID 遇到已删除的行时，继续循环，否则跳出循环 返回 ture */ auto IndexScanExecutor::Next(Tuple *tuple, RID *rid) -\u0026gt; bool //{ return false; } {/////////////////////////////////////////////// // 获取索引和表信息（例如表名、表结构） IndexInfo *index_info = GetExecutorContext()-\u0026gt;GetCatalog()-\u0026gt;GetIndex(plan_-\u0026gt;GetIndexOid()); TableInfo *table_info = GetExecutorContext()-\u0026gt;GetCatalog()-\u0026gt;GetTable(index_info-\u0026gt;table_name_); TupleMeta meta{}; do { // 如果RID列表遍历完成，返回false if (rids_iter_ == rids_.end()) { return false; } // 获取当前RID（行位置） *rid = *rids_iter_; // 获取该行的元数据（例如是否被删除） meta = table_info-\u0026gt;table_-\u0026gt;GetTupleMeta(*rid); // 从表中读取该行的实际数据 *tuple = table_info-\u0026gt;table_-\u0026gt;GetTuple(*rid).second; // 迭代器指向下一个RID rids_iter_++; } while (meta.is_deleted_);// 跳过已删除的行 return true; }/////////////////////////////////////////////// task1 完成后，sql语句的1-6就都可以测试了\n6 优化 6.1 思路 要求： 实现将SeqScanPlanNode优化为IndexScanPlanNode的优化器规则 思路： 只有一种情况可以把顺序的变成索引的，即以下条件同时满足 1、谓词（即where之后的语句）不为空 2、表支持索引扫描 3、只有一个谓词条件（如SELECT * FROM t1 WHERE v1 = 1 AND v2 = 2就不行） 4、谓词是等值条件（即WHERE v1 = 1） 所以要把所有条件都判断一遍，才能用索引扫描\n6.2 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 /* 遍历子计划，递归优化【children.emplace_back(OptimizeSeqScanAsIndexScan(child));】 克隆计划，用优化后的子计划替换原有的子计划 复制一份计划【optimized_plan = plan-\u0026gt;CloneWithChildren(std::move(children));】 如果计划类型为序列扫描 动态类型转换为序列扫描计划节点 动态类型转换为比较表达式 过滤条件必须是等值比较​（如 =），才能使用索引加速。 获取表格信息、索引 动态类型转换为列值表达式 遍历所有索引， 匹配索引列 返回索引扫描计划节点，生成索引扫描计划 结束 返回优化后的计划【这里的情况是不符合优化条件】 */ // 优化器函数：将序列扫描计划优化为索引扫描计划 auto Optimizer::OptimizeSeqScanAsIndexScan(const bustub::AbstractPlanNodeRef \u0026amp;plan) -\u0026gt; AbstractPlanNodeRef { /////////////////////////////////////////////////// // TODO(student): implement seq scan with predicate -\u0026gt; index scan optimizer rule // The Filter Predicate Pushdown has been enabled for you in optimizer.cpp when forcing starter rule // 遍历子计划，递归优化 // 作用：深度优先遍历查询计划树，确保所有子节点都经过优化。 // ​类比：类似先整理书架每一层，再处理整个书架。 std::vector\u0026lt;AbstractPlanNodeRef\u0026gt; children; for (const auto \u0026amp;child : plan-\u0026gt;GetChildren()) { children.emplace_back(OptimizeSeqScanAsIndexScan(child)); } // 克隆计划，用优化后的子计划替换原有的子计划 // 作用：生成一个与原计划结构相同的新计划，但替换了优化后的子节点。 // ​意义：避免直接修改原计划，保证优化过程的独立性。 auto optimized_plan = plan-\u0026gt;CloneWithChildren(std::move(children)); // 如果计划类型为序列扫描 if (optimized_plan-\u0026gt;GetType() == PlanType::SeqScan) { // 动态类型转换为序列扫描计划节点 if (const auto \u0026amp;seq_scan = dynamic_cast\u0026lt;const SeqScanPlanNode \u0026amp;\u0026gt;(*optimized_plan); seq_scan.filter_predicate_ != nullptr) {// 如果过滤谓词不为空 // 动态类型转换为比较表达式 if (const auto *cmp_expr = dynamic_cast\u0026lt;const ComparisonExpression *\u0026gt;(seq_scan.filter_predicate_.get()); // 过滤条件必须是等值比较​（如 =），才能使用索引加速。 // 例如：WHERE id = 1001 适合索引扫描，而 WHERE id \u0026gt; 1001 可能不适合。 cmp_expr != nullptr \u0026amp;\u0026amp; cmp_expr-\u0026gt;comp_type_ == ComparisonType::Equal) {// 如果是相等比较表达式 // 获取表格信息 const auto *table_info = catalog_.GetTable(seq_scan.GetTableOid()); // 获取表格的所有索引 const auto indices = catalog_.GetTableIndexes(table_info-\u0026gt;name_); // 动态类型转换为列值表达式 const auto *column_value_expr = dynamic_cast\u0026lt;ColumnValueExpression *\u0026gt;(cmp_expr-\u0026gt;children_[0].get()); // 遍历所有索引， 匹配索引列 // ​列匹配：过滤条件中的列（如 id）必须与索引的列完全一致。 // 示例：若索引是 (id)，过滤条件为 id = 1001，则匹配成功。 // 不匹配的情况：索引是 (name)，过滤条件是 id = 1001，则跳过。 for (const auto *index : indices) { // 获取索引的列 const auto \u0026amp;columns = index-\u0026gt;index_-\u0026gt;GetKeyAttrs();// 索引的列ID列表 // 获取过滤列的ID std::vector\u0026lt;uint32_t\u0026gt; filter_column_ids = {column_value_expr-\u0026gt;GetColIdx()}; // 如果过滤列ID与索引列相匹配 if (filter_column_ids == columns) { // 是否匹配索引列 // 返回索引扫描计划节点，生成索引扫描计划 return std::make_shared\u0026lt;IndexScanPlanNode\u0026gt;(optimized_plan-\u0026gt;output_schema_, table_info-\u0026gt;oid_, index-\u0026gt;index_oid_, seq_scan.filter_predicate_); } } } } } // 返回优化后的计划 return optimized_plan; /////////////////////////////////////////////////// //return plan; } 任务 #2 - 聚合和联接执行者 您将在以下文件中完成实施：\nsrc/include/execution/aggregation_executor.h src/execution/aggregation_executor.cpp src/include/execution/nested_loop_join_executor.h src/execution/nested_loop_join_executor.cpp 1 Aggregation 1.1 思路 注意：聚合在查询计划中是管道中断者，聚合操作不能简单地按行（tuple-by-tuple）从其子节点（或数据源）接收数据，然后逐行输出结果。 相反，聚合操作需要先从其子节点获取所有相关的数据，完成整个聚合计算过程（例如计算总和、平均值、最小/最大值等），然后才能产生输出结果 AggregationExecutor 需要先从子执行器中获取所有数据，然后对这些数据进行分组和聚合操作， 最后将结果输出，而这个过程必须在init函数中完成\n这里我推荐看.h文件，更容易看懂。\n思路：\n我们以分组聚合查询语句 select count(name) from table group by camp; 为例简要说明一下聚合执行器的执行流程： Init() 函数首先从子执行器中逐行获取数据，并根据每行数据构建聚合键和聚合值。其中聚合键用于标识该行数据属于哪一个聚合组，这里是按照阵营 camp 分组，因此聚合键会有 Piltover、Ionia 和 Shadow Isles 三种取值，这样所有数据被分成三个聚合组。而聚合值就是待聚合的列的值，这里的聚合列是 name，因此这五个 Tuple 中生成的聚合值即为对应的 name 属性的值。 对于每个提取的数据行，Init() 函数还会通过 InsertCombine()， 将相应的聚合值聚合到到相应的聚合组中。在InsertCombine()中调用CombineAggregateValues() 函数来实现具体的聚合规则。 经过 Init() 函数的处理，以上六条数据会被整理为 [{“Piltover”: 3}, {“Ionia”: 2}, {“Shadow Isles”: 1}] 三个聚合组（对应于聚合哈希表中的三个键值对）。其中groupby的值分别为Piltover、Ionia、Shadow Isles；aggregate的值分别为3、2、1。 最后，Next() 函数会通过哈希迭代器依次获取每个聚合组的键与值，返回给父执行器。如果没 group by 子句，那么所有数据都会被分到同一个聚合组中并返回。\n1.2 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /////////////////////////////////////////////////////////// // 返回表的大小 auto Size() -\u0026gt; size_t { return ht_.size(); } ////////////////////////////////////////////////////////////////////// /** 简单聚合哈希表 */ // 存储所有分组的中间聚合结果。 // ​结构： // ​键（Key）​：分组键（如[\u0026#34;HR\u0026#34;]）。 // ​值（Value）​：当前分组的聚合值（如[总销售额, 最小年龄]）。 // ​操作： // ​插入新分组：当遇到新的分组键时，创建初始值（如COUNT(*)初始为0）。 // ​更新现有分组：当分组已存在时，合并新值（如累加销售额）。 SimpleAggregationHashTable aht_; /** 简单聚合哈希表迭代器 */ // ​作用：遍历聚合哈希表，逐个输出分组结果。 // ​使用场景： // 所有数据处理完毕后，通过迭代器遍历哈希表，生成最终结果。 // 每次调用Next()时，迭代器移动到下一个分组，输出其键和值。 SimpleAggregationHashTable::Iterator aht_iterator_; ////////////////////////////////////////////////////////////////////// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 AggregationExecutor::AggregationExecutor(ExecutorContext *exec_ctx, const AggregationPlanNode *plan, std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; \u0026amp;\u0026amp;child_executor) : AbstractExecutor(exec_ctx), plan_(plan), child_executor_(std::move(child_executor)), // GetAggregates()返回的是agg_exprs_ // 而GetAggregateTypes()返回的是agg_types_。 aht_(plan-\u0026gt;GetAggregates(), plan-\u0026gt;GetAggregateTypes()), aht_iterator_(aht_.Begin()) {} /* 启动数据读取器（如从员工表读数据） 清空抽屉柜（防止旧数据干扰） 逐行处理数据【这里是获取key和value，其中value代表着是这个元组的被聚合的列的数据】 处理特殊情况：没有GROUP BY且无数据时保证输出 设置aht_iterator_指向aht的开头 */ void AggregationExecutor::Init() //{} { child_executor_-\u0026gt;Init();// 启动数据读取器（如从员工表读数据） aht_.Clear();// 清空抽屉柜（防止旧数据干扰） Tuple child_tuple{}; RID rid; // 逐行处理数据 while (child_executor_-\u0026gt;Next(\u0026amp;child_tuple, \u0026amp;rid)) { // 生成keu和对应的value // 将数据合并到对应分组的抽屉： // 如果是新部门（抽屉不存在）→ 创建初始值（如SUM=0，COUNT=0） // 已有部门 → 更新统计值（如SUM累加，COUNT+1） aht_.InsertCombine(MakeAggregateKey(\u0026amp;child_tuple), MakeAggregateValue(\u0026amp;child_tuple)); } // 我猜测，key为空，但数据不为空的时候这里也是能走的，只有？？？？？？？？？？？ // 处理特殊情况：没有GROUP BY且无数据时保证输出 if (aht_.Size() == 0 \u0026amp;\u0026amp; GetOutputSchema().GetColumnCount() == 1) { aht_.InsertEmptyCombine(); } aht_iterator_ = aht_.Begin(); } /* 所有抽屉已遍历，则返回false 组装输出结果【values = 分组标签 + 统计结果; 如[\u0026#34;HR\u0026#34;, 5, 5500]】 *tuple = 打包成数据库表格的一行; */ auto AggregationExecutor::Next(Tuple *tuple, RID *rid) -\u0026gt; bool //{ return false; } { if (aht_iterator_ == aht_.End()) {// 所有抽屉已遍历 return false; } // 组装输出结果 std::vector\u0026lt;Value\u0026gt; values{}; // values = 分组标签 + 统计结果; 如[\u0026#34;HR\u0026#34;, 5, 5500] values.insert(values.end(), aht_iterator_.Key().group_bys_.begin(), aht_iterator_.Key().group_bys_.end()); values.insert(values.end(), aht_iterator_.Val().aggregates_.begin(), aht_iterator_.Val().aggregates_.end()); // *tuple = 打包成数据库表格的一行; *tuple = Tuple{values, \u0026amp;GetOutputSchema()}; *rid = tuple-\u0026gt;GetRid(); ++aht_iterator_; return true; } auto AggregationExecutor::GetChildExecutor() const -\u0026gt; const AbstractExecutor * { return child_executor_.get(); } 2 NestedLoopJoin 2.1 思路 实现内连接和左外连接 左外连接：左边确定找右边，分两种情况：1、找得到：把两个一样的放一块。2、找不到：左边写好右边放null。 内连接：也是左边确定找右边，找到就放value里，找不到就不放。\n2.2 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private: /** 要执行的NestedLoopJoin计划节点。 */ const NestedLoopJoinPlanNode *plan_; ////////////////////////////////////// std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; left_executor_; /** The right child executor */ std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; right_executor_; /** 左孩子的 Next() 结果 */ bool left_ret_; /** 从左孩子获取元组 */ Tuple left_tuple_; /** 该左元组是否已与任何右元组匹配 */ bool left_done_; /////////////////////////////////////// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 NestedLoopJoinExecutor::NestedLoopJoinExecutor(ExecutorContext *exec_ctx, const NestedLoopJoinPlanNode *plan, std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; \u0026amp;\u0026amp;left_executor, std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; \u0026amp;\u0026amp;right_executor) : AbstractExecutor(exec_ctx), plan_(plan), left_executor_(std::move(left_executor)), right_executor_(std::move(right_executor)) { // 检查连接类型，目前仅支持两种： // ​内连接（INNER JOIN）​：只保留匹配的行（如员工A有订单）。 // ​左连接（LEFT JOIN）​：保留左表所有行，右表无匹配时填充NULL（如员工B无订单） if (!(plan-\u0026gt;GetJoinType() == JoinType::LEFT || plan-\u0026gt;GetJoinType() == JoinType::INNER)) { // Note for 2023 Fall: You ONLY need to implement left join and inner join. throw bustub::NotImplementedException(fmt::format(\u0026#34;join type {} not supported\u0026#34;, plan-\u0026gt;GetJoinType())); } } // 输出模式（Output Schema）​：定义最终结果的列顺序和类型。 auto NestedLoopJoinExecutor::LeftAntiJoinTuple(Tuple *left_tuple) -\u0026gt; Tuple { //左连接 std::vector\u0026lt;Value\u0026gt; values{};// 存储合并后的结果 // reserve(100)后，size还是原来的，但capacity至少为100。而resize(100)则可能增加元素，size变为100。 // reserve只是预留空间，不创建对象，而resize会创建对象 values.reserve(GetOutputSchema().GetColumnCount()); // 1. 遍历左表的所有列，添加到结果中 for (uint32_t idx = 0; idx \u0026lt; left_executor_-\u0026gt;GetOutputSchema().GetColumnCount(); idx++) { values.push_back(left_tuple-\u0026gt;GetValue(\u0026amp;left_executor_-\u0026gt;GetOutputSchema(), idx)); } // 2. 遍历右表的所有列，填充 NULL 值 //对于左连接中不存在的列，添加 NULL 值 for (uint32_t idx = 0; idx \u0026lt; right_executor_-\u0026gt;GetOutputSchema().GetColumnCount(); idx++) { // 获取右表元组中的值，但由于左连接中不存在右表的元组，因此添加 NULL 值 values.push_back(ValueFactory::GetNullValueByType(plan_-\u0026gt;GetRightPlan()-\u0026gt;OutputSchema().GetColumn(idx).GetType())); } return Tuple{values, \u0026amp;GetOutputSchema()}; } ////////////////////////////////////////////// auto NestedLoopJoinExecutor::InnerJoinTuple(Tuple *left_tuple, Tuple *right_tuple) -\u0026gt; Tuple { //内连接 std::vector\u0026lt;Value\u0026gt; values{}; values.reserve(GetOutputSchema().GetColumnCount()); // 1. 遍历左表的所有列，添加到结果中 for (uint32_t idx = 0; idx \u0026lt; left_executor_-\u0026gt;GetOutputSchema().GetColumnCount(); idx++) { values.push_back(left_tuple-\u0026gt;GetValue(\u0026amp;left_executor_-\u0026gt;GetOutputSchema(), idx)); } // 2. 遍历右表的所有列，添加到结果中 for (uint32_t idx = 0; idx \u0026lt; right_executor_-\u0026gt;GetOutputSchema().GetColumnCount(); idx++) { // （idx表示第几列），所以下面这个函数的意思是获取该元组第idx列的值 values.push_back(right_tuple-\u0026gt;GetValue(\u0026amp;right_executor_-\u0026gt;GetOutputSchema(), idx)); } return Tuple{values, \u0026amp;GetOutputSchema()}; } /* 启动左表扫描（如员工表） 启动右表扫描（如订单表） 读取左表第一行，标记左表当前行是否处理完毕 */ ////////////////////////////////////////////// void NestedLoopJoinExecutor::Init()// { throw NotImplementedException(\u0026#34;NestedLoopJoinExecutor is not implemented\u0026#34;); } {////////////////////////////////////////////// left_executor_-\u0026gt;Init();// 启动左表扫描（如员工表） right_executor_-\u0026gt;Init();// 启动右表扫描（如订单表） RID left_rid; left_ret_ = left_executor_-\u0026gt;Next(\u0026amp;left_tuple_, \u0026amp;left_rid);// 读取左表第一行 left_done_ = false;// 标记左表当前行是否处理完毕 }////////////////////////////////////////////// /* 进入循环，直到返回结果或者遍历结束 如果左表中的元组已经遍历完毕，返回 false，表示没有更多的结果了 如果右表中的元组已经遍历完毕 如果是左连接且左表中的当前元组还没有匹配到右表的任何元组 生成左连接结果中不存在右表元组的元组 获取元组的 RID 标记左表中的当前元组已经处理过 返回 true，表示找到了一个结果 重新初始化右表的扫描，以便重新开始扫描右表 获取下一个左表中的元组，重置 left_done_ 标志 继续循环，尝试下一个左表中的元组 利用 JOIN 条件判断左右表中的元组是否满足条件 如果左右表中的元组满足 JOIN 条件 生成内连接结果的元组 获取元组的 RID 标记左表中的当前元组已经处理过 返回 true，表示找到了一个结果 */ auto NestedLoopJoinExecutor::Next(Tuple *tuple, RID *rid) -\u0026gt; bool //{ return false; } {////////////////////////////////////////////// Tuple right_tuple{}; // 用于存储右表中的元组 RID left_rid; // 左表中当前元组的 RID RID right_rid; // 右表中当前元组的 RID while (true) { // 进入循环，直到返回结果或者遍历结束 if (!left_ret_) { // 如果左表中的元组已经遍历完毕 return false; // 返回 false，表示没有更多的结果了 } if (!right_executor_-\u0026gt;Next(\u0026amp;right_tuple, \u0026amp;right_rid)) { // 如果右表中的元组已经遍历完毕 if (plan_-\u0026gt;GetJoinType() == JoinType::LEFT \u0026amp;\u0026amp; !left_done_) { // 如果是左连接且左表中的当前元组还没有匹配到右表的任何元组 *tuple = LeftAntiJoinTuple(\u0026amp;left_tuple_); // 生成左连接结果中不存在右表元组的元组 *rid = tuple-\u0026gt;GetRid(); // 获取元组的 RID left_done_ = true; // 标记左表中的当前元组已经处理过 return true; // 返回 true，表示找到了一个结果 } right_executor_-\u0026gt;Init(); // 重新初始化右表的扫描，以便重新开始扫描右表 left_ret_ = left_executor_-\u0026gt;Next(\u0026amp;left_tuple_, \u0026amp;left_rid); // 获取下一个左表中的元组 left_done_ = false; // 重置 left_done_ 标志 continue; // 继续循环，尝试下一个左表中的元组 } // 利用 JOIN 条件判断左右表中的元组是否满足条件 auto ret = plan_-\u0026gt;Predicate()-\u0026gt;EvaluateJoin( \u0026amp;left_tuple_, left_executor_-\u0026gt;GetOutputSchema(), \u0026amp;right_tuple, right_executor_-\u0026gt;GetOutputSchema()); // 如果左右表中的元组满足 JOIN 条件 if (!ret.IsNull() \u0026amp;\u0026amp; ret.GetAs\u0026lt;bool\u0026gt;()) { *tuple = InnerJoinTuple(\u0026amp;left_tuple_, \u0026amp;right_tuple); // 生成内连接结果的元组 *rid = tuple-\u0026gt;GetRid(); // 获取元组的 RID left_done_ = true; // 标记左表中的当前元组已经处理过 return true; // 返回 true，表示找到了一个结果 } } }////////////////////////////////////////////// task2 完成后，sql语句的7-12就都可以测试了\n任务 #3 - HashJoin 执行程序和优化 您将在以下文件中完成实施：\nsrc/include/execution/hash_join_executor.h src/execution/hash_join_executor.cpp src/optimizer/nlj_as_hash_join.cpp 1、HashJoin 1.1 思路 哈希连接包括两个阶段：构建（build）阶段和探测（probe）阶段。\n构建阶段：遍历右表，将每个元组的连接键哈希并存储在哈希表中。 探测阶段：遍历左表，对表中的每个元组进行哈希，并在哈希表中查找具有相同哈希值的条目。由于右表可能有好几个和左表匹配的选项，所以还需要一个迭代器\n其中需要注意，如果是左连接，没找到对应哈希值要把左边对应的右边写null。如果是内连接，跳过下一个。\n1.2 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 /////////////////////////////////////////////////////////////////////////////// /** HashJoinKeyrepresents a key in an join operation */ // 快递单号（用于匹配包裹） struct HashJoinKey { std::vector\u0026lt;Value\u0026gt; hash_keys_;// 存储连接字段的值（如订单ID） /** * Compares two hash joi keys for equality * @param other the other hash join key to be compared with * @return `true` if both hash join key have equivalent values */ auto operator==(const HashJoinKey \u0026amp;other) const -\u0026gt; bool { // 比较两个对象的hash_keys_成员中的每个Value对象是否相等 for (uint32_t i = 0; i \u0026lt; other.hash_keys_.size(); ++i) { if (hash_keys_[i].CompareEquals(other.hash_keys_[i]) != CmpBool::CmpTrue) { return false; } } return true; } }; } // namespace bustub namespace std { /** Implements std::hash on AggregateKey */ template \u0026lt;\u0026gt; // 根据键构建计算哈希表 struct hash\u0026lt;bustub::HashJoinKey\u0026gt; { auto operator()(const bustub::HashJoinKey \u0026amp;join_key) const -\u0026gt; std::size_t { size_t curr_hash = 0; for (const auto \u0026amp;key : join_key.hash_keys_) { if (!key.IsNull()) { // 对每一个非空的value对象，计算出它的哈希值 curr_hash = bustub::HashUtil::CombineHashes(curr_hash, bustub::HashUtil::HashValue(\u0026amp;key)); } } return curr_hash; } }; } // namespace std namespace bustub { /** * A simplified hash table that has all the necessary functionality for join. */ // 分拣货架（按单号分区域存放包裹） class SimpleHashJoinHashTable { public: /** 插入join key和tuple构建hash表 */ /* 包裹入库 */ void InsertKey(const HashJoinKey \u0026amp;join_key, const Tuple \u0026amp;tuple) { // 没有这个键 if (ht_.count(join_key) == 0) { std::vector\u0026lt;Tuple\u0026gt; tuple_vector; tuple_vector.push_back(tuple); // 添加键和对应的值 ht_.insert({join_key, tuple_vector}); } else { // 有这个键 ht_.at(join_key).push_back(tuple); } } /** 获取该join key对应的tuple */ auto GetValue(const HashJoinKey \u0026amp;join_key) -\u0026gt; std::vector\u0026lt;Tuple\u0026gt; * { if (ht_.find(join_key) == ht_.end()) {// 没有这个键 return nullptr; } // 返回键对应的值 return \u0026amp;(ht_.find(join_key)-\u0026gt;second); } /** * Clear the hash table */ void Clear() { ht_.clear(); } private: /** The hash table is just a map from aggregate keys to aggregate values */ std::unordered_map\u0026lt;HashJoinKey, std::vector\u0026lt;Tuple\u0026gt;\u0026gt; ht_{}; }; /////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////// auto GetLeftJoinKey(const Tuple *tuple) -\u0026gt; HashJoinKey { std::vector\u0026lt;Value\u0026gt; values; // 获取左表的键 for (const auto \u0026amp;expr : plan_-\u0026gt;LeftJoinKeyExpressions()) { values.emplace_back(expr-\u0026gt;Evaluate(tuple, left_child_-\u0026gt;GetOutputSchema())); } return {values}; } auto GetRightJoinKey(const Tuple *tuple) -\u0026gt; HashJoinKey { std::vector\u0026lt;Value\u0026gt; values; // 获取右表的键 for (const auto \u0026amp;expr : plan_-\u0026gt;RightJoinKeyExpressions()) { values.emplace_back(expr-\u0026gt;Evaluate(tuple, right_child_-\u0026gt;GetOutputSchema())); } return {values}; }//////////////////////////////////////// //////////////////////////////////////// // 遍历哈希表的迭代器 std::vector\u0026lt;Tuple\u0026gt;::iterator jht_iterator_; // 哈希表 std::unique_ptr\u0026lt;SimpleHashJoinHashTable\u0026gt; jht_; // 指向左表的执行器对象 std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; left_child_; // 指向右表的执行器对象 std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; right_child_; Tuple left_tuple_{}; RID left_rid_{}; std::vector\u0026lt;Tuple\u0026gt; *right_tuple_{nullptr}; bool has_done_; // 用来判断左边还有没有符合要求的元组 bool left_bool_; //////////////////////////////////////// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 HashJoinExecutor::HashJoinExecutor(ExecutorContext *exec_ctx, const HashJoinPlanNode *plan, std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; \u0026amp;\u0026amp;left_child, std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; \u0026amp;\u0026amp;right_child) : AbstractExecutor(exec_ctx) { //===----------------------------------------------------------------------===// this-\u0026gt;plan_ = plan; this-\u0026gt;left_child_ = std::move(left_child); this-\u0026gt;right_child_ = std::move(right_child); //===----------------------------------------------------------------------===// if (!(plan-\u0026gt;GetJoinType() == JoinType::LEFT || plan-\u0026gt;GetJoinType() == JoinType::INNER)) { // Note for 2023 Fall: You ONLY need to implement left join and inner join. throw bustub::NotImplementedException(fmt::format(\u0026#34;join type {} not supported\u0026#34;, plan-\u0026gt;GetJoinType())); } } /* 初始化左右plan的左右孩子 获取左执行器符合条件的元组，left_bool_用于判断左执行器是否还有符合条件的元组(即是否取完元组) 构建哈希表【jht_】，遍历子执行器，将右子执行器中的获取的数据插入到join哈希表中 获取左侧元组的hash key，然后在哈希表中查找与左侧元组匹配的右侧元组 不为空说明找到了哈希值一样的，标记为true，防止next函数中重复输出 否则， 标记为false，主要用于左连接没有匹配的情况 */ void HashJoinExecutor::Init() {//===----------------------------------------------------------------------===// // 初始化左右plan的左右孩子 this-\u0026gt;left_child_-\u0026gt;Init(); this-\u0026gt;right_child_-\u0026gt;Init(); // 获取左执行器符合条件的元组，left_bool_用于判断左执行器是否还有符合条件的元组(即是否取完元组) left_bool_ = left_child_-\u0026gt;Next(\u0026amp;left_tuple_, \u0026amp;left_rid_); // NEXT方法的輸出參數，用于存储查询结果 Tuple right_tuple{}; RID right_rid{}; //构建哈希表 jht_ = std::make_unique\u0026lt;SimpleHashJoinHashTable\u0026gt;(); // 遍历子执行器，将右子执行器中的获取的数据插入到join哈希表中 // 不能在HashJoinExecutor执行器的next中完成，因为执行器需要先从子执行器中获取所有数据，然后对这些数据进行join，最后才能产生输出结果 while (right_child_-\u0026gt;Next(\u0026amp;right_tuple, \u0026amp;right_rid)) { jht_-\u0026gt;InsertKey(GetRightJoinKey(\u0026amp;right_tuple), right_tuple); } // 获取左侧元组的hash key auto left_hash_key = GetLeftJoinKey(\u0026amp;left_tuple_); // 在哈希表中查找与左侧元组匹配的右侧元组 right_tuple_ = jht_-\u0026gt;GetValue(left_hash_key); //这里必须判断right_tuple_是否为空，否则指针会指向空地址报错 // 不为空说明找到了哈希值一样的 if (right_tuple_ != nullptr) { jht_iterator_ = right_tuple_-\u0026gt;begin(); // 标记为true，防止next函数中重复输出 has_done_ = true; } else { // 标记为false，主要用于左连接没有匹配的情况 has_done_ = false; } }//===----------------------------------------------------------------------===// /* 创建一个while循环【如果是内连接，如果没有匹配的元组，则该轮不输出任何元组，不需要返回值，继续往下查找其他左元组】 如果right_tuple_不为空【即在init中找到了】，且jht_iterator_未遍历完【即一个左边匹配多个右边】，则遍历输出 先把左边的元组放入到values中 然后把右边的元组放入到values中【连接操作右边元组的值均不为null，且不包含重复的那列】 如果right_tuple_为空【没找到】，或者jht_iterator_遍历完，且为左连接 如果has_done_为false，则说明左连接没有匹配的元组，需要输出右元组为null的情况 连接操作右边元组的值均为null 如果不是左连接，或者为左连接，但有有效输出，则继续遍历下一个左元组进行匹配 左边找下一个数据 但如果left_bool_为false，左边找完了，返回false，结束 反之，更新左边的key，在哈希表中查找与左侧元组匹配的右侧元组 */ auto HashJoinExecutor::Next(Tuple *tuple, RID *rid) -\u0026gt; bool {//===----------------------------------------------------------------------===// // 用while的原因：如果是内连接，如果没有匹配的元组，则该轮不输出任何元组，不需要返回值，继续往下查找其他左元组 while (true) { // 如果right_tuple_不为空，且jht_iterator_未遍历完，则遍历输出 // 一个左边可能匹配多个右边 if (right_tuple_ != nullptr \u0026amp;\u0026amp; jht_iterator_ != right_tuple_-\u0026gt;end()) { std::vector\u0026lt;Value\u0026gt; values; auto right_tuple = *jht_iterator_; for (uint32_t i = 0; i \u0026lt; this-\u0026gt;left_child_-\u0026gt;GetOutputSchema().GetColumnCount(); i++) { values.emplace_back(left_tuple_.GetValue(\u0026amp;this-\u0026gt;left_child_-\u0026gt;GetOutputSchema(), i)); } // 连接操作右边元组的值均不为null for (uint32_t i = 0; i \u0026lt; this-\u0026gt;right_child_-\u0026gt;GetOutputSchema().GetColumnCount(); i++) { values.emplace_back(right_tuple.GetValue(\u0026amp;this-\u0026gt;right_child_-\u0026gt;GetOutputSchema(), i)); } *tuple = Tuple{values, \u0026amp;GetOutputSchema()}; ++jht_iterator_; return true; } // 如果right_tuple_为空，或者jht_iterator_遍历完，且为左连接 // 如果has_done_为false，则说明左连接没有匹配的元组，需要输出右元组为null的情况 if (plan_-\u0026gt;GetJoinType() == JoinType::LEFT \u0026amp;\u0026amp; !has_done_) { std::vector\u0026lt;Value\u0026gt; values; for (uint32_t i = 0; i \u0026lt; this-\u0026gt;left_child_-\u0026gt;GetOutputSchema().GetColumnCount(); i++) { values.emplace_back(left_tuple_.GetValue(\u0026amp;this-\u0026gt;left_child_-\u0026gt;GetOutputSchema(), i)); } // 连接操作右边元组的值均为null for (uint32_t i = 0; i \u0026lt; this-\u0026gt;right_child_-\u0026gt;GetOutputSchema().GetColumnCount(); i++) { values.emplace_back( ValueFactory::GetNullValueByType(this-\u0026gt;right_child_-\u0026gt;GetOutputSchema().GetColumn(i).GetType())); } *tuple = Tuple{values, \u0026amp;GetOutputSchema()}; has_done_ = true; return true; } // 如果不是左连接，或者为左连接，但有有效输出，则继续遍历下一个左元组进行匹配 // 如果left_bool_为false，左边找完了 left_bool_ = left_child_-\u0026gt;Next(\u0026amp;this-\u0026gt;left_tuple_, \u0026amp;this-\u0026gt;left_rid_); if (!left_bool_) { return false; } // 重置右边匹配的元组，以及更新迭代器 auto left_hash_key = GetLeftJoinKey(\u0026amp;left_tuple_); // 在哈希表中查找与左侧元组匹配的右侧元组 right_tuple_ = jht_-\u0026gt;GetValue(left_hash_key); if (right_tuple_ != nullptr) { jht_iterator_ = right_tuple_-\u0026gt;begin(); has_done_ = true; } else { has_done_ = false; } } }//===----------------------------------------------------------------------===// 2 NestedLoopJoin优化为HashJoin 2.1 思路 查询计划是从下往上的树形结构，所以要现在做下面再搞上面（用递归实现） 注意：要检查每个等值条件两侧的列属于哪个表。 步骤： 1、把子节点用递归的方式添加到 optimized_children 列表中 2、用 CloneWithChildren 方法克隆原始计划，并用优化后的子节点替换原始的子节点。这样即使实际没优化成，也说明尝试优化过了 3、看优化为hashjoin的条件满不满足 4、满足则换，不满足输出原计划\n2.2 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 ////////////////////////////////// //这段代码的主要功能是解析一个包含多个条件的连接谓词，并提取出用于哈希连接的左右连接键表达式。 //它通过递归处理逻辑表达式（如 AND）和识别比较表达式（如 //=）来实现这一点，从而为优化器提供必要的信息以转换嵌套循环连接为哈希连接。 // 解析一个逻辑表达式，并提取出左右两侧的关键表达式 /* 这里是要把条件语句里的条件进行分类【A.id = B.id AND A.name = B.name拆分成俩个集合，每个集合存放着对应的条件】 尝试将谓词转换为逻辑表达式，与或非（类似把and变成\u0026amp; ？？？这里变换后是什么形式不清楚，但是并不太重要） 递归分解AND条件：将A.id = B.id AND A.name = B.name拆分为两个独立条件 尝试将谓词转换为比较表达式，识别等值比较：仅处理=操作符的比较表达式 如果是比较表达式 区分左右表列：通过TupleIdx判断列属于左表（0）还是右表（1） 区分每个数据元素是从左侧表还是右侧表提取的，例如 A.id = B.id时，系统需要知道 A.id 和 B.id 分别属于哪个数据源 */ void ParseAndExpression(const AbstractExpressionRef \u0026amp;predicate, std::vector\u0026lt;AbstractExpressionRef\u0026gt; *left_key_expressions, std::vector\u0026lt;AbstractExpressionRef\u0026gt; *right_key_expressions) { // 尝试将谓词转换为逻辑表达式，与或非（类似把and变成\u0026amp; ？？？） auto *logic_expression_ptr = dynamic_cast\u0026lt;LogicExpression *\u0026gt;(predicate.get()); // 递归处理逻辑逻辑表达式 // 递归分解AND条件：将A.id = B.id AND A.name = B.name拆分为两个独立条件 if (logic_expression_ptr != nullptr) { // left child ParseAndExpression(logic_expression_ptr-\u0026gt;GetChildAt(0), left_key_expressions, right_key_expressions); // right child ParseAndExpression(logic_expression_ptr-\u0026gt;GetChildAt(1), left_key_expressions, right_key_expressions); } // 尝试将谓词转换为比较表达式 // 识别等值比较：仅处理=操作符的比较表达式 auto *comparison_ptr = dynamic_cast\u0026lt;ComparisonExpression *\u0026gt;(predicate.get()); // 如果是比较表达式 if (comparison_ptr != nullptr) { auto column_value_1 = dynamic_cast\u0026lt;const ColumnValueExpression \u0026amp;\u0026gt;(*comparison_ptr-\u0026gt;GetChildAt(0)); // auto column_value_2 = dynamic_cast\u0026lt;const ColumnValueExpression \u0026amp;\u0026gt;(*comparison_ptr-\u0026gt;GetChildAt(1)); // ​区分左右表列：通过TupleIdx判断列属于左表（0）还是右表（1） // 区分每个数据元素是从左侧表还是右侧表提取的，例如 A.id = B.id时，系统需要知道 A.id 和 B.id 分别属于哪个数据源 if (column_value_1.GetTupleIdx() == 0) { left_key_expressions-\u0026gt;emplace_back(comparison_ptr-\u0026gt;GetChildAt(0)); right_key_expressions-\u0026gt;emplace_back(comparison_ptr-\u0026gt;GetChildAt(1)); } else { left_key_expressions-\u0026gt;emplace_back(comparison_ptr-\u0026gt;GetChildAt(1)); right_key_expressions-\u0026gt;emplace_back(comparison_ptr-\u0026gt;GetChildAt(0)); } } }////////////////////////////////// /* 索引优化这部分的代码基本都是一个思路，只要把顺序查找那边的优化看明白了，这里也就很简单了。 递归优化子节点 若当前节点是嵌套循环连接，则替换为哈希连接 获取谓词，提取等值连接条件中的左右键 提取左右两侧关键表达式，分别放到left_key_expressions和right_key_expressions里) 创建哈希连接计划节点 返回optimized_plan【这个情况是不为嵌套循环连接或者是优化失败】 */ auto Optimizer::OptimizeNLJAsHashJoin(const AbstractPlanNodeRef \u0026amp;plan) -\u0026gt; AbstractPlanNodeRef { // TODO(student): implement NestedLoopJoin -\u0026gt; HashJoin optimizer rule // Note for 2023 Fall: You should support join keys of any number of conjunction of equi-condistions: // E.g. \u0026lt;column expr\u0026gt; = \u0026lt;column expr\u0026gt; AND \u0026lt;column expr\u0026gt; = \u0026lt;column expr\u0026gt; AND ... //return plan; ////////////////////////////////// std::vector\u0026lt;AbstractPlanNodeRef\u0026gt; optimized_children; for (const auto \u0026amp;child : plan-\u0026gt;GetChildren()) { // 递归优化子节点 optimized_children.emplace_back(OptimizeNLJAsHashJoin(child)); } auto optimized_plan = plan-\u0026gt;CloneWithChildren(std::move(optimized_children)); // 若当前节点是嵌套循环连接，则替换为哈希连接 if (optimized_plan-\u0026gt;GetType() == PlanType::NestedLoopJoin) { const auto \u0026amp;join_plan = dynamic_cast\u0026lt;const NestedLoopJoinPlanNode \u0026amp;\u0026gt;(*optimized_plan); // 获取谓词 auto predicate = join_plan.Predicate(); // 提取等值连接条件中的左右键 std::vector\u0026lt;AbstractExpressionRef\u0026gt; left_key_expressions; std::vector\u0026lt;AbstractExpressionRef\u0026gt; right_key_expressions; // 提取左右两侧关键表达式，分别放到left_key_expressions和right_key_expressions里) ParseAndExpression(predicate, \u0026amp;left_key_expressions, \u0026amp;right_key_expressions); // 创建哈希连接计划节点 return std::make_shared\u0026lt;HashJoinPlanNode\u0026gt;(join_plan.output_schema_, join_plan.GetLeftPlan(), join_plan.GetRightPlan(), left_key_expressions, right_key_expressions, join_plan.GetJoinType()); } return optimized_plan; ////////////////////////////////// } 这个完成后可以运行SQLLogicTests - #14 和#15.\n任务 #4：排序 + 限制执行程序 + 窗口函数 + Top-N 优化 您将在以下文件中完成实施：\nsrc/include/execution/sort_executor.h src/execution/sort_executor.cpp src/include/execution/limit_executor.h src/execution/limit_executor.cpp src/include/execution/topn_executor.h src/execution/topn_executor.cpp src/include/execution/window_function_executor.h src/execution/window_function_executor.cpp src/optimizer/sort_limit_as_topn.cpp 1、Sort 1.1 思路 要求：默认升序 Init函数把元组顺序排好。Next函数从开始位置一个个输出\n1.2 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 //===----------------------------------------------------------------------===// // 用于排序的比较器 class Comparator { public: Comparator() { schema_ = nullptr; } Comparator(const Schema *schema, std::vector\u0026lt;std::pair\u0026lt;OrderByType, AbstractExpressionRef\u0026gt;\u0026gt; order_bys) : schema_(schema), order_bys_(std::move(order_bys)) {} // 比较两个元组的排序规则 auto operator()(const Tuple \u0026amp;t1, const Tuple \u0026amp;t2) -\u0026gt; bool { // 遍历所有排序条件（如ORDER BY age DESC, name ASC） for (auto const \u0026amp;order_by : this-\u0026gt;order_bys_) { const auto order_type = order_by.first; // 使用Evaluate获取值 AbstractExpressionRef expr = order_by.second; // 计算两个元组在该字段的值（如年龄字段值） Value v1 = expr-\u0026gt;Evaluate(\u0026amp;t1, *schema_); Value v2 = expr-\u0026gt;Evaluate(\u0026amp;t2, *schema_); // 比较逻辑 // if (值相等) 继续比较下一个字段; // if (升序) 返回v1是否小于v2; // else 返回v1是否大于v2; if (v1.CompareEquals(v2) == CmpBool::CmpTrue) { continue; } // 如果是升序（ASC 或 DEFAULT），比较 v1 是否小于 v2（CompareLessThan） if (order_type == OrderByType::ASC || order_type == OrderByType::DEFAULT) { return v1.CompareLessThan(v2) == CmpBool::CmpTrue; } // 如果是降序（DESC），比较 v1 是否大于 v2（CompareGreaterThan） return v1.CompareGreaterThan(v2) == CmpBool::CmpTrue; } // 两个元组所有键都相等 return false; } private: const Schema *schema_; // 两个参数：升序还是降序，用那个键的值 std::vector\u0026lt;std::pair\u0026lt;OrderByType, AbstractExpressionRef\u0026gt;\u0026gt; order_bys_; }; //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; child_executor_; std::vector\u0026lt;Tuple\u0026gt; tuples_; std::vector\u0026lt;Tuple\u0026gt;::iterator iter_; //===----------------------------------------------------------------------===// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // ​图书馆整理书籍 的比喻，来理解这个排序执行器的工作原理。 // 假设你是一个图书管理员，现在需要把一堆乱序的书籍按照「先按书名字母顺序，再按出版年份倒序」的规则整理好 SortExecutor::SortExecutor(ExecutorContext *exec_ctx, const SortPlanNode *plan, std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; \u0026amp;\u0026amp;child_executor) : AbstractExecutor(exec_ctx)// {} { this-\u0026gt;plan_ = plan;// 拿到整理说明书 this-\u0026gt;child_executor_ = std::move(child_executor);// 接收送书机器人 } /* 初始化字执行器 将要排序的表里的元组都提取出来 获取排序字段 用sort进行排序 */ void SortExecutor::Init() //{ throw NotImplementedException(\u0026#34;SortExecutor is not implemented\u0026#34;); } { child_executor_-\u0026gt;Init();// 启动送书机器人 Tuple tuple{}; RID rid{}; // 步骤1：收集所有书籍 while (child_executor_-\u0026gt;Next(\u0026amp;tuple, \u0026amp;rid)) { tuples_.emplace_back(tuple); } // 获取排序字段 // std::vector\u0026lt;std::pair\u0026lt;OrderByType, AbstractExpressionRef\u0026gt;\u0026gt; order_bys auto order_by = plan_-\u0026gt;GetOrderBy(); // 排序 std::sort(tuples_.begin(), tuples_.end(), Comparator(\u0026amp;this-\u0026gt;GetOutputSchema(), order_by)); iter_ = tuples_.begin(); } /* 按顺序依次返回排完序后的元组【一次返回一个】 调用的时候返回，从头到尾一个个返回 */ auto SortExecutor::Next(Tuple *tuple, RID *rid) -\u0026gt; bool //{ return false; } { // 调用的时候返回，从头到尾一个个返回 if (iter_ != tuples_.end()) { *tuple = *iter_; ++iter_; return true; } return false; } 2、Limit Executors 2.1 思路 要求： 限制元组（记录或行）的数量。没什么说的。\n2.2 代码\n1 2 3 4 //////////////////////////////////// std::vector\u0026lt;Tuple\u0026gt; tuples_; std::vector\u0026lt;Tuple\u0026gt;::iterator iter_; //////////////////////////////////// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 LimitExecutor::LimitExecutor(ExecutorContext *exec_ctx, const LimitPlanNode *plan, std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; \u0026amp;\u0026amp;child_executor) : AbstractExecutor(exec_ctx)// {} { this-\u0026gt;plan_ = plan; this-\u0026gt;child_executor_ = std::move(child_executor); } /* 初始化子执行器 从plan中获取限制的元组数 获取符合条件数量的元组（即没达到限制且能获取到下一元组） 要是tuples_不为空，则让iter_指向tuples_的开头 */ void LimitExecutor::Init()// { throw NotImplementedException(\u0026#34;LimitExecutor is not implemented\u0026#34;); } { child_executor_-\u0026gt;Init(); std::size_t count = 0; // 获取限制的元组数 auto limit = plan_-\u0026gt;GetLimit(); Tuple tuple{}; RID rid{}; // 获取符合条件数量的元组（没达到限制且能获取到下一元组） while (count \u0026lt; limit \u0026amp;\u0026amp; child_executor_-\u0026gt;Next(\u0026amp;tuple, \u0026amp;rid)) { count++; tuples_.emplace_back(tuple); } if (!tuples_.empty()) { iter_ = tuples_.begin(); } } /* 在限制数量内，调用函数后，依次返回一个元组 要是超出限制的数量后，返回false，表示失败。 */ auto LimitExecutor::Next(Tuple *tuple, RID *rid) -\u0026gt; bool //{ return false; } { if (!tuples_.empty() \u0026amp;\u0026amp; iter_ != tuples_.end()) { *tuple = *iter_; iter_++; return true; } return false; } 3、Top-N Optimization 3.1 思路\n这里实现的是sort和limit这俩个的结合使用，效率比分别单独使用sort和limit要高\n它的原理是实现动态保存前n个大（或者小）的元组 ，遍历完整个表的数据之后，保留最后的答案；这样可以实现动态维护前n大或者小的元组数，可以在插入后以最小的代码维护sort和limit的结果。\n比较器的实现和sort里的Comparator是一样的。\nInit函数里用\n1 2 std::priority_queue\u0026lt;Tuple, std::vector\u0026lt;Tuple\u0026gt;, HeapComparator\u0026gt; heap( HeapComparator(\u0026amp;this-\u0026gt;GetOutputSchema(), plan_-\u0026gt;GetOrderBy())); 定义一个可以排序的（HeapComparator实现）、存储top-n元组的堆\n3.2 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 //===----------------------------------------------------------------------===// // 用于排序的比较器 class HeapComparator { public: HeapComparator() { schema_ = nullptr; } HeapComparator(const Schema *schema, std::vector\u0026lt;std::pair\u0026lt;OrderByType, AbstractExpressionRef\u0026gt;\u0026gt; order_bys) : schema_(schema), order_bys_(std::move(order_bys)) {} // 这里是仿函数机制，以下是示例 // class Counter { // private: // int count = 0; // public: // int operator()() { // return ++count; // } // }; // int main() { // Counter c1, c2; // std::cout \u0026lt;\u0026lt; c1(); // 1 // std::cout \u0026lt;\u0026lt; c2(); // 1（每个对象独立维护状态） // } auto operator()(const Tuple \u0026amp;t1, const Tuple \u0026amp;t2) -\u0026gt; bool { for (auto const \u0026amp;order_by : this-\u0026gt;order_bys_) { const auto order_type = order_by.first; // 使用Evaluate获取值 AbstractExpressionRef expr = order_by.second; Value v1 = expr-\u0026gt;Evaluate(\u0026amp;t1, *schema_); Value v2 = expr-\u0026gt;Evaluate(\u0026amp;t2, *schema_); if (v1.CompareEquals(v2) == CmpBool::CmpTrue) { continue; } // 如果是升序（ASC 或 DEFAULT），比较 v1 是否小于 v2（CompareLessThan） if (order_type == OrderByType::ASC || order_type == OrderByType::DEFAULT) { return v1.CompareLessThan(v2) == CmpBool::CmpTrue; } // 如果是降序（DESC），比较 v1 是否大于 v2（CompareGreaterThan） return v1.CompareGreaterThan(v2) == CmpBool::CmpTrue; } // 两个元组所有键都相等 return false; } private: const Schema *schema_; // 两个参数：升序还是降序，用那个键的值 std::vector\u0026lt;std::pair\u0026lt;OrderByType, AbstractExpressionRef\u0026gt;\u0026gt; order_bys_; }; //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// // 按順序存储优先队列中的tuple /** The stack to store sorted top-n tuple*/ std::stack\u0026lt;Tuple\u0026gt; top_entries_; size_t heap_size_{0}; //===----------------------------------------------------------------------===// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 TopNExecutor::TopNExecutor(ExecutorContext *exec_ctx, const TopNPlanNode *plan, std::unique_ptr\u0026lt;AbstractExecutor\u0026gt; \u0026amp;\u0026amp;child_executor) : AbstractExecutor(exec_ctx) //{} { this-\u0026gt;plan_ = plan; this-\u0026gt;child_executor_ = std::move(child_executor); } /* 使用优先队列存储topN，升序用大顶堆，降序用小顶堆 遍历子执行器，将子执行器返回的元组加入优先队列 因為只需要topN个元组，所以当优先队列大小大于topN时，弹出堆顶元组 （如果是升序，堆顶是最大的元组，如果是降序，堆顶是最小的元组） 升序场景：需保留最小的N个元素 → ​使用最大堆​（堆顶是当前最大的元素）。 降序场景：需保留最大的N个元素 → ​使用最小堆​（堆顶是当前最小的元素）。 */ void TopNExecutor::Init() { child_executor_-\u0026gt;Init(); //使用优先队列存储topN，升序用大顶堆，降序用小顶堆 std::priority_queue\u0026lt;Tuple, std::vector\u0026lt;Tuple\u0026gt;, HeapComparator\u0026gt; heap( HeapComparator(\u0026amp;this-\u0026gt;GetOutputSchema(), plan_-\u0026gt;GetOrderBy())); Tuple tuple{}; RID rid{}; //遍历子执行器，将子执行器返回的元组加入优先队列 while (child_executor_-\u0026gt;Next(\u0026amp;tuple, \u0026amp;rid)) { heap.push(tuple); heap_size_++; //因為只需要topN个元组，所以当优先队列大小大于topN时，弹出堆顶元组 // （如果是升序，堆顶是最大的元组，如果是降序，堆顶是最小的元组） // 升序场景：需保留最小的N个元素 → ​使用最大堆​（堆顶是当前最大的元素）。 // ​降序场景：需保留最大的N个元素 → ​使用最小堆​（堆顶是当前最小的元素）。 if (heap.size() \u0026gt; plan_-\u0026gt;GetN()) { heap.pop(); heap_size_--; } } while (!heap.empty()) { this-\u0026gt;top_entries_.push(heap.top()); heap.pop(); } } /* 判断top_entries_是否为空 空：结束，返回false 不为空：弹出顶部元组，返回ture，结束 */ auto TopNExecutor::Next(Tuple *tuple, RID *rid) -\u0026gt; bool //{ return false; } { if (top_entries_.empty()) { return false; } *tuple = top_entries_.top(); top_entries_.pop(); return true; } auto TopNExecutor::GetNumInHeap() -\u0026gt; size_t //{ throw NotImplementedException(\u0026#34;TopNExecutor is not implemented\u0026#34;); }; { return top_entries_.size(); } 3.3 优化 要求： 将带有 ORDER BY + LIMIT 子句的查询转换为使用 TopNExecutor 优化的实现和前面优化成hashjoin的有点像 步骤： 1、把子节点用递归的方式添加到 optimized_children 列表中 2、用 CloneWithChildren 方法克隆原始计划，并用优化后的子节点替换原始的子节点。这样即使实际没优化成，也说明尝试优化过了 3、看优化为Top-N的条件满不满足，即有没有limit+orderby 4、满足就换，不满足输出原计划\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // ​数据库执行计划：数据库处理SQL查询时，会生成一个由多个节点组成的树状结构（类似工厂流水线），每个节点负责特定操作（如排序、过滤）。 // 示例：SELECT * FROM table ORDER BY age LIMIT 10会被解析为Sort→Limit计划 // ​优化器作用：通过改写执行计划，让查询更快、更省资源（如同快递路线规划，找到最优路径）。 // ​TopN优势：直接取前N条数据，比\u0026#34;全排序后截取\u0026#34;更高效（类似直接从成绩单中找前10名，不用给全班排完整名次）。 /* 递归处理所有子节点（树状结构需要逐层优化） 生成优化后的新计划节点（携带已优化的子节点） 判断当前节点是否是\u0026#34;Limit+Sort\u0026#34;组合 创建更高效的TopN节点，替换原有结构 非Limit+Sort组合则保持原样【return optimized_plan;】 */ auto Optimizer::OptimizeSortLimitAsTopN(const AbstractPlanNodeRef \u0026amp;plan) -\u0026gt; AbstractPlanNodeRef {//return plan; // TODO(student): implement sort + limit -\u0026gt; top N optimizer rule // 对所有子节点递归应用这一优化 std::vector\u0026lt;bustub::AbstractPlanNodeRef\u0026gt; optimized_children; // 1. 递归处理所有子节点（树状结构需要逐层优化） for (const auto \u0026amp;child : plan-\u0026gt;GetChildren()) { optimized_children.emplace_back(OptimizeSortLimitAsTopN(child)); } // 2. 生成优化后的新计划节点（携带已优化的子节点） auto optimized_plan = plan-\u0026gt;CloneWithChildren(std::move(optimized_children)); // 3. 判断当前节点是否是\u0026#34;Limit+Sort\u0026#34;组合 // 查询解析的层级关系 // SQL 查询的语法顺序是 SELECT → ORDER BY → LIMIT，但执行计划的生成顺序是 ​自底向上 的： // 先对数据源进行排序（生成 SORT 节点）， // 再在排序结果上应用行数限制（生成 LIMIT 节点）。 // ​示例：SELECT * FROM table ORDER BY age LIMIT 10 的执行计划树为 LIMIT → SORT → TABLE_SCAN if (optimized_plan-\u0026gt;GetType() == PlanType::Limit) { const auto \u0026amp;limit_plan = dynamic_cast\u0026lt;const LimitPlanNode \u0026amp;\u0026gt;(*optimized_plan); auto child = optimized_plan-\u0026gt;children_[0];// 获取Limit的子节点 if (child-\u0026gt;GetType() == PlanType::Sort) {// 子节点是Sort const auto \u0026amp;sort_plan = dynamic_cast\u0026lt;const SortPlanNode \u0026amp;\u0026gt;(*child); // 4. 创建更高效的TopN节点，替换原有结构 // output_schema_-》输出结构不变 // children_[0] 子节点（Sort的子节点） // GetOrderBy 继承排序规则 // limit_ 继承行数限制 return std::make_shared\u0026lt;TopNPlanNode\u0026gt;(optimized_plan-\u0026gt;output_schema_, optimized_plan-\u0026gt;children_[0], sort_plan.GetOrderBy(), limit_plan.limit_); } } // 非Limit+Sort组合则保持原样 return optimized_plan; } 4、Window Functions 4.1 思路 看下官方介绍:https://15445.courses.cs.cmu.edu/fall2023/project3/#optimizer-guide,很详细了 不想写了，我要出去玩。要是有人看，帮我写了我粘上去吧\n4.2 代码\n最后放个满分截图。有的地方明后天有空再完善下，没空算了。\n参考文章： CMU 15-445 数据库导论 proj3(上) Query Execution 实现具体的SQL语句_哔哩哔哩_bilibili\nCMU 15-445 Bustub 2023-Fall Project 3 Query Execution 思路分享 - 知乎\ncmu15445 2023fall project3 详细过程（上）QUERY EXECUTION_cmu15445 2023 fall project 3-CSDN博客\n丯是幡动-CSDN博客\ncmu15445 2023fall project3 详细过程（下）QUERY EXECUTION-CSDN博客\nCMU15445 (Fall 2023) Project 3 - Query Execution 思路分享_cmu15445 2023fall project3-CSDN博客\nCMU15-445 2023 Fall Project0~4 通关总结 - 知乎\n做个数据库：2022 CMU15-445 Project3 Query Execution - 知乎\nBusTub 养成记：从课程项目到 SQL 数据库 - 知乎\nCMU15-445 2023 Fall Project#3 - Query Execution - 知乎\n","date":"2024-11-11T15:29:00+08:00","permalink":"https://1878247293.github.io/p/cmu15445-2023-fall-p3/","title":"cmu15445 2023 fall   p3"},{"content":"1.转到此处 在您的账户下创建新存储库。选择一个名称（例如 ），然后选择 Private 作为仓库可见性级别。bustub-private\n2.在开发计算机上，创建公有 BusTub 存储库的裸克隆：\n1 $ git clone --bare https://github.com/cmu-db/bustub.git bustub-public 3.接下来，将公有 BusTub 存储库镜像到您自己的私有 BusTub 存储库。假设您的 GitHub 名称是student ，仓库名称是 bustub-private。镜像存储库的过程是：这会将公有 BusTub 存储库中的所有内容复制到您自己的私有存储库。您现在可以删除公有仓库的本地克隆：\n1 2 3 4 5 6 7 8 9 10 11 12 13 $ cd bustub-public # If you pull / push over HTTPS $ git push https://github.com/student/bustub-private.git master #这里现在已经不能用普通的密码登录，需要用token #详细见这个博客：https://blog.csdn.net/weixin_49614712/article/details/141129442 # If you pull / push over SSH $ git push git@github.com:student/bustub-private.git master #详细见这个博客：https://blog.csdn.net/jiunian_2761/article/details/122907766 #关于github想要了解更多的话，就参考这个文章 https://zhuanlan.zhihu.com/p/193140870 1 2 $ cd .. $ rm -rf bustub-public 4.将私有仓库克隆到开发计算机：\n1 2 3 4 5 # If you pull / push over HTTPS $ git clone https://github.com/student/bustub-private.git # If you pull / push over SSH $ git clone git@github.com:student/bustub-private.git Linux（推荐）/ macOS（仅限开发） 要确保您的计算机上有正确的软件包，请运行以下脚本以自动安装它们：\n1 2 3 # Linux $ sudo build_support/packages.sh #chmod +x build_support/packages.sh 这里可能会没有权限导致找不到文件，使用这句话添加权限 然后运行以下命令来构建系统：\n1 2 3 4 5 6 ￥ rm -rf build $ mkdir build $ cd build $ cmake .. # chmod +x /root/bustub-pubilc/build_support/cpplint.py同上 $ make 这里可用make -j 4 加速 注意： 修改一下Cmake，不然不出意外会抛一个warning：\u0026quot;!! We recommend that you use clang-12 for developing BusTub. You\u0026rsquo;re using xxx, which is not clang.\u0026quot;。字符串里填的是你自己clang的安装地址。\nset(CMAKE_C_COMPILER \u0026ldquo;/usr/bin/clang\u0026rdquo;) set(CMAKE_CXX_COMPILER \u0026ldquo;/usr/bin/clang++\u0026rdquo;)\n要是有其他问题的话，可参考以下（我所参考过的）文件\nCMU15445（2023 Spring） lab - 环境配置_cmu的15445的lab-CSDN博客\n（全网最详细！！！）CMU15-445（Fall 2023）——从环境搭建开始的P0详细历程及踩坑经历_cmu15445-CSDN博客\n[CMU15445-2023Fall，Lab0 C++Primer 个人流程记录-CSDN博客](https://blog.csdn.net/EQUINOX1/article/details/142740875?ops_request_misc=%7B%22request%5Fid%22%3A%2283adc256f0232def1afe12b892ef5e58%22%2C%22scm%22%3A%2220140713.130102334..%22%7D\u0026request_id=83adc256f0232def1afe12b892ef5e58\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-142740875-null-null.142^v101^pc_search_result_base5\u0026utm_term=cmu15445 2023fall\u0026amp;spm=1018.2226.3001.4187)\n","date":"2024-11-11T15:29:00+08:00","permalink":"https://1878247293.github.io/p/cmu15445%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/","title":"cmu15445环境搭建以及使用"},{"content":"一. 参考文章：\n1.csdn的【详细版】ubuntu下的miniob环境编译与调试_miniob ubuntu-CSDN博客\n2.学校给的俩个文档: miniob 实验指导书、miniob项⽬环境搭建\n3.社区官网的git： 1.4 MiniOB Gitee 使用说明-V1.0.0-开发者入门教程文档-分布式数据库使用文档\n二.大体步骤：\nwsl2和Ubuntu参照miniob项⽬环境搭建进行\n注：1.之后的拉取地址均为 git clone https://github.com/oceanbase/miniob.git\n​ 2.cmake通过以下指令进行下载，下载完后需要去设置环境变量，不然无法找到cmake\n1 2 3 4 5 wget https://github.com/Kitware/CMake/releases/download/v3.24.0/cmake-3. 24.0-linux-x86_64.sh bash cmake-3.24.0-linux-x86_64.sh 查看cmake版本: cmake --version 查看cmake位置: which cmake ​ 3.\u0026ldquo;bison\u0026quot;直接在终端通过下载指令下载即可，现在的版本够高，够用（eg：3.7.4版本），\n​ 4.如果没有make的话用指令下载即可\n​ 5.注意有的时候需要梯子，有的时候不需要。所以遇到报错的时候要想到梯子是不是需要关闭/开启\n​ 6.到这一步的时候，输入ctrl shift＋～，再开一个终端，然后切到build目录，再输入下一个指令就行了\n三.可能遇到的问题：\n这个是因为g++和gcc版本不匹配 eg:只更新gcc到11，g++还在9\n","date":"2024-11-11T15:29:00+08:00","permalink":"https://1878247293.github.io/p/miniob2024%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/","title":"miniob2024环境搭建以及使用"},{"content":"找到指定的目录 eg：cd \\home\\\u0026hellip;.\n终端输入 code . 获取某一目录下的代码\n","date":"2024-11-11T15:29:00+08:00","permalink":"https://1878247293.github.io/p/vscode%E9%80%9A%E8%BF%87%E7%BB%88%E7%AB%AF%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%80%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%A0%81/","title":"VScode通过终端获取某一目录下的代码"},{"content":"安装与使用 Windows Subsystem for Linux - WSL 安装 Step1：以管理员的身份打开运行Windows PowerShell，然后执行以下命令（启用适用于Linux的Windows子系统）：\n1 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart `\nStep2:使用Win+R，输入winver查询Windows的相关版本是否符合安装运行WSL2的要求：操作系统的内部版本要大于1903（For x64 systems: Version 1903 or later, with Build 18362 or later.）\nStep3：启用虚拟化，确定虚拟机的特性\n1 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart Step4：打开Microsoft Store，直接搜索wsl，然后选择Linux发行版本进行下载即可，下载完要重启电脑。\nStep5：下载Linux内核的更新升级包并进行安装。（安装包可以在网上自行查找wsl_update_x64.msi)\nStep6：设置WSL2作为默认版本\n1 wsl --set-default-version 2 Step7：下载好后在菜单栏找到Ubuntu双击启动，打开后设置初始的用户名和密码即可，然后就可以使用了。\n参考的CSDN的原文链接：https://blog.csdn.net/weixin_57367513/article/details/135001273\n","date":"2024-11-11T15:29:00+08:00","permalink":"https://1878247293.github.io/p/%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8-windows-subsystem-for-linux-wsl/","title":"安装与使用 Windows Subsystem for Linux - WSL"},{"content":" 将写好的文章连同文件一起放到上面的目录里。\n然后再dev的目录下，输入cmd加回车，跳出命令台：\n三步走： git add .\ngit commit -m \u0026ldquo;这里自己随便起名字\u0026rdquo;\ngit push [origin main] [ 这里的字是可选的，没有影响 ]\n","date":"2024-11-11T15:29:00+08:00","permalink":"https://1878247293.github.io/p/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E6%96%87%E6%A1%A3/","title":"个人博客提交自己写的文档"},{"content":"一. 本次讲解\n​\t管理员查看评论列表、 用户登录后显示商家列表、选择商家进入菜单列表、查看商家评论、商家查看评论\n二. 代码讲解：\n​\t1管理员查看评论列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @app.route(\u0026#39;/adminCommentList\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def adminCommentPage(): msg = \u0026#34;\u0026#34;# 初始化一个空的消息变量 if request.method == \u0026#39;GET\u0026#39;: # 如果请求方法是GET（即加载页面） msg = \u0026#34;\u0026#34;# 重置消息 # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) # 创建一个cursor对象来执行SQL查询 cursor = db.cursor() try: # 尝试使用数据库“appDB” cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 执行SQL查询，获取所有已完成且文本内容不为空的评论 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE isFinished = 1 and text \u0026lt;\u0026gt; \u0026#39;\u0026#39;\u0026#34; # 执行查询 cursor.execute(sql) # 获取查询结果 res = cursor.fetchall() # 如果有查询结果（即有评论） if len(res) != 0: msg = \u0026#34;done\u0026#34; print(msg) return render_template(\u0026#39;adminCommentList.html\u0026#39;, username=username, result=res, messages=msg) else: # 如果没有查询结果（没有评论） print(\u0026#34;NULL\u0026#34;) msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;adminCommentList.html\u0026#39;, username=username, messages=msg) # 如果请求方法是POST（即用户提交了表单） elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按评分升序排列\u0026#34;:# 如果提交的表单动作是\u0026#34;按评分升序排列\u0026#34; db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 执行SQL查询，按评分升序排列获取所有已完成且文本不为空的评论 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE isFinished = 1 AND text is not null Order BY c_rank\u0026#34; cursor.execute(sql) res = cursor.fetchall() print(len(res)) if len(res): #如果有查询结果（即有评论） msg = \u0026#34;done\u0026#34; print(msg) return render_template(\u0026#39;adminCommentList.html\u0026#39;, username=username, result=res, messages=msg) else: # 如果没有查询结果（没有评论） print(\u0026#34;NULL\u0026#34;) msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;adminCommentList.html\u0026#39;, username=username, messages=msg) ​\t2.用户登录后显示商家列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @app.route(\u0026#39;/UserRestList\u0026#39;,methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def UserRestListPage(): msg = \u0026#34;\u0026#34; # 如果请求方法是GET（即加载页面） if request.method == \u0026#39;GET\u0026#39;: msg = \u0026#34;\u0026#34; # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 执行SQL查询，获取所有餐厅信息 sql = \u0026#34;SELECT * FROM RESTAURANT\u0026#34; cursor.execute(sql) res = cursor.fetchall() # 如果有查询结果（即有餐厅数据） if len(res) != 0: msg = \u0026#34;done\u0026#34; print(msg) return render_template(\u0026#39;UserRestList.html\u0026#39;, username=username, result=res, messages=msg) else: # 如果没有查询结果（没有餐厅数据） print(\u0026#34;NULL\u0026#34;) msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;UserRestList.html\u0026#39;, username=username, messages=msg) ​\t3.选择商家进入菜单列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @app.route(\u0026#39;/Menu\u0026#39;,methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def menu(): msg = \u0026#34;\u0026#34; # 声明restaurant为全局变量，方便在不同请求之间共享数据 global restaurant # 如果表单动作是\u0026#34;进入本店\u0026#34; if request.form[\u0026#34;action\u0026#34;] == \u0026#34;进入本店\u0026#34;: # 获取用户选择的餐厅名称 restaurant = request.form[\u0026#39;restaurant\u0026#39;] msg = \u0026#34;\u0026#34; # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询餐厅的所有菜品 sql = \u0026#34;SELECT * FROM DISHES WHERE restaurant = \u0026#39;%s\u0026#39;\u0026#34; % restaurant cursor.execute(sql) res = cursor.fetchall() # 如果有查询结果（即有菜品） if len(res) != 0: msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, result=res, messages=msg) else:# 如果没有查询结果（没有菜品） msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, messages=msg) # 如果表单动作是\u0026#34;特色菜\u0026#34; elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;特色菜\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询餐厅的特色菜（isSpecialty = 1表示是特色菜） sql = \u0026#34;SELECT * FROM DISHES WHERE restaurant = \u0026#39;%s\u0026#39; AND isSpecialty = 1\u0026#34; % restaurant cursor.execute(sql) res = cursor.fetchall() # 如果有查询结果（即有特色菜） if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, result=res, messages=msg) else: # 如果没有查询结果（没有特色菜） msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, messages=msg) # 如果表单动作是\u0026#34;按销量排序\u0026#34; elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按销量排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询餐厅的菜品，并按销量降序排序 sql = \u0026#34;SELECT * FROM DISHES WHERE restaurant = \u0026#39;%s\u0026#39; Order BY sales DESC\u0026#34; % restaurant cursor.execute(sql) res = cursor.fetchall() # 如果有查询结果（即有菜品） if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, result=res, messages=msg) else: # 如果没有查询结果（没有菜品） msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, messages=msg) # 如果表单动作是\u0026#34;按价格排序\u0026#34; elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按价格排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询餐厅的菜品，并按价格降序排序 sql = \u0026#34;SELECT * FROM DISHES WHERE restaurant = \u0026#39;%s\u0026#39; Order BY price DESC\u0026#34; % restaurant cursor.execute(sql) res = cursor.fetchall() if len(res): # 如果有查询结果（即有菜品） msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, result=res, messages=msg) else: # 如果没有查询结果（没有菜品） msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, messages=msg) ​\t4.查看商家评论\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @app.route(\u0026#39;/ResComment\u0026#39;,methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def resComment(): msg = \u0026#34;\u0026#34; global restaurant # 如果表单动作是\u0026#34;查看评价\u0026#34; if request.form[\u0026#34;action\u0026#34;] == \u0026#34;查看评价\u0026#34;: restaurant = request.form[\u0026#39;restaurant\u0026#39;] msg = \u0026#34;\u0026#34; # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询餐厅的已完成评价（isFinished = 1表示评价已完成，text \u0026lt;\u0026gt; \u0026#39;\u0026#39;表示评价内容不为空） sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE restaurant = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text \u0026lt;\u0026gt; \u0026#39;\u0026#39; \u0026#34;% restaurant cursor.execute(sql) res = cursor.fetchall() # 如果查询到评价数据 if len(res) != 0: msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;ResComment.html\u0026#39;, username=username, RESTAURANT=restaurant, result=res, messages=msg) else:# 如果没有查询结果（没有评价数据） msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;ResComment.html\u0026#39;, username=username, RESTAURANT=restaurant, messages=msg) ​\t5.商家查看评论\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @app.route(\u0026#39;/ResCommentList\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def ResCommentList(): msg = \u0026#34;\u0026#34; # 获取当前用户名作为餐厅名称（假设restaurant = username） restaurant=username # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询餐厅的已完成评价（isFinished = 1表示评价已完成，text \u0026lt;\u0026gt; \u0026#39;\u0026#39;表示评价内容不为空） sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE restaurant = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text \u0026lt;\u0026gt; \u0026#39;\u0026#39; \u0026#34; % restaurant cursor.execute(sql) res = cursor.fetchall() # 如果查询到评价数据 if len(res) != 0: msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;ResCommentList.html\u0026#39;, username=username, RESTAURANT=restaurant, result=res,messages=msg) # 如果没有查询结果（没有评价数据） else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;ResCommentList.html\u0026#39;, username=username, RESTAURANT=restaurant, messages=msg) ","date":"2024-11-11T15:24:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E4%B8%89/","title":"外卖订餐系统-（三）"},{"content":"一. 本次讲解\n​\t首页，登陆和注册\n二. 代码讲解：\n​\t1.首页\n1 2 3 4 5 @app.route(\u0026#39;/\u0026#39;) @app.route(\u0026#39;/index\u0026#39;) # 首页路由 def indexpage(): return render_template(\u0026#39;index.html\u0026#39;) ​\t2.注册\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 # 注册页面的路由和逻辑 @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def registerPage(): global username global userRole msg = \u0026#34;\u0026#34; # GET方法返回注册页面 if request.method == \u0026#39;GET\u0026#39;: return render_template(\u0026#39;Register.html\u0026#39;) # POST方法处理注册逻辑 if request.method == \u0026#39;POST\u0026#39;: username = request.form.get(\u0026#39;username\u0026#39;) password = request.form.get(\u0026#39;password\u0026#39;) phone = request.form.get(\u0026#39;phone\u0026#39;) addr = request.form.get(\u0026#39;addr\u0026#39;) userRole = request.form.get(\u0026#39;userRole\u0026#39;) print(userRole) print(username) # 连接数据库，默认数据库用户名root，密码空 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) # 根据用户角色分别注册 if userRole == \u0026#39;RESTAURANT\u0026#39;:#商家 cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 检查商家是否已存在 sql1 = \u0026#34;SELECT * from RESTAURANT where username = \u0026#39;{}\u0026#39; \u0026#34;.format(username) cursor.execute(sql1) db.commit() res1 = cursor.fetchall() num = 0 for row in res1: num = num + 1 # 如果商家已注册，返回注册失败信息 if num == 1: print(\u0026#34;失败！商家已注册！\u0026#34;) msg = \u0026#34;fail1\u0026#34; else: # 插入新商家记录 sql2 = \u0026#34;insert into RESTAURANT (username, password, address, phone) values (\u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;) \u0026#34;.format(username, password, addr, phone) try: cursor.execute(sql2) db.commit() print(\u0026#34;商家注册成功\u0026#34;) msg = \u0026#34;done1\u0026#34; except ValueError as e: print(\u0026#34;---\u0026gt;\u0026#34;, e) print(\u0026#34;注册出错，失败\u0026#34;) msg = \u0026#34;fail1\u0026#34; return render_template(\u0026#39;Register.html\u0026#39;, messages=msg, username=username, userRole=userRole) elif userRole == \u0026#39;CUSTOMER\u0026#39;:#客户 cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 检查客户是否已存在 sql1 = \u0026#34;SELECT * from CUSTOMER where username = \u0026#39;{}\u0026#39;\u0026#34;.format(username) cursor.execute(sql1) db.commit() res1 = cursor.fetchall() num = 0 for row in res1: num = num + 1 # 如果用户已注册，返回注册失败信息 if num == 1: print(\u0026#34;用户已注册！请直接登录。\u0026#34;) msg = \u0026#34;fail2\u0026#34; else:# 插入新用户记录 sql2 = \u0026#34;insert into CUSTOMER (username, password, address, phone) values (\u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;) \u0026#34;.format(username, password, addr, phone) try: cursor.execute(sql2) db.commit() print(\u0026#34;商家注册成功\u0026#34;) msg = \u0026#34;done2\u0026#34; except ValueError as e: print(\u0026#34;---\u0026gt;\u0026#34;, e) print(\u0026#34;注册出错，失败\u0026#34;) msg = \u0026#34;fail2\u0026#34; return render_template(\u0026#39;Register.html\u0026#39;, messages=msg, username=username, userRole=userRole) ​\t3.登陆\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 # 登录页面的路由和逻辑 @app.route(\u0026#39;/logIn\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def logInPage(): global username global userRole msg = \u0026#34;\u0026#34; # GET方法返回登陆页面 if request.method == \u0026#39;GET\u0026#39;: return render_template(\u0026#39;logIn.html\u0026#39;) # POST方法处理登陆逻辑 if request.method == \u0026#39;POST\u0026#39;: username = request.form.get(\u0026#39;username\u0026#39;) password = request.form.get(\u0026#39;password\u0026#39;) userRole = request.form.get(\u0026#39;userRole\u0026#39;) print(userRole) print(username) # 连接数据库，默认数据库用户名root，密码空 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) if userRole == \u0026#39;ADMIN\u0026#39;:#管理员 cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) sql = \u0026#34;SELECT * from ADMIN where username = \u0026#39;{}\u0026#39; and password=\u0026#39;{}\u0026#39;\u0026#34;.format(username, password) cursor.execute(sql) db.commit() res = cursor.fetchall() num = 0 for row in res: num = num + 1 # 如果存在该管理员且密码正确 if num == 1: print(\u0026#34;登录成功！欢迎管理员！\u0026#34;) msg = \u0026#34;done1\u0026#34; else: print(\u0026#34;您没有管理员权限或登录信息出错。\u0026#34;) msg = \u0026#34;fail1\u0026#34; return render_template(\u0026#39;logIn.html\u0026#39;, messages=msg, username=username, userRole=userRole) elif userRole == \u0026#39;RESTAURANT\u0026#39;:#商家 cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) sql = \u0026#34;SELECT * from RESTAURANT where username = \u0026#39;{}\u0026#39; and password=\u0026#39;{}\u0026#39;\u0026#34;.format(username, password) cursor.execute(sql) db.commit() res = cursor.fetchall() num = 0 for row in res: num = num + 1 # 如果存在该商家且密码正确 if num == 1: print(\u0026#34;登录成功！欢迎商家用户！\u0026#34;) msg = \u0026#34;done2\u0026#34; else: print(\u0026#34;您没有商家用户权限或登录信息出错。\u0026#34;) msg = \u0026#34;fail2\u0026#34; return render_template(\u0026#39;logIn.html\u0026#39;, messages=msg, username=username, userRole=userRole) elif userRole == \u0026#39;CUSTOMER\u0026#39;:#用户 cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) sql = \u0026#34;SELECT * from CUSTOMER where username = \u0026#39;{}\u0026#39; and password=\u0026#39;{}\u0026#39;\u0026#34;.format(username, password) cursor.execute(sql) db.commit() res = cursor.fetchall() num = 0 for row in res: num = num + 1 # 如果存在该用户且密码正确 if num == 1: print(\u0026#34;登录成功！欢迎用户！\u0026#34;) msg = \u0026#34;done3\u0026#34; else: print(\u0026#34;您没有用户权限，未注册或登录信息出错。\u0026#34;) msg = \u0026#34;fail3\u0026#34; return render_template(\u0026#39;logIn.html\u0026#39;, messages=msg, username=username, userRole=userRole) ","date":"2024-11-11T14:37:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E4%BA%8C/","title":"外卖订餐系统-（二）"},{"content":"一. 项目描述\n​\t本项目用于数据库实验课选做项目的大作业，基于python实现外卖订餐系统\n二. 代码讲解：\n1 2 3 4 5 6 7 from flask import Flask, render_template, request, redirect, url_for, flash from werkzeug.utils import secure_filename import pymysql import os import argparse import sys import importlib 代码引入了 Flask（用于创建 Web 应用）、render_template（渲染 HTML 页面）、request（处理请求）、redirect 和 url_for（页面跳转）、flash（闪现消息）、secure_filename（用于安全保存上传的文件名），以及 pymysql（用于连接和操作 MySQL 数据库）。\n1 2 3 4 # 重新加载sys模块配置 importlib.reload(sys) app = Flask(__name__) importlib.reload(sys)：重新加载 sys 模块，通常用于确保加载的是最新版本，或者在修改模块时使用。\napp = Flask(__name__)：创建一个 Flask 应用实例，__name__ 用于确定应用的根路径，方便管理路由和静态文件。\n1 2 3 4 # MySQL配置变量 mysql_pwd = \u0026#34;6021123456\u0026#34; db_name = \u0026#34;appdb\u0026#34; port = 3340 用于数据库连接的配置信息，依次是我的密码，数据库名和mysql的端口号\n1 2 3 4 # 全局变量 username = \u0026#34;\u0026#34; userRole = \u0026#34;\u0026#34; notFinishedNum = 0 全局变量，用来处理总体的信息\nusername变量的赋值\n方法1：全局变量实现，随登录进行修改 方法2：给每个页面传递username\n1 2 3 4 5 6 7 # 设置文件上传目录和允许的扩展名 UPLOAD_FOLDER = \u0026#39;/static/images/\u0026#39; ALLOWED_EXTENSIONS = set([ \u0026#39;png\u0026#39;, \u0026#39;jpg\u0026#39;, \u0026#39;jpeg\u0026#39;]) # 检查上传文件的扩展名是否合法 def allowed_file(filename): return \u0026#39;.\u0026#39; in filename and \\ filename.rsplit(\u0026#39;.\u0026#39;, 1)[1] in ALLOWED_EXTENSIONS 设置文件上传目录和允许的扩展名\n检查上传文件的扩展名是否合法\n","date":"2024-11-11T14:22:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E4%B8%80/","title":"外卖订餐系统-（一）"},{"content":"一. 问题描述\n删除文件的时候只能永久删除，而无法放入回收站。\n二.解决方法：\n查阅大量资料后，最终的方法如下：\n​\t1.使用 Windows + R 快捷键打开「运行」对话框，执行 control folders 命令打开「文件夹选项」，有的 Windows 版本中也叫「文件资源管理器选项」。\n​\t2.切换到「查看」菜单，在「高级设置」中： 取消勾选「隐藏受保护的操作系统文件（推荐）」 选择「显示隐藏的文件、文件夹和驱动器」。 设置文件资源管理器选项 。\n​\t3.点击「确定」应用并关闭窗口。\n​\t4.打开C盘和D盘的文件夹，分别将$recycle.bin 文件夹删掉（运行回收站的时候会自动生成这个文件夹，所以不用担心）\n","date":"2024-11-10T22:26:00+08:00","permalink":"https://1878247293.github.io/p/%E5%9B%9E%E6%94%B6%E7%AB%99%E6%97%A0%E6%B3%95%E6%94%BE%E5%85%A5%E6%96%87%E4%BB%B6/","title":"回收站无法放入文件"},{"content":"一. 实习总结\n本次实习完成的任务是通过java代码来实现对krb5的调用、获取TGT以及能手动更改TGT的有效时间。\n二. 实习收获：\n作为第一次的实习，大部分时间都用来熟悉工作环境和工作流程以及查阅一些关于krb5的资料。\n通过本次实习，我了解到了：\n如何ssh远程调用虚拟机来进行调试\nGit的提交和推送操作\nNginx对Restful API接口进行https的操作处理\n了解到了大致的工作分工的模式以及情况\n对于工作之间的交接和交流也有了一定的经验\n三. 实习所学到的知识：\n学到了如下：\n初步了解到了javaweb关于后端和redis、mysql（crud）的相关知识\n初步了解到springboot框架、restful接口以及对他们的使用经验\n实操的git的常用操作\n实操了JWT的操作\n对于nginx也有了初步的认识和使用经验\n学会了idea通过ssh进行远程操作的步骤\n四．工具详情：\n通过提供用户的用户名和密码、以及邮箱和TGT的有效时间等等可以获取到krb5的TGT。\n难点分析：\n相比于其它热门知识来讲，网上资料过少，了解的难度过大\n设置TGT的有效时间时，这里通过创建临时文件的方式，但却存在补充下加载配置的问题。最后查阅了多天的资料后，以及不断的尝试，发现的解决的方法（jaas.conf）\n","date":"2024-11-10T20:50:00+08:00","permalink":"https://1878247293.github.io/p/java%E8%BF%9C%E7%A8%8B%E9%93%BE%E6%8E%A5krb5/","title":"Java远程链接krb5"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://1878247293.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://1878247293.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://1878247293.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://1878247293.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://1878247293.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://1878247293.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://1878247293.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://1878247293.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://1878247293.github.io/p/emoji-support/","title":"Emoji Support"}]