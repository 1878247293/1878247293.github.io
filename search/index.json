[{"content":"一. 本次讲解\n​\tsql语句以及相关的建表的操作和设计思路\n二. 代码讲解：\n​\t1.创建数据库appDB\n1 2 3 -- 创建数据库 appDB 并切换到此数据库 CREATE DATABASE appDB; USE appDB; 创建并且使用数据库appDB ​\t2.管理员表\n1 2 3 4 5 6 7 8 9 10 -- 创建 ADMIN 表，用于存储管理员账户信息 CREATE TABLE `ADMIN`( `username` CHAR(15) PRIMARY KEY,-- 用户名，主键 `password` CHAR(12) NOT NULL-- 密码，不能为空 )ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 向 ADMIN 表插入管理员账户信息 INSERT INTO `ADMIN` VALUES (\u0026#39;root\u0026#39;,\u0026#39;12345678\u0026#39;); -- 查看 ADMIN 表中所有记录 SELECT* FROM ADMIN; 存储管理员的账号和密码字段（username, password）。 主要用于应用的后台管理。 主键：username。 ​\t3.用户表\n1 2 3 4 5 6 7 8 9 10 11 12 13 -- 创建 CUSTOMER 表，用于存储顾客账户信息 CREATE TABLE `CUSTOMER`( `username` CHAR(15) PRIMARY KEY,-- 用户名，主键 `password` CHAR(12) NOT NULL,-- 密码，不能为空 `address` VARCHAR(30) NOT NULL,-- 顾客地址，不能为空 `phone` CHAR(15) NOT NULL-- 顾客手机号，不能为空 )ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 向 CUSTOMER 表插入顾客账户信息 INSERT INTO `CUSTOMER` VALUES (\u0026#39;lonelyprince7\u0026#39;,\u0026#39;77777777\u0026#39;,\u0026#39;西南石油大学学生宿舍10-222\u0026#39;,\u0026#39;13844444444\u0026#39;), (\u0026#39;小张\u0026#39;,\u0026#39;55555555\u0026#39;,\u0026#39;西南石油大学学生宿舍17-555\u0026#39;,\u0026#39;18833344444\u0026#39;); -- 查看 CUSTOMER 表中所有记录 SELECT* FROM CUSTOMER; 存储顾客的用户名、密码、地址、电话（username, password, address, phone）。\n顾客可以使用此表与应用进行交互，例如下单、查看菜品等。\n主键：username。\n​\t4.餐馆表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 创建 RESTAURANT 表，用于存储餐馆账户信息 CREATE TABLE `RESTAURANT`( `username` CHAR(15) PRIMARY KEY,-- 餐馆名称，主键 `password` CHAR(12) NOT NULL,-- 餐馆密码，不能为空 `address` VARCHAR(30) NOT NULL,-- 餐馆地址，不能为空 `phone` CHAR(15) NOT NULL,-- 餐馆电话，不能为空 `img_res` VARCHAR(50)-- 餐馆图片路径 )ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 向 RESTAURANT 表插入餐馆账户信息 INSERT INTO `RESTAURANT` VALUES (\u0026#39;土风土味\u0026#39;,\u0026#39;77777777\u0026#39;,\u0026#39;四川省成都市新都区正因村128号\u0026#39;,\u0026#39;1314074\u0026#39;,\u0026#39;static/images/res_2.jpg\u0026#39;), (\u0026#39;统一面馆\u0026#39;,\u0026#39;88888888\u0026#39;,\u0026#39;四川省成都市新都区正熊猫大道69号\u0026#39;,\u0026#39;1884801\u0026#39;,\u0026#39;static/images/res_1.jpg\u0026#39;); -- 查看 RESTAURANT 表中所有记录 SELECT* FROM RESTAURANT; 存储餐馆的用户名、密码、地址、电话、图片路径（username, password, address, phone, img_res）。 每家餐馆都有自己的登录信息，可以管理自己的菜品。 主键：username。 ​\t5.菜品表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -- 创建 DISHES 表，用于存储菜品信息 CREATE TABLE `DISHES`( `dishname` CHAR(15) PRIMARY KEY,-- 菜品名称，主键 `restaurant` CHAR(15) NOT NULL,-- 餐馆名称，外键，不能为空 `dishinfo` VARCHAR(50) , -- 菜品信息 `nutriention` VARCHAR(30),-- 营养信息 `price` DECIMAL(5,2) NOT NULL,-- 价格，不能为空 `sales` INT(5) NOT NULL, -- 销量 `imgsrc` VARCHAR(50), -- 菜品图片路径 `isSpecialty` BOOLEAN, -- 是否为特色菜（布尔类型） FOREIGN KEY (restaurant) REFERENCES RESTAURANT(username)-- 关联到餐馆表的用户名字段 )ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 向 DISHES 表插入菜品信息 INSERT INTO DISHES VALUES (\u0026#39;水煮鱼\u0026#39;, \u0026#39;土风土味\u0026#39;, \u0026#39;松江鲈鱼，巨口细鳞，肉质鲜嫩\u0026#39;, \u0026#39;蛋白质，维生素\u0026#39;, 26.00, 0, \u0026#39;static/images/img_2.jpg\u0026#39;, 0), (\u0026#39;香锅牛肉\u0026#39;, \u0026#39;土风土味\u0026#39;, \u0026#39;该香锅牛肉味道鲜美，有土豆藕片等蔬菜可添加\u0026#39;, \u0026#39;蛋白质，维生素\u0026#39;, 14.50, 0, \u0026#39;static/images/img_5.jpg\u0026#39;, 1), (\u0026#39;牛肉面\u0026#39;, \u0026#39;统一面馆\u0026#39;, \u0026#39;老坛酸菜牛肉面，麻辣酸爽，美味享受\u0026#39;, \u0026#39;蛋白质，淀粉，维生素\u0026#39;, 13.00, 1, \u0026#39;static/images/img_7.jpg\u0026#39;, 0); -- 查看 DISHES 表中所有记录 SELECT* FROM DISHES; 存储各个餐馆的菜品信息，包括菜名、餐馆名称、菜品描述、营养成分、价格、销量、图片路径以及是否是特色菜（dishname, restaurant, dishinfo, nutriention, price, sales, imgsrc, isSpecialty）。 restaurant 字段为外键，关联到 RESTAURANT 表中的 username，以指定每个菜品所属的餐馆。 主键：dishname。 ​\t6.购物车表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -- 创建 SHOPPINGCART 表，用于存储顾客购物车信息 CREATE TABLE `SHOPPINGCART`( `username` CHAR(15),-- 顾客用户名，外键 `restaurant` CHAR(15),-- 餐馆名称，外键 `dishname` CHAR(15),-- 菜品名称，外键 `price` DECIMAL(5,2) NOT NULL,-- 菜品价格 `img_res` VARCHAR(50), -- 菜品图片路径 FOREIGN KEY (username) REFERENCES CUSTOMER(username),-- 关联到顾客表的用户名字段 FOREIGN KEY (restaurant) REFERENCES RESTAURANT(username),-- 关联到餐馆表的用户名字段 FOREIGN KEY (dishname) REFERENCES DISHES(dishname), -- 关联到菜品表的菜品名称字段 PRIMARY KEY (username,restaurant,dishname)-- 联合主键，确保每个顾客、餐馆和菜品的组合唯一 )ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 向 SHOPPINGCART 表插入购物车信息 INSERT INTO `SHOPPINGCART` VALUES (\u0026#39;lonelyprince7\u0026#39;,\u0026#39;土风土味\u0026#39;,\u0026#39;水煮鱼\u0026#39;,26.00,\u0026#39;static/images/img_2.jpg\u0026#39;); -- 查看 SHOPPINGCART 表中所有记录 SELECT* FROM SHOPPINGCART; 追踪顾客加入购物车的菜品信息，包括顾客用户名、餐馆名、菜品名、价格、图片路径（username, restaurant, dishname, price, img_res）。\n外键：\n​\tusername 关联 CUSTOMER 表，表示购物车归属于哪个顾客。\n​\trestaurant 和 dishname 分别关联 RESTAURANT 和 DISHES 表，以指定购物车中的菜品来源。\n复合主键：(username, restaurant, dishname)，确保每个购物车中的条目在顾客、餐馆和菜品的组合下是唯一的。\n​\t7.订单评论表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 -- 创建 ORDER_COMMENT 表，用于存储顾客对订单的评价信息 CREATE TABLE `ORDER_COMMENT`( `orderID` CHAR(15) PRIMARY KEY,-- 订单编号，主键 `username` CHAR(15) NOT NULL,-- 顾客用户名，外键 `restaurant` VARCHAR(15) NOT NULL,-- 餐馆名称，外键 `isFinished` BOOLEAN, -- 订单是否完成（布尔类型） CHECK(isFinished=1 or isFinished =0), -- 检查 isFinished 值必须为 1 或 0 `cost` DECIMAL(5,2) NOT NULL,-- 订单总金额，不能为空 `c_rank` TINYINT(1),-- 评价等级（1-5） CHECK(c_rank BETWEEN 1 AND 5),-- 检查 c_rank 值必须在 1 到 5 之间 `text` VARCHAR(50),-- 评价内容 `transactiontime` TIMESTAMP(0) NOT NULL,-- 交易时间，不能为空 CHECK(transactiontime BETWEEN \u0026#39;1970-01-01 00:00:01\u0026#39; AND \u0026#39;2038-01-19 03:14:07\u0026#39;),-- 检查交易时间在合法范围内 FOREIGN KEY (username) REFERENCES CUSTOMER(username),-- 关联到顾客表的用户名字段 FOREIGN KEY (restaurant) REFERENCES RESTAURANT(username)-- 关联到餐馆表的用户名字段 )ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 向 ORDER_COMMENT 表插入订单评价信息 INSERT INTO ORDER_COMMENT VALUES (\u0026#39;1444000\u0026#39;, \u0026#39;lonelyprince7\u0026#39;, \u0026#39;土风土味\u0026#39;, 1, 26.00, 1, \u0026#39;鱼肉非常不新鲜，不推荐\u0026#39;, \u0026#39;2020-11-7 13:14:07\u0026#39;), (\u0026#39;1445000\u0026#39;, \u0026#39;lonelyprince7\u0026#39;, \u0026#39;土风土味\u0026#39;, 1, 14.50, 3, \u0026#39;牛肉太少，蔬菜太多，希望下次多放点牛肉\u0026#39;, \u0026#39;2020-10-13 20:29:13\u0026#39;), (\u0026#39;1446000\u0026#39;, \u0026#39;小张\u0026#39;, \u0026#39;统一面馆\u0026#39;, 0, 13.00, 5, \u0026#39;分量足，味道好，推荐\u0026#39;, \u0026#39;2020-10-27 15:45:21\u0026#39;); -- 查看 ORDER_COMMENT 表中所有记录 SELECT* FROM ORDER_COMMENT; 存储顾客的订单记录以及评价内容，包括订单 ID、用户名、餐馆名、订单是否完成、花费、评分、评论文本、交易时间（orderID, username, restaurant, isFinished, cost, c_rank, text, transactiontime）。\n外键：\n​\tusername 关联 CUSTOMER 表。\n​\trestaurant 关联 RESTAURANT 表。\n约束条件：\n​\tisFinished 限制为 0 或 1，表示订单未完成或已完成。\n​\tc_rank 限制在 1 到 5 之间，用于评分。\n​\ttransactiontime 需在合法的时间范围内。\n主键：orderID。\n​\t8.简易的ER图\n","date":"2024-11-12T14:12:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E5%85%AB/","title":"外卖订餐系统-（八）"},{"content":"一. 本次讲解\n​\t页面指引、个人中心页面、修改个人信息页面、修改密码页面、商家查看订单、完结\n二. 代码讲解：\n​\t1.页面指引\n1 2 3 4 5 @app.route(\u0026#39;/MerchantIndex\u0026#39;) # 渲染并返回 \u0026#39;MerchantIndex.html\u0026#39; 模板页面 def Merchantindexpage(): return render_template(\u0026#39;MerchantIndex.html\u0026#39;) 此代码段用于定义 Flask Web 应用中的一个路由，使用户能够通过访问 /MerchantIndex 路径来加载并查看 MerchantIndex.html 页面。\n​\t2.个人中心页面\n1 2 3 4 5 # 个人中心页面 @app.route(\u0026#39;/MerchantPersonal\u0026#39;) # 渲染并返回 \u0026#39;MerchantPersonal.html\u0026#39; 模板页面 def MpersonalPage(): return render_template(\u0026#39;MerchantPersonal.html\u0026#39;) 该代码段定义了一个 Flask Web 应用中的路由，使用户能够通过访问 /MerchantPersonal 路径进入商户的个人中心页面 MerchantPersonal.html。\n​\t3.修改个人信息页面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 修改个人信息页面 @app.route(\u0026#39;/MerchantModifyPerInfo\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def MerchantModifyPerInfo(): msg = \u0026#34;\u0026#34; # 如果请求方法为 GET，直接返回页面并传递用户名信息 if request.method == \u0026#39;GET\u0026#39;: return render_template(\u0026#39;MerchantModifyPerInfo.html\u0026#39;, username=username) # 如果请求方法为 POST，处理表单提交的数据 if request.method == \u0026#39;POST\u0026#39;: # 从表单获取用户填写的地址和电话号码信息 address = request.form[\u0026#39;address\u0026#39;] phonenum = request.form[\u0026#39;phonenum\u0026#39;] # 获取上传的图片文件 f = request.files[\u0026#39;imagesrc\u0026#39;] filename = \u0026#39;\u0026#39; # 检查文件名是否符合要求 if f !=\u0026#39;\u0026#39; and allowed_file(f.filename): filename = secure_filename(f.filename) # 保存文件到指定路径 if filename != \u0026#39;\u0026#39;: f.save(\u0026#39;static/images/\u0026#39; + filename) imgsrc = \u0026#39;static/images/\u0026#39; + filename # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 构建更新个人信息的 SQL 语句，根据是否上传图片来选择更新内容 if filename == \u0026#39;\u0026#39;:\t# 如果没有上传图片，仅更新地址和电话信息 sql = \u0026#34;Update {} SET address = \u0026#39;{}\u0026#39;, phone = \u0026#39;{}\u0026#39; where username = \u0026#39;{}\u0026#39;\u0026#34;.format(userRole, address, phonenum,username) else: # 如果有上传图片，更新地址、电话和图片路径 sql = \u0026#34;Update {} SET address = \u0026#39;{}\u0026#39;, phone = \u0026#39;{}\u0026#39;,img_res = \u0026#39;{}\u0026#39; where username = \u0026#39;{}\u0026#39;\u0026#34;.format(userRole, address, phonenum, imgsrc, username) try: cursor.execute(sql) db.commit() msg = \u0026#34;done\u0026#34; except ValueError as e: msg = \u0026#34;fail\u0026#34; return render_template(\u0026#39;MerchantModifyPerInfo.html\u0026#39;, messages=msg, username=username) ​\t该代码段定义了一个 Flask 路由 /MerchantModifyPerInfo，用户可通过此路径修改个人信息。支持 GET 和 POST 两种请求方法：GET 显示页面，POST 处理提交的数据，包括更新地址、电话号码和头像，并将修改后的信息存储到数据库。\n​\t4.修改密码页面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 修改密码页面 @app.route(\u0026#39;/MerchantModifyPwd\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def MerModifyPassword(): msg = \u0026#34;\u0026#34; # 如果请求方法为 GET，直接返回页面并传递用户名信息 if request.method == \u0026#39;GET\u0026#39;: return render_template(\u0026#39;MerchantModifyPwd.html\u0026#39;, username=username) # 如果请求方法为 POST，处理表单提交的数据 if request.method == \u0026#39;POST\u0026#39;: # 从表单获取用户输入的两次密码 psw1 = request.form[\u0026#39;psw1\u0026#39;] psw2 = request.form[\u0026#39;psw2\u0026#39;] # 两次输入密码是否相同 if psw1 == psw2: # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 构建更新密码的 SQL 语句 sql = \u0026#34;Update {} SET password = \u0026#39;{}\u0026#39; where username = \u0026#39;{}\u0026#39;\u0026#34;.format(userRole, psw1, username) try: cursor.execute(sql) db.commit() msg = \u0026#34;done\u0026#34; except ValueError as e: msg = \u0026#34;fail\u0026#34; # 构建更新密码的 SQL 语句 return render_template(\u0026#39;MerchantModifyPwd.html\u0026#39;, messages=msg, username=username) else: # 如果两次输入的密码不一致 msg = \u0026#34;not equal\u0026#34; return render_template(\u0026#39;MerchantModifyPwd.html\u0026#39;, messages=msg, username=username) 该代码段定义了一个 Flask 路由 /MerchantModifyPwd，用户可通过此路径修改个人密码。支持 GET 和 POST 两种请求方法：GET 显示页面，POST 处理密码更新。系统检查两次密码是否一致并更新数据库，最后将操作结果返回页面显示。\n​\t5.商家查看订单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 #商家查看订单 @app.route(\u0026#39;/MerchantOrderPage\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def MerchantOrderPage(): msg = \u0026#34;\u0026#34; # 全局变量，记录未完成订单数量 global notFinishedNum # GET 请求：用于初次加载页面和显示订单信息 if request.method == \u0026#39;GET\u0026#39;: msg = \u0026#34;\u0026#34; # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询未完成订单数量 presql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE restaurant = \u0026#39;%s\u0026#39; AND isFinished = 0\u0026#34; % username cursor.execute(presql) res1 = cursor.fetchall() notFinishedNum = len(res1) # 查询所有订单信息 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE restaurant = \u0026#39;%s\u0026#39;\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() # 判断是否有订单记录 if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, messages=msg) # POST 请求：用于执行特定操作，如排序和过滤订单 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按时间排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询并按时间排序 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; Order BY transactiontime DESC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, result=res, messages=msg, notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, messages=msg) elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按价格排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 按价格升序排序订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; Order BY cost ASC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, messages=msg, notFinishedNum=notFinishedNum) elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;未完成订单\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询未完成订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 0 \u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=len(res)) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, messages=msg, notFinishedNum=notFinishedNum) else: return render_template(\u0026#39;MerchantOrderPage.html\u0026#39;, username=username, messages=msg) 该代码段定义了一个 Flask 路由 /MerchantOrderPage，用户可以通过此路径查看和管理订单。支持 GET 和 POST 请求，通过 POST 可实现按时间和价格排序以及仅查看未完成订单的功能，并将查询结果返回页面显示。\n​\t6.完结\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def parse_args(): \u0026#34;\u0026#34;\u0026#34;解析命令行参数并返回包含这些参数的命名空间对象。 Returns: args: 包含解析后命令行参数的命名空间对象。 \u0026#34;\u0026#34;\u0026#34; # 创建用于解析命令行参数的解析器对象，并为脚本添加描述。 parser = argparse.ArgumentParser(description=__doc__) # 添加MySQL root密码的参数，默认值为“xxxxxxxx”。 parser.add_argument( \u0026#39;--mysql_pwd\u0026#39;, help=\u0026#39;the mysql root password\u0026#39;, default=\u0026#34;xxxxxxxx\u0026#34; ) # 添加要使用的数据库名称参数，默认值为“appdb”。 parser.add_argument( \u0026#39;--db_name\u0026#39;, help=\u0026#39;which database to use\u0026#39;, default=\u0026#34;appdb\u0026#34; ) # 解析用户提供的命令行参数并返回。 args = parser.parse_args() return args if __name__ == \u0026#39;__main__\u0026#39;: # 解析命令行参数以获取MySQL密码和数据库名称。 args = parse_args() # 从解析对象中提取单个参数。 mysql_pwd = args.mysql_pwd db_name = args.db_name # 启动应用程序服务器，在localhost的9090端口上监听 app.run(host=\u0026#39;localhost\u0026#39;, port=\u0026#39;9090\u0026#39;) 用途：该脚本用于解析命令行参数，以便用户指定MySQL密码 (--mysql_pwd) 和数据库名称 (--db_name)，默认值分别为 \u0026quot;xxxxxxxx\u0026quot; 和 \u0026quot;appdb\u0026quot;。\n执行：在运行脚本时，解析命令行参数并将其应用到程序中，启动应用服务器，监听 localhost:9090。\n","date":"2024-11-12T14:12:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E4%B8%83/","title":"外卖订餐系统-（七）"},{"content":"一. 本次讲解\n​\t商家查看菜品信息、商家修改菜品信息、商家添加新菜品\n二. 代码讲解：\n​\t1.商家查看菜品信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #商家查看菜品信息 @app.route(\u0026#39;/MerchantMenu\u0026#39;,methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def MerchantMenu(): msg = \u0026#34;\u0026#34; # 处理 GET 请求：用于显示商家的所有菜品信息 if request.method == \u0026#39;GET\u0026#39;: msg = \u0026#34;\u0026#34; # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询当前商家(username)的所有菜品信息 sql = \u0026#34;SELECT * FROM DISHES WHERE restaurant = \u0026#39;%s\u0026#39;\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() # 如果有查询结果，返回菜品信息页面，显示结果 if len(res) != 0: msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MerchantMenu.html\u0026#39;, username=username, result=res, messages=msg) else: # 如果没有结果，返回页面并显示“无菜品”信息 msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MerchantMenu.html\u0026#39;, username=username, messages=msg) # 处理 POST 请求：用于执行删除菜品或按销量或价格排序 if request.method == \u0026#39;POST\u0026#39;: # 删除指定菜品 if request.form[\u0026#34;action\u0026#34;] == \u0026#34;删除该菜品\u0026#34;: # 获取菜品名称和所属餐厅 dishname = request.form.get(\u0026#39;dishname\u0026#39;) rest = request.form.get(\u0026#39;restaurant\u0026#39;) db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 执行删除操作 sql = \u0026#34;DELETE FROM DISHES where dishname = \u0026#39;{}\u0026#39; and restaurant = \u0026#39;{}\u0026#39;\u0026#34;.format(dishname,rest) try: cursor.execute(sql) db.commit() dmsg = \u0026#34;done\u0026#34; except ValueError as e: dmsg = \u0026#34;fail\u0026#34; return render_template(\u0026#39;MerchantMenu.html\u0026#39;, dishname=dishname, rest=rest, dmessages=dmsg) # 按销量排序显示菜品 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按销量排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 执行查询，按销量从高到低排序 sql = \u0026#34;SELECT * FROM DISHES WHERE restaurant = \u0026#39;%s\u0026#39; Order BY sales DESC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MerchantMenu.html\u0026#39;,username=username, result=res, messages=msg) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MerchantMenu.html\u0026#39;, username=username, messages=msg) # 按价格排序显示菜品 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按价格排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 执行查询，按价格从高到低排序 sql = \u0026#34;SELECT * FROM DISHES WHERE restaurant = \u0026#39;%s\u0026#39; Order BY price DESC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MerchantMenu.html\u0026#39;, username=username, result=res, messages=msg) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MerchantMenu.html\u0026#39;,username=username,messages=msg) ​\t2.商家修改菜品信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #商家修改菜品信息 @app.route(\u0026#39;/MenuModify\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def MenuModify(): msg = \u0026#34;\u0026#34; # 如果操作为“修改菜品信息”，则加载菜品信息修改页面 if request.form[\u0026#34;action\u0026#34;] == \u0026#34;修改菜品信息\u0026#34;: # 从表单获取菜品和商家信息 dishname = request.form[\u0026#39;dishname\u0026#39;]#传递过去菜品名 rest = request.form[\u0026#39;restaurant\u0026#39;]#传递过去商家名 dishinfo = request.form[\u0026#39;dishinfo\u0026#39;] nutriention = request.form.get(\u0026#39;nutriention\u0026#39;) price = request.form.get(\u0026#39;price\u0026#39;) isSpecialty = request.form.get(\u0026#39;isSpecialty\u0026#39;) return render_template(\u0026#39;MenuModify.html\u0026#39;, dishname=dishname, rest=rest, dishinfo=dishinfo, nutriention=nutriention, price=price, username=username, messages=msg,isSpecialty=isSpecialty) # 如果操作为“提交修改”，则执行数据库更新操作 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;提交修改\u0026#34;: # 获取表单中的修改数据 dishname = request.form.get(\u0026#39;dishname\u0026#39;) rest = request.form.get(\u0026#39;rest\u0026#39;) dishinfo = request.form[\u0026#39;dishinfo\u0026#39;] nutriention = request.form.get(\u0026#39;nutriention\u0026#39;) price = request.form.get(\u0026#39;price\u0026#39;) isSpecialty = int(request.form.get(\u0026#39;isSpecialty\u0026#39;)) f = request.files[\u0026#39;imagesrc\u0026#39;] filename = \u0026#39;\u0026#39;# 默认文件名为空 # 检查是否有上传的图片文件且格式允许 if f !=\u0026#39;\u0026#39; and allowed_file(f.filename): filename = secure_filename(f.filename) # 如果有有效文件名，保存文件到指定目录 if filename != \u0026#39;\u0026#39;: f.save(\u0026#39;static/images/\u0026#39; + filename) imgsrc = \u0026#39;static/images/\u0026#39; + filename # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 根据是否有新图片，生成不同的 SQL 语句 if filename == \u0026#39;\u0026#39;: # 没有图片时，不更新图片路径字段 sql = \u0026#34;Update DISHES SET dishinfo = \u0026#39;{}\u0026#39;, nutriention = \u0026#39;{}\u0026#39;, price = {} , isSpecialty = {} where dishname = \u0026#39;{}\u0026#39; and restaurant = \u0026#39;{}\u0026#39;\u0026#34;.format(dishinfo,nutriention,price,isSpecialty,dishname,rest) else: # 有图片时，更新图片路径字段 sql = \u0026#34;Update DISHES SET dishinfo = \u0026#39;{}\u0026#39;, nutriention = \u0026#39;{}\u0026#39;, price = {} ,imgsrc = \u0026#39;{}\u0026#39;, isSpecialty = {} where dishname = \u0026#39;{}\u0026#39; and restaurant = \u0026#39;{}\u0026#39;\u0026#34;.format(dishinfo,nutriention,price,imgsrc,isSpecialty,dishname,rest) try: cursor.execute(sql) #事务中的更改保存到数据库中 db.commit() msg = \u0026#34;done\u0026#34; except ValueError as e: msg = \u0026#34;fail\u0026#34; # 渲染模板，返回修改后的信息 return render_template(\u0026#39;MenuModify.html\u0026#39;,dishname=dishname, rest=rest, username=username, messages=msg) 该路由函数 MenuModify 允许商家修改菜品信息。根据请求表单中的 action 字段，它处理两种操作：\n修改菜品信息： 如果 action 是 \u0026quot;修改菜品信息\u0026quot;，则从表单中获取现有的菜品信息（如描述、营养信息、价格、是否为特色菜等），并将这些信息显示在 MenuModify.html 页面上，以便商家进行编辑。 提交修改： 如果 action 是 \u0026quot;提交修改\u0026quot;，则会使用用户提供的新的菜品信息更新数据库。 如果上传了新图片，也会将图片更新。图片将保存到静态目录中，同时图片路径会存储在数据库中。 构造一个 SQL UPDATE 语句，如果有新图片，则包含新的图片路径。 修改后的信息保存到数据库中，并将操作成功或失败的消息渲染在 MenuModify.html 页面上。 ​\t3.商家添加新菜品\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #商家添加新菜品 @app.route(\u0026#39;/MenuAdd\u0026#39;,methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def MenuAdd(): msg = \u0026#34;\u0026#34; rest= \u0026#34;\u0026#34;# 商家名称变量 # 判断请求表单中的 \u0026#34;action\u0026#34; 字段 if request.form[\u0026#34;action\u0026#34;] == \u0026#34;增加菜品\u0026#34;: rest = request.form[\u0026#39;restaurant\u0026#39;]#传递过去商家名 return render_template(\u0026#39;MenuAdd.html\u0026#39;,rest=rest) elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;确认增加\u0026#34;: # 获取表单中传递的菜品信息 dishname = request.form.get(\u0026#39;dishname\u0026#39;) # 菜品名 rest = request.form.get(\u0026#39;rest\u0026#39;)# 商家名 dishinfo = request.form.get(\u0026#39;dishinfo\u0026#39;)# 菜品描述信息 nutriention = request.form.get(\u0026#39;nutriention\u0026#39;)# 营养信息 price = request.form.get(\u0026#39;price\u0026#39;)# 价格 # 菜品图片文件 f = request.files[\u0026#39;imagesrc\u0026#39;] # 是否特色菜，转为整型 isSpecialty = int(request.form.get(\u0026#39;isSpecialty\u0026#39;)) # 检查图片文件是否有效且格式允许 if f and allowed_file(f.filename): filename = secure_filename(f.filename) f.save(\u0026#39;static/images/\u0026#39; + filename) imgsrc = \u0026#39;static/images/\u0026#39; + filename # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 检查菜品是否已经存在 sql1 = \u0026#34;SELECT * from DISHES where dishname = \u0026#39;{}\u0026#39; \u0026#34;.format(dishname) cursor.execute(sql1) db.commit() res1 = cursor.fetchall() # 计算结果条数，如果有数据，表示菜品已存在 num = 0 for row in res1: num = num + 1 # 如果已经存在该商家 if num == 1:# 如果菜品已经存在，返回失败消息 msg = \u0026#34;fail1\u0026#34; else: # 如果菜品不存在，执行插入操作 sql2 = \u0026#34;insert into DISHES values (\u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;,\u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;,{}, {},\u0026#39;{}\u0026#39;, {}) \u0026#34;.format(dishname,rest,dishinfo,nutriention,price,0,imgsrc,isSpecialty) try: cursor.execute(sql2) db.commit() msg = \u0026#34;done\u0026#34; except ValueError as e: msg = \u0026#34;fail\u0026#34; return render_template(\u0026#39;MenuAdd.html\u0026#39;, messages=msg, username=username) 该路由函数 MenuAdd 处理商家添加新菜品的操作，支持以下两个主要功能：\n显示添加菜品页面： 如果请求的 action 为 \u0026quot;增加菜品\u0026quot;，则根据商家名称加载 MenuAdd.html 页面，准备输入菜品信息。 提交添加的菜品： 如果 action 为 \u0026quot;确认增加\u0026quot;，则获取提交的菜品信息（如菜品名、描述、营养信息、价格、特色菜状态以及图片）。 检查数据库中是否已经存在同名菜品，如果存在，则返回错误消息。 如果菜品不存在，程序会将新菜品信息插入到数据库中，并保存上传的图片。 根据添加结果显示成功或失败消息。 ​\n","date":"2024-11-12T00:42:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E5%85%AD/","title":"外卖订餐系统-（六）"},{"content":"一. 本次讲解\n​\t管理用户的订单评价、查看并管理待评价订单、处理用户对订单的评论操作\n二. 代码讲解：\n​\t1.管理用户的订单评价\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #管理用户的订单评价 @app.route(\u0026#39;/MyComments\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def MyCommentsPage(): msg = \u0026#34;\u0026#34; # 全局变量，记录未完成或未评价订单数量 global notFinishedNum # 处理 GET 请求，显示用户评论页面 if request.method == \u0026#39;GET\u0026#39;: msg = \u0026#34;\u0026#34; # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询已完成但未评价的订单数量 presql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text = \u0026#39;\u0026#39; \u0026#34; % username cursor.execute(presql) #将 cursor.execute(sql) 返回的所有结果行提取出来 res1 = cursor.fetchall() # 记录未评价订单数量 notFinishedNum = len(res1) # 查询已完成且已评价的订单信息 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; and isFinished = 1 and text \u0026lt;\u0026gt; \u0026#39;\u0026#39; \u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MyComments.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MyComments.html\u0026#39;, username=username, messages=msg) #按时间排序 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按时间排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 按时间排序已完成且已评价的订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text is not null Order BY transactiontime DESC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MyComments.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MyComments.html\u0026#39;, username=username, messages=msg) #按价格排序 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按价格排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询按价格升序排序的订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text is not null Order BY cost ASC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() # 渲染页面并传入结果 if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;MyComments.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;MyComments.html\u0026#39;, username=username, messages=msg, notFinishedNum=notFinishedNum) #待评价订单 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;待评价订单\u0026#34;: # 查看未评价的订单并跳转到写评论页面 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询所有已完成但未评价的订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text = \u0026#39;\u0026#39; \u0026#34; % username cursor.execute(sql) res = cursor.fetchall() # 渲染写评论页面并传入结果 if len(res): msg = \u0026#34;done\u0026#34; print(msg) return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=len(res)) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, messages=msg, notFinishedNum=len(res)) # 返回到该界面 else: return render_template(\u0026#39;MyComments.html\u0026#39;, username=username, messages=msg) 此代码实现了一个 /MyComments 路由，用于管理用户的订单评价。它提供了多种排序和筛选功能，帮助用户查看并管理其已完成和已评价的订单。\n作用 显示用户的已评价订单：查询已完成且已评价的订单，并在页面中显示。 按时间或价格排序：用户可以选择按时间或价格对已评价的订单进行排序。 查看待评价订单：筛选出用户已完成但未评价的订单，并跳转到“写评论”页面，方便用户进行评价。 ​\t2.查看并管理待评价订单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #查看并管理待评价订单 @app.route(\u0026#39;/WriteComments\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def WriteCommentsPage(): msg=\u0026#34;\u0026#34; # GET 请求：显示待评价订单 if request.method == \u0026#39;GET\u0026#39;: # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询用户已完成但未评价的订单信息 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text = \u0026#39;\u0026#39; \u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; print(msg) return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, result=res, messages=msg) else: print(\u0026#34;WriteCommentsPage - GET - NULL\u0026#34;) msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, messages=msg) # 按交易时间排序 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按交易时间排序\u0026#34;: # TODO: 排序之后显示的是空的，不显示的问题没有解决 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询用户未评价订单按交易时间降序排列 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text = \u0026#39;\u0026#39; Order BY transactiontime DESC\u0026#34; % username cursor.execute(sql) # 获取查询结果 res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, result=res, messages=msg) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, messages=msg) # 按价格排序 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按价格排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询用户未评价订单按价格升序排列 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text = \u0026#39;\u0026#39; Order BY cost ASC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, messages=msg, notFinishedNum=notFinishedNum) # 未完成订单 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;未完成订单\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询用户未完成的订单信息 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 0 AND text = \u0026#39;\u0026#39; \u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; print(msg) return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, result=res, messages=msg, notFinishedNum=len(res)) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, messages=msg, notFinishedNum=notFinishedNum) # 默认情况，直接渲染评论页面 else: return render_template(\u0026#39;WriteComments.html\u0026#39;, username=username, messages=msg) 该代码定义了一个 Flask 路由 /WriteComments，用于用户查看并管理待评价订单。主要功能是根据用户请求展示待评价的订单列表，包括支持按交易时间或价格排序，并允许用户查看未完成订单。查询的结果会渲染到 WriteComments.html 模板。\n逻辑总结 GET 请求：从数据库中查询用户已完成但未评价的订单，并显示在页面上。 按交易时间排序：查询已完成、待评价的订单，按交易时间降序显示。 按价格排序：查询已完成、待评价的订单，按价格升序显示。 未完成订单：查询用户的未完成订单并显示在页面上。 页面展示：根据查询结果，渲染页面 WriteComments.html 并传递相关数据给前端。 ​\t3.处理用户对订单的评论操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #处理用户对订单的评论操作 @app.route(\u0026#39;/CommentForm\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def CommentFormPage(): msg = \u0026#34;\u0026#34; # 判断用户请求的操作类型 if request.form[\u0026#34;action\u0026#34;] == \u0026#34;写评论\u0026#34;: orderID = request.form[\u0026#39;orderID\u0026#39;] msg = \u0026#34;WriteRequest\u0026#34; return render_template(\u0026#39;CommentForm.html\u0026#39;, username=username, orderID=orderID, messages=msg) # 提交评论操作 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;提交评论\u0026#34;: # 获取表单数据：订单ID、评分、评论文本 orderID = request.form.get(\u0026#39;orderID\u0026#39;) c_rank = request.form.get(\u0026#39;rank\u0026#39;) text = request.form.get(\u0026#39;text\u0026#39;) # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 更新评论内容和评分 sql = \u0026#34;Update ORDER_COMMENT SET text = \u0026#39;{}\u0026#39;, c_rank = {} where orderID = \u0026#39;{}\u0026#39;\u0026#34;.format(text, c_rank, orderID) try: cursor.execute(sql) db.commit() msg = \u0026#34;done\u0026#34; except ValueError as e: msg = \u0026#34;fail\u0026#34; # 渲染评论页面并显示提交结果 return render_template(\u0026#39;CommentForm.html\u0026#39;, messages = msg, username=username) ​\t该代码定义了一个 Flask 路由 /CommentForm，用于处理用户对订单的评论操作，包括填写评论表单和提交评论内容。当用户点击“写评论”或“提交评论”按钮时，程序会相应地渲染评论页面或更新数据库中的评论数据。\n逻辑总结 写评论：当用户点击“写评论”按钮时，获取该订单的 orderID 并渲染 CommentForm.html 模板，以便用户在表单中填写评论内容。 提交评论：当用户提交评论时，将用户输入的评论文本和评分插入数据库的 ORDER_COMMENT 表中。若插入成功，显示“提交成功”消息；否则显示“提交失败”消息。 ​\n","date":"2024-11-11T23:44:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E4%BA%94/","title":"外卖订餐系统-（五）"},{"content":"一. 本次讲解\n​\t404跳转，购物车，个人中心页面，修改个人信息页面，修改密码页面，查看、管理和更新订单信息\n二. 代码讲解：\n​\t1.404跳转\n1 2 3 4 5 # 当发生 404 错误时调用此装饰的函数 @app.errorhandler(404) # 使用 render_template 渲染一个自定义的 404 页面 def page_not_found(error): return render_template(\u0026#34;404.html\u0026#34;), 404 ​\t2.购物车\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 @app.route(\u0026#39;/myOrder\u0026#39;,methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def shoppingCartPage(): # 当请求方法为 GET 时执行以下代码块 if request.method == \u0026#39;GET\u0026#39;: # 连接到 MySQL 数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 执行查询 SHOPPINGCART 表中所有记录的 SQL 语句 sql = \u0026#34;SELECT * FROM SHOPPINGCART\u0026#34; cursor.execute(sql) res = cursor.fetchall() # 如果查询结果不为空 if len(res) != 0: msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;myOrder.html\u0026#39;, username=username, result=res, messages=msg) else:# 如果查询结果为空 msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;myOrder.html\u0026#39;, username=username, messages=msg) # 当 POST 请求的表单字段 \u0026#34;action\u0026#34; 为 \u0026#34;加入购物车\u0026#34; 时 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;加入购物车\u0026#34;: # 获取表单字段的数据 restaurant = request.form[\u0026#39;restaurant\u0026#39;] dishname = request.form[\u0026#39;dishname\u0026#39;] price = (float)(request.form[\u0026#39;price\u0026#39;]) img_res = request.form[\u0026#39;img_res\u0026#39;] db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 插入新记录到 SHOPPINGCART 表 sql1 = \u0026#34;insert into SHOPPINGCART (username,restaurant,dishname,price,img_res) values (\u0026#39;{}\u0026#39;,\u0026#39;{}\u0026#39;,\u0026#39;{}\u0026#39;,{},\u0026#39;{}\u0026#39;) \u0026#34;.format(username,restaurant,dishname,price,img_res) cursor.execute(sql1) # 查询 SHOPPINGCART 表的所有记录 sql = \u0026#34;SELECT * FROM SHOPPINGCART\u0026#34; cursor.execute(sql) res = cursor.fetchall() # 检查查询结果 if len(res) != 0: msg = \u0026#34;done\u0026#34; print(msg) print(len(res)) return render_template(\u0026#39;myOrder.html\u0026#39;, username=username, result=res, messages=msg) else: print(\u0026#34;NULL\u0026#34;) msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;myOrder.html\u0026#39;, username=username, messages=msg) # 当 POST 请求的表单字段 \u0026#34;action\u0026#34; 为 \u0026#34;结算\u0026#34; 时 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;结算\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 从表单字段获取数据 restaurant = request.form[\u0026#39;restaurant\u0026#39;] dishname = request.form[\u0026#39;dishname\u0026#39;] price = request.form[\u0026#39;price\u0026#39;] img_res = request.form[\u0026#39;img_res\u0026#39;] mode = request.form[\u0026#39;mode\u0026#39;] # 获取结算模式（堂食或外送） return render_template(\u0026#39;index.html\u0026#39;) else: return render_template(\u0026#39;index.html\u0026#39;) 这个 Flask 路由处理了三种情况：\nGET 请求：查询购物车中的商品并渲染结果到 myOrder.html 页面。如果购物车为空，显示相关消息。 POST 请求 - 加入购物车：将用户选择的商品信息插入到 SHOPPINGCART 数据库表中，然后查询购物车中的商品并更新显示。 POST 请求 - 结算：获取商品信息和结算模式（堂食或外送），根据模式输出相应的日志，最终跳转到 index.html 页面。 ​\t3.个人中心页面\n1 2 3 4 # 定义路由 \u0026#39;/personal\u0026#39;，用于访问个人页面 @app.route(\u0026#39;/personal\u0026#39;) def personalPage(): return render_template(\u0026#39;personal.html\u0026#39;) ​\t该代码定义了一个用于访问个人页面的路由 /personal。当用户在浏览器中访问该路径时，Flask 会调用 personalPage 函数，该函数通过 render_template 函数渲染 personal.html 模板，并将该页面返回给用户的浏览器展示。\n​\t4.修改个人信息页面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @app.route(\u0026#39;/ModifyPersonalInfo\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def ModifyPersonalInfo(): msg = \u0026#34;\u0026#34; # 处理 GET 请求，显示修改个人信息的页面 if request.method == \u0026#39;GET\u0026#39;: # 渲染 ModifyPersonalInfo.html 模板，传入用户名 return render_template(\u0026#39;ModifyPersonalInfo.html\u0026#39;, username=username) # 处理 POST 请求，用于更新个人信息 if request.method == \u0026#39;POST\u0026#39;: # 从表单中获取用户输入的数据 address = request.form[\u0026#39;address\u0026#39;] phonenum = request.form[\u0026#39;phonenum\u0026#39;] # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 构建 SQL 更新语句，将 address 和 phone 字段更新为用户提供的值 sql = \u0026#34;Update {} SET address = \u0026#39;{}\u0026#39;, phone = \u0026#39;{}\u0026#39; where username = \u0026#39;{}\u0026#39;\u0026#34;.format(userRole, address, phonenum,username) # 执行更新操作 try: cursor.execute(sql) db.commit() msg = \u0026#34;done\u0026#34; except ValueError as e: msg = \u0026#34;fail\u0026#34; # 渲染 ModifyPersonalInfo.html 模板，传入操作结果消息和用户名 return render_template(\u0026#39;ModifyPersonalInfo.html\u0026#39;, messages=msg, username=username) 该代码定义了 /ModifyPersonalInfo 路由，用于显示和更新用户的个人信息页面，支持 GET 和 POST 两种请求：\nGET 请求：显示用户的修改个人信息页面 ModifyPersonalInfo.html，并传入用户名信息以便显示。 POST 请求：更新用户的地址和电话号码。在接收到用户输入后，将其写入数据库。如果操作成功，页面显示成功消息，否则显示失败消息。 ​\t5.修改密码页面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @app.route(\u0026#39;/ModifyPassword\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def ModifyPassword(): msg = \u0026#34;\u0026#34; # 处理 GET 请求，显示修改密码的页面 if request.method == \u0026#39;GET\u0026#39;: # 渲染 ModifyPassword.html 模板，并传入用户名 return render_template(\u0026#39;ModifyPassword.html\u0026#39;, username=username) # 处理 POST 请求，用于更新密码 if request.method == \u0026#39;POST\u0026#39;: psw1 = request.form[\u0026#39;psw1\u0026#39;] psw2 = request.form[\u0026#39;psw2\u0026#39;] # 两次输入密码是否相同 if psw1 == psw2: # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 构建 SQL 更新语句，将用户的密码更新为新值 sql = \u0026#34;Update {} SET password = \u0026#39;{}\u0026#39; where username = \u0026#39;{}\u0026#39;\u0026#34;.format(userRole, psw1, username) try: cursor.execute(sql) db.commit() msg = \u0026#34;done\u0026#34; except ValueError as e: msg = \u0026#34;fail\u0026#34; return render_template(\u0026#39;ModifyPassword.html\u0026#39;, messages=msg, username=username) # 如果两次输入的密码不一致 else: msg = \u0026#34;not equal\u0026#34; return render_template(\u0026#39;ModifyPassword.html\u0026#39;, messages=msg, username=username) 该代码定义了 /ModifyPassword 路由，用于显示和更新用户密码页面，支持 GET 和 POST 两种请求：\nGET 请求：显示 ModifyPassword.html 页面，让用户输入新密码。 POST 请求：处理修改密码操作。若用户两次输入的密码一致，则将新密码更新到数据库中，并显示成功消息；否则，提示密码不一致。 ​\t6.查看、管理和更新订单信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 @app.route(\u0026#39;/OrderPage\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def OrderPage(): msg = \u0026#34;\u0026#34; # 全局变量，用于存储未完成订单数量 global notFinishedNum # 处理 GET 请求，显示订单页面 if request.method == \u0026#39;GET\u0026#39;: msg = \u0026#34;\u0026#34; # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询未完成订单数量 presql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 0\u0026#34; % username cursor.execute(presql) res1 = cursor.fetchall() # 获取未完成订单数量 notFinishedNum = len(res1) # 查询用户的所有订单信息 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39;\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() # 如果有数据 if len(res): msg = \u0026#34;done\u0026#34; print(msg) return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: print(\u0026#34;NULL\u0026#34;) msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, messages=msg) # 按时间降序排序 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按时间排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询按时间降序排序的订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; Order BY transactiontime DESC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, messages=msg) # 按价格升序排序 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按价格排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询按价格升序排序的订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; Order BY cost ASC\u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=notFinishedNum) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, messages=msg, notFinishedNum=notFinishedNum) # 查询未完成订单 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;未完成订单\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询未完成订单 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE username = \u0026#39;%s\u0026#39; AND isFinished = 0 \u0026#34; % username cursor.execute(sql) res = cursor.fetchall() if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, result=res, messages=msg,notFinishedNum=len(res)) else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, messages=msg, notFinishedNum=notFinishedNum) #确认收货 elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;确认收货\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, db=db_name, charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) orderID = request.form[\u0026#39;orderID\u0026#39;] # 确认订单已完成 sql1 = \u0026#34;Update ORDER_COMMENT SET isFinished = 1, text = \u0026#39;\u0026#39; WHERE orderID = \u0026#39;%s\u0026#39; \u0026#34; % orderID cursor.execute(sql1) db.commit() # 获取订单信息，增加菜品销量 sql2 = \u0026#34;select * from ORDER_COMMENT WHERE orderID = \u0026#39;%s\u0026#39; \u0026#34; % orderID cursor.execute(sql2) res1 = cursor.fetchone() restaurant = res1[1] dishname = res1[2] sql = \u0026#34;Update DISHES SET sales = sales+1 WHERE dishname = \u0026#39;{}\u0026#39; AND restaurant = \u0026#39;{}\u0026#39;\u0026#34; .format(dishname, restaurant) cursor.execute(sql) res = cursor.fetchall() msg = \u0026#34;UpdateSucceed\u0026#34; return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, messages=msg) else: return render_template(\u0026#39;OrderPage.html\u0026#39;, username=username, messages=msg) 该代码定义了一个 /OrderPage 路由，用户可以查看、管理和更新订单信息。根据请求的类型和内容，它执行以下几种操作：\nGET 请求：获取用户订单数据和未完成订单数量，并显示在页面上。 按时间排序：根据订单的交易时间降序排序并显示。 按价格排序：根据订单的价格升序排序并显示。 未完成订单：过滤并显示所有未完成的订单。 确认收货：用户确认收货后，将订单标记为完成，同时更新菜品销量。 ","date":"2024-11-11T22:27:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E5%9B%9B/","title":"外卖订餐系统-（四）"},{"content":"一. 本次讲解\n​\t管理员查看评论列表、 用户登录后显示商家列表、选择商家进入菜单列表、查看商家评论、商家查看评论\n二. 代码讲解：\n​\t1管理员查看评论列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @app.route(\u0026#39;/adminCommentList\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def adminCommentPage(): msg = \u0026#34;\u0026#34;# 初始化一个空的消息变量 if request.method == \u0026#39;GET\u0026#39;: # 如果请求方法是GET（即加载页面） msg = \u0026#34;\u0026#34;# 重置消息 # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) # 创建一个cursor对象来执行SQL查询 cursor = db.cursor() try: # 尝试使用数据库“appDB” cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 执行SQL查询，获取所有已完成且文本内容不为空的评论 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE isFinished = 1 and text \u0026lt;\u0026gt; \u0026#39;\u0026#39;\u0026#34; # 执行查询 cursor.execute(sql) # 获取查询结果 res = cursor.fetchall() # 如果有查询结果（即有评论） if len(res) != 0: msg = \u0026#34;done\u0026#34; print(msg) return render_template(\u0026#39;adminCommentList.html\u0026#39;, username=username, result=res, messages=msg) else: # 如果没有查询结果（没有评论） print(\u0026#34;NULL\u0026#34;) msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;adminCommentList.html\u0026#39;, username=username, messages=msg) # 如果请求方法是POST（即用户提交了表单） elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按评分升序排列\u0026#34;:# 如果提交的表单动作是\u0026#34;按评分升序排列\u0026#34; db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 执行SQL查询，按评分升序排列获取所有已完成且文本不为空的评论 sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE isFinished = 1 AND text is not null Order BY c_rank\u0026#34; cursor.execute(sql) res = cursor.fetchall() print(len(res)) if len(res): #如果有查询结果（即有评论） msg = \u0026#34;done\u0026#34; print(msg) return render_template(\u0026#39;adminCommentList.html\u0026#39;, username=username, result=res, messages=msg) else: # 如果没有查询结果（没有评论） print(\u0026#34;NULL\u0026#34;) msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;adminCommentList.html\u0026#39;, username=username, messages=msg) ​\t2.用户登录后显示商家列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @app.route(\u0026#39;/UserRestList\u0026#39;,methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def UserRestListPage(): msg = \u0026#34;\u0026#34; # 如果请求方法是GET（即加载页面） if request.method == \u0026#39;GET\u0026#39;: msg = \u0026#34;\u0026#34; # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 执行SQL查询，获取所有餐厅信息 sql = \u0026#34;SELECT * FROM RESTAURANT\u0026#34; cursor.execute(sql) res = cursor.fetchall() # 如果有查询结果（即有餐厅数据） if len(res) != 0: msg = \u0026#34;done\u0026#34; print(msg) return render_template(\u0026#39;UserRestList.html\u0026#39;, username=username, result=res, messages=msg) else: # 如果没有查询结果（没有餐厅数据） print(\u0026#34;NULL\u0026#34;) msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;UserRestList.html\u0026#39;, username=username, messages=msg) ​\t3.选择商家进入菜单列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @app.route(\u0026#39;/Menu\u0026#39;,methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def menu(): msg = \u0026#34;\u0026#34; # 声明restaurant为全局变量，方便在不同请求之间共享数据 global restaurant # 如果表单动作是\u0026#34;进入本店\u0026#34; if request.form[\u0026#34;action\u0026#34;] == \u0026#34;进入本店\u0026#34;: # 获取用户选择的餐厅名称 restaurant = request.form[\u0026#39;restaurant\u0026#39;] msg = \u0026#34;\u0026#34; # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询餐厅的所有菜品 sql = \u0026#34;SELECT * FROM DISHES WHERE restaurant = \u0026#39;%s\u0026#39;\u0026#34; % restaurant cursor.execute(sql) res = cursor.fetchall() # 如果有查询结果（即有菜品） if len(res) != 0: msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, result=res, messages=msg) else:# 如果没有查询结果（没有菜品） msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, messages=msg) # 如果表单动作是\u0026#34;特色菜\u0026#34; elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;特色菜\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询餐厅的特色菜（isSpecialty = 1表示是特色菜） sql = \u0026#34;SELECT * FROM DISHES WHERE restaurant = \u0026#39;%s\u0026#39; AND isSpecialty = 1\u0026#34; % restaurant cursor.execute(sql) res = cursor.fetchall() # 如果有查询结果（即有特色菜） if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, result=res, messages=msg) else: # 如果没有查询结果（没有特色菜） msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, messages=msg) # 如果表单动作是\u0026#34;按销量排序\u0026#34; elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按销量排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询餐厅的菜品，并按销量降序排序 sql = \u0026#34;SELECT * FROM DISHES WHERE restaurant = \u0026#39;%s\u0026#39; Order BY sales DESC\u0026#34; % restaurant cursor.execute(sql) res = cursor.fetchall() # 如果有查询结果（即有菜品） if len(res): msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, result=res, messages=msg) else: # 如果没有查询结果（没有菜品） msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, messages=msg) # 如果表单动作是\u0026#34;按价格排序\u0026#34; elif request.form[\u0026#34;action\u0026#34;] == \u0026#34;按价格排序\u0026#34;: db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询餐厅的菜品，并按价格降序排序 sql = \u0026#34;SELECT * FROM DISHES WHERE restaurant = \u0026#39;%s\u0026#39; Order BY price DESC\u0026#34; % restaurant cursor.execute(sql) res = cursor.fetchall() if len(res): # 如果有查询结果（即有菜品） msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, result=res, messages=msg) else: # 如果没有查询结果（没有菜品） msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;Menu.html\u0026#39;, username=username, RESTAURANT=restaurant, messages=msg) ​\t4.查看商家评论\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @app.route(\u0026#39;/ResComment\u0026#39;,methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def resComment(): msg = \u0026#34;\u0026#34; global restaurant # 如果表单动作是\u0026#34;查看评价\u0026#34; if request.form[\u0026#34;action\u0026#34;] == \u0026#34;查看评价\u0026#34;: restaurant = request.form[\u0026#39;restaurant\u0026#39;] msg = \u0026#34;\u0026#34; # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询餐厅的已完成评价（isFinished = 1表示评价已完成，text \u0026lt;\u0026gt; \u0026#39;\u0026#39;表示评价内容不为空） sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE restaurant = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text \u0026lt;\u0026gt; \u0026#39;\u0026#39; \u0026#34;% restaurant cursor.execute(sql) res = cursor.fetchall() # 如果查询到评价数据 if len(res) != 0: msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;ResComment.html\u0026#39;, username=username, RESTAURANT=restaurant, result=res, messages=msg) else:# 如果没有查询结果（没有评价数据） msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;ResComment.html\u0026#39;, username=username, RESTAURANT=restaurant, messages=msg) ​\t5.商家查看评论\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @app.route(\u0026#39;/ResCommentList\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def ResCommentList(): msg = \u0026#34;\u0026#34; # 获取当前用户名作为餐厅名称（假设restaurant = username） restaurant=username # 连接数据库 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 查询餐厅的已完成评价（isFinished = 1表示评价已完成，text \u0026lt;\u0026gt; \u0026#39;\u0026#39;表示评价内容不为空） sql = \u0026#34;SELECT * FROM ORDER_COMMENT WHERE restaurant = \u0026#39;%s\u0026#39; AND isFinished = 1 AND text \u0026lt;\u0026gt; \u0026#39;\u0026#39; \u0026#34; % restaurant cursor.execute(sql) res = cursor.fetchall() # 如果查询到评价数据 if len(res) != 0: msg = \u0026#34;done\u0026#34; return render_template(\u0026#39;ResCommentList.html\u0026#39;, username=username, RESTAURANT=restaurant, result=res,messages=msg) # 如果没有查询结果（没有评价数据） else: msg = \u0026#34;none\u0026#34; return render_template(\u0026#39;ResCommentList.html\u0026#39;, username=username, RESTAURANT=restaurant, messages=msg) ","date":"2024-11-11T15:24:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E4%B8%89/","title":"外卖订餐系统-（三）"},{"content":"一. 本次讲解\n​\t首页，登陆和注册\n二. 代码讲解：\n​\t1.首页\n1 2 3 4 5 @app.route(\u0026#39;/\u0026#39;) @app.route(\u0026#39;/index\u0026#39;) # 首页路由 def indexpage(): return render_template(\u0026#39;index.html\u0026#39;) ​\t2.注册\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 # 注册页面的路由和逻辑 @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def registerPage(): global username global userRole msg = \u0026#34;\u0026#34; # GET方法返回注册页面 if request.method == \u0026#39;GET\u0026#39;: return render_template(\u0026#39;Register.html\u0026#39;) # POST方法处理注册逻辑 if request.method == \u0026#39;POST\u0026#39;: username = request.form.get(\u0026#39;username\u0026#39;) password = request.form.get(\u0026#39;password\u0026#39;) phone = request.form.get(\u0026#39;phone\u0026#39;) addr = request.form.get(\u0026#39;addr\u0026#39;) userRole = request.form.get(\u0026#39;userRole\u0026#39;) print(userRole) print(username) # 连接数据库，默认数据库用户名root，密码空 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, port=port,password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) # 根据用户角色分别注册 if userRole == \u0026#39;RESTAURANT\u0026#39;:#商家 cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 检查商家是否已存在 sql1 = \u0026#34;SELECT * from RESTAURANT where username = \u0026#39;{}\u0026#39; \u0026#34;.format(username) cursor.execute(sql1) db.commit() res1 = cursor.fetchall() num = 0 for row in res1: num = num + 1 # 如果商家已注册，返回注册失败信息 if num == 1: print(\u0026#34;失败！商家已注册！\u0026#34;) msg = \u0026#34;fail1\u0026#34; else: # 插入新商家记录 sql2 = \u0026#34;insert into RESTAURANT (username, password, address, phone) values (\u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;) \u0026#34;.format(username, password, addr, phone) try: cursor.execute(sql2) db.commit() print(\u0026#34;商家注册成功\u0026#34;) msg = \u0026#34;done1\u0026#34; except ValueError as e: print(\u0026#34;---\u0026gt;\u0026#34;, e) print(\u0026#34;注册出错，失败\u0026#34;) msg = \u0026#34;fail1\u0026#34; return render_template(\u0026#39;Register.html\u0026#39;, messages=msg, username=username, userRole=userRole) elif userRole == \u0026#39;CUSTOMER\u0026#39;:#客户 cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) # 检查客户是否已存在 sql1 = \u0026#34;SELECT * from CUSTOMER where username = \u0026#39;{}\u0026#39;\u0026#34;.format(username) cursor.execute(sql1) db.commit() res1 = cursor.fetchall() num = 0 for row in res1: num = num + 1 # 如果用户已注册，返回注册失败信息 if num == 1: print(\u0026#34;用户已注册！请直接登录。\u0026#34;) msg = \u0026#34;fail2\u0026#34; else:# 插入新用户记录 sql2 = \u0026#34;insert into CUSTOMER (username, password, address, phone) values (\u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;) \u0026#34;.format(username, password, addr, phone) try: cursor.execute(sql2) db.commit() print(\u0026#34;商家注册成功\u0026#34;) msg = \u0026#34;done2\u0026#34; except ValueError as e: print(\u0026#34;---\u0026gt;\u0026#34;, e) print(\u0026#34;注册出错，失败\u0026#34;) msg = \u0026#34;fail2\u0026#34; return render_template(\u0026#39;Register.html\u0026#39;, messages=msg, username=username, userRole=userRole) ​\t3.登陆\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 # 登录页面的路由和逻辑 @app.route(\u0026#39;/logIn\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def logInPage(): global username global userRole msg = \u0026#34;\u0026#34; # GET方法返回登陆页面 if request.method == \u0026#39;GET\u0026#39;: return render_template(\u0026#39;logIn.html\u0026#39;) # POST方法处理登陆逻辑 if request.method == \u0026#39;POST\u0026#39;: username = request.form.get(\u0026#39;username\u0026#39;) password = request.form.get(\u0026#39;password\u0026#39;) userRole = request.form.get(\u0026#39;userRole\u0026#39;) print(userRole) print(username) # 连接数据库，默认数据库用户名root，密码空 db = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;,port=port, password=mysql_pwd, database=db_name,charset=\u0026#39;utf8\u0026#39;) if userRole == \u0026#39;ADMIN\u0026#39;:#管理员 cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) sql = \u0026#34;SELECT * from ADMIN where username = \u0026#39;{}\u0026#39; and password=\u0026#39;{}\u0026#39;\u0026#34;.format(username, password) cursor.execute(sql) db.commit() res = cursor.fetchall() num = 0 for row in res: num = num + 1 # 如果存在该管理员且密码正确 if num == 1: print(\u0026#34;登录成功！欢迎管理员！\u0026#34;) msg = \u0026#34;done1\u0026#34; else: print(\u0026#34;您没有管理员权限或登录信息出错。\u0026#34;) msg = \u0026#34;fail1\u0026#34; return render_template(\u0026#39;logIn.html\u0026#39;, messages=msg, username=username, userRole=userRole) elif userRole == \u0026#39;RESTAURANT\u0026#39;:#商家 cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) sql = \u0026#34;SELECT * from RESTAURANT where username = \u0026#39;{}\u0026#39; and password=\u0026#39;{}\u0026#39;\u0026#34;.format(username, password) cursor.execute(sql) db.commit() res = cursor.fetchall() num = 0 for row in res: num = num + 1 # 如果存在该商家且密码正确 if num == 1: print(\u0026#34;登录成功！欢迎商家用户！\u0026#34;) msg = \u0026#34;done2\u0026#34; else: print(\u0026#34;您没有商家用户权限或登录信息出错。\u0026#34;) msg = \u0026#34;fail2\u0026#34; return render_template(\u0026#39;logIn.html\u0026#39;, messages=msg, username=username, userRole=userRole) elif userRole == \u0026#39;CUSTOMER\u0026#39;:#用户 cursor = db.cursor() try: cursor.execute(\u0026#34;use appDB\u0026#34;) except: print(\u0026#34;Error: unable to use database!\u0026#34;) sql = \u0026#34;SELECT * from CUSTOMER where username = \u0026#39;{}\u0026#39; and password=\u0026#39;{}\u0026#39;\u0026#34;.format(username, password) cursor.execute(sql) db.commit() res = cursor.fetchall() num = 0 for row in res: num = num + 1 # 如果存在该用户且密码正确 if num == 1: print(\u0026#34;登录成功！欢迎用户！\u0026#34;) msg = \u0026#34;done3\u0026#34; else: print(\u0026#34;您没有用户权限，未注册或登录信息出错。\u0026#34;) msg = \u0026#34;fail3\u0026#34; return render_template(\u0026#39;logIn.html\u0026#39;, messages=msg, username=username, userRole=userRole) ","date":"2024-11-11T14:37:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E4%BA%8C/","title":"外卖订餐系统-（二）"},{"content":"一. 项目描述\n​\t本项目用于数据库实验课选做项目的大作业，基于python实现外卖订餐系统\n二. 代码讲解：\n1 2 3 4 5 6 7 from flask import Flask, render_template, request, redirect, url_for, flash from werkzeug.utils import secure_filename import pymysql import os import argparse import sys import importlib 代码引入了 Flask（用于创建 Web 应用）、render_template（渲染 HTML 页面）、request（处理请求）、redirect 和 url_for（页面跳转）、flash（闪现消息）、secure_filename（用于安全保存上传的文件名），以及 pymysql（用于连接和操作 MySQL 数据库）。\n1 2 3 4 # 重新加载sys模块配置 importlib.reload(sys) app = Flask(__name__) importlib.reload(sys)：重新加载 sys 模块，通常用于确保加载的是最新版本，或者在修改模块时使用。\napp = Flask(__name__)：创建一个 Flask 应用实例，__name__ 用于确定应用的根路径，方便管理路由和静态文件。\n1 2 3 4 # MySQL配置变量 mysql_pwd = \u0026#34;6021123456\u0026#34; db_name = \u0026#34;appdb\u0026#34; port = 3340 用于数据库连接的配置信息，依次是我的密码，数据库名和mysql的端口号\n1 2 3 4 # 全局变量 username = \u0026#34;\u0026#34; userRole = \u0026#34;\u0026#34; notFinishedNum = 0 全局变量，用来处理总体的信息\nusername变量的赋值\n方法1：全局变量实现，随登录进行修改 方法2：给每个页面传递username\n1 2 3 4 5 6 7 # 设置文件上传目录和允许的扩展名 UPLOAD_FOLDER = \u0026#39;/static/images/\u0026#39; ALLOWED_EXTENSIONS = set([ \u0026#39;png\u0026#39;, \u0026#39;jpg\u0026#39;, \u0026#39;jpeg\u0026#39;]) # 检查上传文件的扩展名是否合法 def allowed_file(filename): return \u0026#39;.\u0026#39; in filename and \\ filename.rsplit(\u0026#39;.\u0026#39;, 1)[1] in ALLOWED_EXTENSIONS 设置文件上传目录和允许的扩展名\n检查上传文件的扩展名是否合法\n","date":"2024-11-11T14:22:00+08:00","permalink":"https://1878247293.github.io/p/%E5%A4%96%E5%8D%96%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F-%E4%B8%80/","title":"外卖订餐系统-（一）"},{"content":"一. 问题描述\n删除文件的时候只能永久删除，而无法放入回收站。\n二.解决方法：\n查阅大量资料后，最终的方法如下：\n​\t1.使用 Windows + R 快捷键打开「运行」对话框，执行 control folders 命令打开「文件夹选项」，有的 Windows 版本中也叫「文件资源管理器选项」。\n​\t2.切换到「查看」菜单，在「高级设置」中： 取消勾选「隐藏受保护的操作系统文件（推荐）」 选择「显示隐藏的文件、文件夹和驱动器」。 设置文件资源管理器选项 。\n​\t3.点击「确定」应用并关闭窗口。\n​\t4.打开C盘和D盘的文件夹，分别将$recycle.bin 文件夹删掉（运行回收站的时候会自动生成这个文件夹，所以不用担心）\n","date":"2024-11-10T22:26:00+08:00","permalink":"https://1878247293.github.io/p/%E5%9B%9E%E6%94%B6%E7%AB%99%E6%97%A0%E6%B3%95%E6%94%BE%E5%85%A5%E6%96%87%E4%BB%B6/","title":"回收站无法放入文件"},{"content":"一. 实习总结\n本次实习完成的任务是通过java代码来实现对krb5的调用、获取TGT以及能手动更改TGT的有效时间。\n二. 实习收获：\n作为第一次的实习，大部分时间都用来熟悉工作环境和工作流程以及查阅一些关于krb5的资料。\n通过本次实习，我了解到了：\n如何ssh远程调用虚拟机来进行调试\nGit的提交和推送操作\nNginx对Restful API接口进行https的操作处理\n了解到了大致的工作分工的模式以及情况\n对于工作之间的交接和交流也有了一定的经验\n三. 实习所学到的知识：\n学到了如下：\n初步了解到了javaweb关于后端和redis、mysql（crud）的相关知识\n初步了解到springboot框架、restful接口以及对他们的使用经验\n实操的git的常用操作\n实操了JWT的操作\n对于nginx也有了初步的认识和使用经验\n学会了idea通过ssh进行远程操作的步骤\n四．工具详情：\n通过提供用户的用户名和密码、以及邮箱和TGT的有效时间等等可以获取到krb5的TGT。\n难点分析：\n相比于其它热门知识来讲，网上资料过少，了解的难度过大\n设置TGT的有效时间时，这里通过创建临时文件的方式，但却存在补充下加载配置的问题。最后查阅了多天的资料后，以及不断的尝试，发现的解决的方法（jaas.conf）\n","date":"2024-11-10T20:50:00+08:00","permalink":"https://1878247293.github.io/p/java%E8%BF%9C%E7%A8%8B%E9%93%BE%E6%8E%A5krb5/","title":"Java远程链接krb5"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://1878247293.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://1878247293.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://1878247293.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://1878247293.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://1878247293.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://1878247293.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://1878247293.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://1878247293.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://1878247293.github.io/p/emoji-support/","title":"Emoji Support"}]